/******************************************************************************
Copyright (c) Likhon Sheikh - @likhonsheikh on Telegram

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
// src/lib/agent-generator.ts (Updated for AI SDK 5 Beta)

export interface AgentConfig {
  name: string;
  persona: string;
  tools: string[]; // e.g., ['web_search', 'calculator']
  initialPrompt: string;
  // New: Agentic control options
  maxSteps?: number;
  stopTool?: string; // Name of a tool to stop when called
  // Spend management options
  budgetConfig?: {
    monthlyBudget: number;
    currency?: string;
    alertThresholds?: number[]; // Percentages to trigger alerts at
    currentSpend?: number;
  };
}

// A helper function to simulate an AI tool
function generateToolFunction(toolName: string): string {
  switch (toolName) {
    case 'web_search':
      return `
// A simulated web search tool. In a real app, this would integrate with a search API.
const webSearch = async (query: string): Promise<string> => {
  console.log(\`[Tool Call] Performing web search for: \${query}\`);
  await new Promise(resolve => setTimeout(resolve, 500)); // Simulate async work
  return \`Search results for "\${query}": [Simulated: Latest AI trend is advanced multimodal models.]\`;
};
`;
    case 'calculator':
      return `
// A simulated calculator tool.
const calculator = (expression: string): number | string => {
  try {
    const result = eval(expression); // WARNING: eval is dangerous in production! Use a safe math library.
    console.log(\`[Tool Call] Calculating \${expression} = \${result}\`);
    return result;
  } catch (e) {
    return \`Error calculating \${expression}\`;
  }
};
`;
    default:
      return `// No specific function for tool: ${toolName}`;
  }
}

// Generates the TypeScript code for the AI agent
export function generateAgentCode(config: AgentConfig): string {
  const { name, persona, tools, initialPrompt, maxSteps, stopTool } = config;

  const toolFunctions = tools.map(generateToolFunction).join('\n');

  // Agentic control logic
  let stopWhenCondition = '';
  if (maxSteps) {
    stopWhenCondition += `stopWhen: stepCountIs(${maxSteps}),`;
  }
  if (stopTool && tools.includes(stopTool)) {
    stopWhenCondition += `\n      stopWhen: hasToolCall('${stopTool}'),`;
  }
  // If both, the last one overrides or they can be combined with 'or'/'and' logic if needed.
  // For simplicity, we'll just add them sequentially, implying the last one wins if multiple `stopWhen` are used,
  // or that they apply separately if `generateObject` handles multiple `stopWhen` calls.
  // In reality, you'd combine them into a single condition like `stopWhen: or(stepCountIs(X), hasToolCall(Y))`

  return `
// This code was generated by your No-Code AI Agent Builder (AI SDK 5 Beta)!

import { generateObject, streamText, tool } from 'ai'; // Updated imports
import { google } from '@ai-sdk/google'; // Updated provider import
import { z } from 'zod'; // For tool schema validation
${maxSteps || stopTool ? `import { stepCountIs, hasToolCall } from 'ai/agents'; // For agentic control` : ''}


// --- Agent Configuration ---
const AGENT_NAME = "${name}";
const AGENT_PERSONA = \`${persona.replace(/`/g, '\\`')}\`; // Escape backticks
const INITIAL_PROMPT = \`${initialPrompt.replace(/`/g, '\\`')}\`; // Escape backticks

// --- AI Model Initialization ---
const model = google('models/gemini-1.5-pro'); // Or 'models/gemini-pro' for non-tool-calling

// --- Agent Tools ---
${toolFunctions}

// Define the AI SDK 5 Beta tools (using Zod for schema and 'tool' helper)
const agentTools = {
  ${tools.map(toolName => {
    switch(toolName) {
      case 'web_search':
        return `webSearch: tool({
          description: "Searches the web for information based on a query.",
          parameters: z.object({
            query: z.string().describe("The search query"),
          }),
          execute: webSearch,
        })`;
      case 'calculator':
        return `calculator: tool({
          description: "Performs mathematical calculations.",
          parameters: z.object({
            expression: z.string().describe("The mathematical expression to calculate"),
          }),
          execute: calculator,
        })`;
      default:
        return `// Custom tool '${toolName}' - define its schema and execute function here`;
    }
  }).join(',\n  ')}
};

// --- Main Agent Logic ---
// Calculate estimated cost based on token usage and tool calls
function calculateEstimatedCost(tokensUsed: number, toolCalls: number): number {
  // Simplified cost model - replace with actual pricing
  const TOKEN_COST = 0.000002; // $0.002 per 1K tokens
  const TOOL_COST = 0.0001; // $0.0001 per tool call
  return (tokensUsed * TOKEN_COST) + (toolCalls * TOOL_COST);
}

async function runAgent(config: AgentConfig) {
  console.log(\`--- Running \${config.name} ---\`);
  console.log(\`Persona: \${config.persona}\`);
  console.log(\`Initial Prompt: \${config.initialPrompt}\`);

  let tokensUsed = 0;
  let toolCallsCount = 0;

  try {
    // Check budget if configured
    if (config.budgetConfig?.monthlyBudget) {
      const { monthlyBudget, currentSpend = 0 } = config.budgetConfig;
      const remainingBudget = monthlyBudget - currentSpend;
      if (remainingBudget <= 0) {
        console.error('Budget exceeded! Current monthly spend:', currentSpend);
        throw new Error('Monthly budget has been exceeded');
      }
      console.log(\`Budget available: \${remainingBudget.toFixed(2)} of \${monthlyBudget}\`);
    }
    const { object: result, toolResults, usage } = await generateObject({ // 'generateObject' is now preferred for tool calling
      model: model,
      system: config.persona,
      prompt: config.initialPrompt,
      tools: agentTools, // Use the new agentTools object
      // Agentic control options
      ${stopWhenCondition}
    });

    // Handle the final result
    // The 'result' from generateObject will contain the final text response or the last tool call output.
    if (result) { // generateObject returns 'object' for the final text or tool output
        console.log("Final Agent Response (Object):");
        console.log(JSON.stringify(result, null, 2));
    }

    if (toolResults && toolResults.length > 0) {
        console.log("Agent performed tool call(s).");
        toolResults.forEach(res => {
            console.log(\`Tool: \${res.toolName}, Args: \${JSON.stringify(res.args)}, Result: \${JSON.stringify(res.result)}\`);
        });
    } else {
        console.log("Agent completed without explicit tool calls.");
    }

  } catch (error) {
    console.error("Error running agent:", error);
    console.error("Ensure GEMINI_API_KEY is correctly set and the model supports tool calling.");
  }
}

// To run the agent, you would call runAgent with a config object.
// Example:
// const myAgentConfig: AgentConfig = {
//   name: 'My Agent',
//   persona: 'You are a helpful assistant.',
//   tools: ['web_search'],
//   initialPrompt: 'Search for the latest AI news.'
// };
// runAgent(myAgentConfig);

// For demonstration purposes, export the runAgent function
export { runAgent };
`;
}
