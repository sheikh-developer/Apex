/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_action-browser_src_lib_ai_mcp-agent_ts";
exports.ids = ["_action-browser_src_lib_ai_mcp-agent_ts"];
exports.modules = {

/***/ "(action-browser)/./src/lib/ai/mcp-agent.ts":
/*!*********************************!*\
  !*** ./src/lib/ai/mcp-agent.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApexMCPAgent: () => (/* binding */ ApexMCPAgent)\n/* harmony export */ });\n/* harmony import */ var _google_genai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @google/genai */ \"(action-browser)/./node_modules/@google/genai/dist/node/index.mjs\");\n/* harmony import */ var _modelcontextprotocol_sdk_client_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @modelcontextprotocol/sdk/client/index.js */ \"(action-browser)/./node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js\");\n/* harmony import */ var _modelcontextprotocol_sdk_client_stdio_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @modelcontextprotocol/sdk/client/stdio.js */ \"(action-browser)/./node_modules/@modelcontextprotocol/sdk/dist/esm/client/stdio.js\");\n// Apex with MCP Server Integration\n\n\n\nclass ApexMCPAgent {\n    constructor(apiKey, config = {}){\n        this.mcpClients = new Map();\n        this.availableTools = new Map();\n        const key = apiKey || process.env.GEMINI_API_KEY;\n        if (!key) {\n            throw new Error('GEMINI_API_KEY must be provided or set in environment');\n        }\n        this.ai = new _google_genai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenAI({\n            apiKey: key\n        });\n        this.config = {\n            model: 'gemini-2.5-flash',\n            temperature: 0.7,\n            maxTokens: 8192,\n            thinkingBudget: 24576,\n            workingDirectory: process.cwd(),\n            mcpServers: {\n                // Web Automation\n                puppeteer: {\n                    command: 'npx',\n                    args: [\n                        '-y',\n                        '@modelcontextprotocol/server-puppeteer'\n                    ]\n                },\n                playwright: {\n                    command: 'npx',\n                    args: [\n                        '@playwright/mcp@latest',\n                        '--headless'\n                    ]\n                },\n                // System & Memory\n                memory: {\n                    command: 'npx',\n                    args: [\n                        '-y',\n                        '@modelcontextprotocol/server-memory'\n                    ]\n                },\n                filesystem: {\n                    command: 'npx',\n                    args: [\n                        '-y',\n                        '@modelcontextprotocol/server-filesystem',\n                        config.workingDirectory || process.cwd()\n                    ]\n                },\n                time: {\n                    command: 'uvx',\n                    args: [\n                        'mcp-server-time',\n                        '--local-timezone=America/New_York'\n                    ]\n                },\n                // Development Tools\n                github: {\n                    command: 'npx',\n                    args: [\n                        '-y',\n                        '@modelcontextprotocol/server-github'\n                    ],\n                    env: {\n                        GITHUB_PERSONAL_ACCESS_TOKEN: process.env.GITHUB_PERSONAL_ACCESS_TOKEN || ''\n                    }\n                },\n                // AI Enhancement\n                'sequential-thinking': {\n                    command: 'npx',\n                    args: [\n                        '-y',\n                        '@modelcontextprotocol/server-sequential-thinking'\n                    ]\n                }\n            },\n            ...config\n        };\n    }\n    async initialize() {\n        console.log('üöÄ Initializing Apex with MCP servers...\\n');\n        for (const [serverName, serverConfig] of Object.entries(this.config.mcpServers)){\n            try {\n                await this.connectMCPServer(serverName, serverConfig);\n            } catch (error) {\n                console.warn(`‚ö†Ô∏è  Could not connect to ${serverName}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n        console.log(`‚úÖ Initialized with ${this.mcpClients.size} MCP servers\\n`);\n        this.logAvailableTools();\n    }\n    async connectMCPServer(name, config) {\n        const transport = new _modelcontextprotocol_sdk_client_stdio_js__WEBPACK_IMPORTED_MODULE_2__.StdioClientTransport({\n            command: config.command,\n            args: config.args,\n            env: {\n                ...process.env,\n                ...config.env\n            }\n        });\n        const client = new _modelcontextprotocol_sdk_client_index_js__WEBPACK_IMPORTED_MODULE_1__.Client({\n            name: `apex-${name}-client`,\n            version: '1.0.0'\n        }, {\n            capabilities: {\n                resources: {},\n                tools: {},\n                prompts: {}\n            }\n        });\n        await client.connect(transport);\n        this.mcpClients.set(name, client);\n        // Get available tools from this server\n        const toolsResponse = await client.listTools();\n        toolsResponse.tools.forEach((tool)=>{\n            this.availableTools.set(tool.name, {\n                ...tool,\n                server: name\n            });\n        });\n        console.log(`‚úÖ Connected to ${name} (${toolsResponse.tools.length} tools)`);\n    }\n    logAvailableTools() {\n        console.log('üîß Available Tools:');\n        for (const [toolName, toolInfo] of this.availableTools.entries()){\n            console.log(`   ‚Ä¢ ${toolName} (${toolInfo.server}): ${toolInfo.description || 'No description'}`);\n        }\n        console.log('');\n    }\n    async executeMCPTool(toolName, parameters) {\n        const toolInfo = this.availableTools.get(toolName);\n        if (!toolInfo) {\n            throw new Error(`Tool ${toolName} not available`);\n        }\n        const client = this.mcpClients.get(toolInfo.server);\n        if (!client) {\n            throw new Error(`MCP client for ${toolInfo.server} not connected`);\n        }\n        try {\n            const result = await client.callTool({\n                name: toolName,\n                arguments: parameters\n            });\n            return result;\n        } catch (error) {\n            console.error(`Error executing ${toolName}:`, error);\n            throw error;\n        }\n    }\n    async cleanup() {\n        console.log('\\nüßπ Cleaning up MCP connections...');\n        for (const [name, client] of this.mcpClients.entries()){\n            try {\n                await client.close();\n                console.log(`‚úÖ Closed ${name}`);\n            } catch (error) {\n                console.warn(`‚ö†Ô∏è  Error closing ${name}:`, error);\n            }\n        }\n        this.mcpClients.clear();\n        this.availableTools.clear();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL3NyYy9saWIvYWkvbWNwLWFnZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxtQ0FBbUM7QUFDUztBQUN1QjtBQUNjO0FBcUIxRSxNQUFNRztJQU1YQyxZQUFZQyxNQUFlLEVBQUVDLFNBQXdCLENBQUMsQ0FBQyxDQUFFO2FBSGpEQyxhQUFrQyxJQUFJQzthQUN0Q0MsaUJBQW1DLElBQUlEO1FBRzdDLE1BQU1FLE1BQU1MLFVBQVVNLFFBQVFDLEdBQUcsQ0FBQ0MsY0FBYztRQUNoRCxJQUFJLENBQUNILEtBQUs7WUFDUixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFFQSxJQUFJLENBQUNDLEVBQUUsR0FBRyxJQUFJZixzREFBV0EsQ0FBQztZQUFFSyxRQUFRSztRQUFJO1FBQ3hDLElBQUksQ0FBQ0osTUFBTSxHQUFHO1lBQ1pVLE9BQU87WUFDUEMsYUFBYTtZQUNiQyxXQUFXO1lBQ1hDLGdCQUFnQjtZQUNoQkMsa0JBQWtCVCxRQUFRVSxHQUFHO1lBQzdCQyxZQUFZO2dCQUNWLGlCQUFpQjtnQkFDakJDLFdBQVc7b0JBQ1RDLFNBQVM7b0JBQ1RDLE1BQU07d0JBQUM7d0JBQU07cUJBQXlDO2dCQUN4RDtnQkFDQUMsWUFBWTtvQkFDVkYsU0FBUztvQkFDVEMsTUFBTTt3QkFBQzt3QkFBMEI7cUJBQWE7Z0JBQ2hEO2dCQUVBLGtCQUFrQjtnQkFDbEJFLFFBQVE7b0JBQ05ILFNBQVM7b0JBQ1RDLE1BQU07d0JBQUM7d0JBQU07cUJBQXNDO2dCQUNyRDtnQkFDQUcsWUFBWTtvQkFDVkosU0FBUztvQkFDVEMsTUFBTTt3QkFBQzt3QkFBTTt3QkFBMkNuQixPQUFPYyxnQkFBZ0IsSUFBSVQsUUFBUVUsR0FBRztxQkFBRztnQkFDbkc7Z0JBQ0FRLE1BQU07b0JBQ0pMLFNBQVM7b0JBQ1RDLE1BQU07d0JBQUM7d0JBQW1CO3FCQUFvQztnQkFDaEU7Z0JBRUEsb0JBQW9CO2dCQUNwQkssUUFBUTtvQkFDTk4sU0FBUztvQkFDVEMsTUFB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U0FBUyxJQUFJLENBQUN4QyxVQUFVLENBQUMyRCxHQUFHLENBQUNKLFNBQVNILE1BQU07UUFDbEQsSUFBSSxDQUFDWixRQUFRO1lBQ1gsTUFBTSxJQUFJakMsTUFBTSxDQUFDLGVBQWUsRUFBRWdELFNBQVNILE1BQU0sQ0FBQyxjQUFjLENBQUM7UUFDbkU7UUFFQSxJQUFJO1lBQ0YsTUFBTVEsU0FBUyxNQUFNcEIsT0FBT3FCLFFBQVEsQ0FBQztnQkFDbkN2QixNQUFNZ0I7Z0JBQ05RLFdBQVdKO1lBQ2I7WUFDQSxPQUFPRTtRQUNULEVBQUUsT0FBTzNCLE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLENBQUMsZ0JBQWdCLEVBQUVxQixTQUFTLENBQUMsQ0FBQyxFQUFFckI7WUFDOUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBTThCLFVBQXlCO1FBQzdCckMsUUFBUUMsR0FBRyxDQUFDO1FBRVosS0FBSyxNQUFNLENBQUNXLE1BQU1FLE9BQU8sSUFBSSxJQUFJLENBQUN4QyxVQUFVLENBQUMrQixPQUFPLEdBQUk7WUFDdEQsSUFBSTtnQkFDRixNQUFNUyxPQUFPd0IsS0FBSztnQkFDbEJ0QyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxTQUFTLEVBQUVXLE1BQU07WUFDaEMsRUFBRSxPQUFPTCxPQUFPO2dCQUNkUCxRQUFRUSxJQUFJLENBQUMsQ0FBQyxrQkFBa0IsRUFBRUksS0FBSyxDQUFDLENBQUMsRUFBRUw7WUFDN0M7UUFDRjtRQUVBLElBQUksQ0FBQ2pDLFVBQVUsQ0FBQ2lFLEtBQUs7UUFDckIsSUFBSSxDQUFDL0QsY0FBYyxDQUFDK0QsS0FBSztJQUMzQjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxpa2hvXFxPbmVEcml2ZVxcR2l0SHViXFxBcGV4XFxzcmNcXGxpYlxcYWlcXG1jcC1hZ2VudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBcGV4IHdpdGggTUNQIFNlcnZlciBJbnRlZ3JhdGlvblxyXG5pbXBvcnQgeyBHb29nbGVHZW5BSSB9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xyXG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tICdAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2NsaWVudC9pbmRleC5qcyc7XHJcbmltcG9ydCB7IFN0ZGlvQ2xpZW50VHJhbnNwb3J0IH0gZnJvbSAnQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9jbGllbnQvc3RkaW8uanMnO1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XHJcblxyXG5pbnRlcmZhY2UgTUNQU2VydmVyQ29uZmlnIHtcclxuICBjb21tYW5kOiBzdHJpbmc7XHJcbiAgYXJnczogc3RyaW5nW107XHJcbiAgZW52PzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcclxuICB1cmw/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBBcGV4TUNQQ29uZmlnIHtcclxuICBtb2RlbD86IHN0cmluZztcclxuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcclxuICBtYXhUb2tlbnM/OiBudW1iZXI7XHJcbiAgdGhpbmtpbmdCdWRnZXQ/OiBudW1iZXI7XHJcbiAgbWNwU2VydmVycz86IFJlY29yZDxzdHJpbmcsIE1DUFNlcnZlckNvbmZpZz47XHJcbiAgd29ya2luZ0RpcmVjdG9yeT86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFwZXhNQ1BBZ2VudCB7XHJcbiAgcHJpdmF0ZSBhaTogR29vZ2xlR2VuQUk7XHJcbiAgcHJpdmF0ZSBjb25maWc6IEFwZXhNQ1BDb25maWc7XHJcbiAgcHJpdmF0ZSBtY3BDbGllbnRzOiBNYXA8c3RyaW5nLCBDbGllbnQ+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgYXZhaWxhYmxlVG9vbHM6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwaUtleT86IHN0cmluZywgY29uZmlnOiBBcGV4TUNQQ29uZmlnID0ge30pIHtcclxuICAgIGNvbnN0IGtleSA9IGFwaUtleSB8fCBwcm9jZXNzLmVudi5HRU1JTklfQVBJX0tFWTtcclxuICAgIGlmICgha2V5KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignR0VNSU5JX0FQSV9LRVkgbXVzdCBiZSBwcm92aWRlZCBvciBzZXQgaW4gZW52aXJvbm1lbnQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5haSA9IG5ldyBHb29nbGVHZW5BSSh7IGFwaUtleToga2V5IH0pO1xyXG4gICAgdGhpcy5jb25maWcgPSB7XHJcbiAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuNS1mbGFzaCcsXHJcbiAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXHJcbiAgICAgIG1heFRva2VuczogODE5MixcclxuICAgICAgdGhpbmtpbmdCdWRnZXQ6IDI0NTc2LFxyXG4gICAgICB3b3JraW5nRGlyZWN0b3J5OiBwcm9jZXNzLmN3ZCgpLFxyXG4gICAgICBtY3BTZXJ2ZXJzOiB7XHJcbiAgICAgICAgLy8gV2ViIEF1dG9tYXRpb25cclxuICAgICAgICBwdXBwZXRlZXI6IHtcclxuICAgICAgICAgIGNvbW1hbmQ6ICducHgnLFxyXG4gICAgICAgICAgYXJnczogWycteScsICdAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2VydmVyLXB1cHBldGVlciddXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwbGF5d3JpZ2h0OiB7XHJcbiAgICAgICAgICBjb21tYW5kOiAnbnB4JywgXHJcbiAgICAgICAgICBhcmdzOiBbJ0BwbGF5d3JpZ2h0L21jcEBsYXRlc3QnLCAnLS1oZWFkbGVzcyddXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBTeXN0ZW0gJiBNZW1vcnlcclxuICAgICAgICBtZW1vcnk6IHtcclxuICAgICAgICAgIGNvbW1hbmQ6ICducHgnLFxyXG4gICAgICAgICAgYXJnczogWycteScsICdAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2VydmVyLW1lbW9yeSddXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaWxlc3lzdGVtOiB7XHJcbiAgICAgICAgICBjb21tYW5kOiAnbnB4JyxcclxuICAgICAgICAgIGFyZ3M6IFsnLXknLCAnQG1vZGVsY29udGV4dHByb3RvY29sL3NlcnZlci1maWxlc3lzdGVtJywgY29uZmlnLndvcmtpbmdEaXJlY3RvcnkgfHwgcHJvY2Vzcy5jd2QoKV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHRpbWU6IHtcclxuICAgICAgICAgIGNvbW1hbmQ6ICd1dngnLFxyXG4gICAgICAgICAgYXJnczogWydtY3Atc2VydmVyLXRpbWUnLCAnLS1sb2NhbC10aW1lem9uZT1BbWVyaWNhL05ld19Zb3JrJ11cclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERldmVsb3BtZW50IFRvb2xzXHJcbiAgICAgICAgZ2l0aHViOiB7XHJcbiAgICAgICAgICBjb21tYW5kOiAnbnB4JyxcclxuICAgICAgICAgIGFyZ3M6IFsnLXknLCAnQG1vZGVsY29udGV4dHByb3RvY29sL3NlcnZlci1naXRodWInXSxcclxuICAgICAgICAgIGVudjoge1xyXG4gICAgICAgICAgICBHSVRIVUJfUEVSU09OQUxfQUNDRVNTX1RPS0VOOiBwcm9jZXNzLmVudi5HSVRIVUJfUEVSU09OQUxfQUNDRVNTX1RPS0VOIHx8ICcnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICAvLyBBSSBFbmhhbmNlbWVudFxyXG4gICAgICAgICdzZXF1ZW50aWFsLXRoaW5raW5nJzoge1xyXG4gICAgICAgICAgY29tbWFuZDogJ25weCcsXHJcbiAgICAgICAgICBhcmdzOiBbJy15JywgJ0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZXJ2ZXItc2VxdWVudGlhbC10aGlua2luZyddXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICAuLi5jb25maWdcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbml0aWFsaXplKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc29sZS5sb2coJ/CfmoAgSW5pdGlhbGl6aW5nIEFwZXggd2l0aCBNQ1Agc2VydmVycy4uLlxcbicpO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IFtzZXJ2ZXJOYW1lLCBzZXJ2ZXJDb25maWddIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29uZmlnLm1jcFNlcnZlcnMhKSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdE1DUFNlcnZlcihzZXJ2ZXJOYW1lLCBzZXJ2ZXJDb25maWcpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPICBDb3VsZCBub3QgY29ubmVjdCB0byAke3NlcnZlck5hbWV9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYOKchSBJbml0aWFsaXplZCB3aXRoICR7dGhpcy5tY3BDbGllbnRzLnNpemV9IE1DUCBzZXJ2ZXJzXFxuYCk7XHJcbiAgICB0aGlzLmxvZ0F2YWlsYWJsZVRvb2xzKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGNvbm5lY3RNQ1BTZXJ2ZXIobmFtZTogc3RyaW5nLCBjb25maWc6IE1DUFNlcnZlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFN0ZGlvQ2xpZW50VHJhbnNwb3J0KHtcclxuICAgICAgY29tbWFuZDogY29uZmlnLmNvbW1hbmQsXHJcbiAgICAgIGFyZ3M6IGNvbmZpZy5hcmdzLFxyXG4gICAgICBlbnY6IHsgLi4ucHJvY2Vzcy5lbnYsIC4uLmNvbmZpZy5lbnYgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCh7XHJcbiAgICAgIG5hbWU6IGBhcGV4LSR7bmFtZX0tY2xpZW50YCxcclxuICAgICAgdmVyc2lvbjogJzEuMC4wJ1xyXG4gICAgfSwge1xyXG4gICAgICBjYXBhYmlsaXRpZXM6IHtcclxuICAgICAgICByZXNvdXJjZXM6IHt9LFxyXG4gICAgICAgIHRvb2xzOiB7fSxcclxuICAgICAgICBwcm9tcHRzOiB7fVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBhd2FpdCBjbGllbnQuY29ubmVjdCh0cmFuc3BvcnQpO1xyXG4gICAgdGhpcy5tY3BDbGllbnRzLnNldChuYW1lLCBjbGllbnQpO1xyXG5cclxuICAgIC8vIEdldCBhdmFpbGFibGUgdG9vbHMgZnJvbSB0aGlzIHNlcnZlclxyXG4gICAgY29uc3QgdG9vbHNSZXNwb25zZSA9IGF3YWl0IGNsaWVudC5saXN0VG9vbHMoKTtcclxuICAgIHRvb2xzUmVzcG9uc2UudG9vbHMuZm9yRWFjaCh0b29sID0+IHtcclxuICAgICAgdGhpcy5hdmFpbGFibGVUb29scy5zZXQodG9vbC5uYW1lLCB7IC4uLnRvb2wsIHNlcnZlcjogbmFtZSB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGDinIUgQ29ubmVjdGVkIHRvICR7bmFtZX0gKCR7dG9vbHNSZXNwb25zZS50b29scy5sZW5ndGh9IHRvb2xzKWApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBsb2dBdmFpbGFibGVUb29scygpOiB2b2lkIHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5SnIEF2YWlsYWJsZSBUb29sczonKTtcclxuICAgIGZvciAoY29uc3QgW3Rvb2xOYW1lLCB0b29sSW5mb10gb2YgdGhpcy5hdmFpbGFibGVUb29scy5lbnRyaWVzKCkpIHtcclxuICAgICAgY29uc29sZS5sb2coYCAgIOKAoiAke3Rvb2xOYW1lfSAoJHt0b29sSW5mby5zZXJ2ZXJ9KTogJHt0b29sSW5mby5kZXNjcmlwdGlvbiB8fCAnTm8gZGVzY3JpcHRpb24nfWApO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coJycpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXhlY3V0ZU1DUFRvb2wodG9vbE5hbWU6IHN0cmluZywgcGFyYW1ldGVyczogYW55KTogUHJvbWlzZTxhbnk+IHtcclxuICAgIGNvbnN0IHRvb2xJbmZvID0gdGhpcy5hdmFpbGFibGVUb29scy5nZXQodG9vbE5hbWUpO1xyXG4gICAgaWYgKCF0b29sSW5mbykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2wgJHt0b29sTmFtZX0gbm90IGF2YWlsYWJsZWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMubWNwQ2xpZW50cy5nZXQodG9vbEluZm8uc2VydmVyKTtcclxuICAgIGlmICghY2xpZW50KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTUNQIGNsaWVudCBmb3IgJHt0b29sSW5mby5zZXJ2ZXJ9IG5vdCBjb25uZWN0ZWRgKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuY2FsbFRvb2woe1xyXG4gICAgICAgIG5hbWU6IHRvb2xOYW1lLFxyXG4gICAgICAgIGFyZ3VtZW50czogcGFyYW1ldGVyc1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGV4ZWN1dGluZyAke3Rvb2xOYW1lfTpgLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnNvbGUubG9nKCdcXG7wn6e5IENsZWFuaW5nIHVwIE1DUCBjb25uZWN0aW9ucy4uLicpO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjbGllbnRdIG9mIHRoaXMubWNwQ2xpZW50cy5lbnRyaWVzKCkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCBjbGllbnQuY2xvc2UoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIENsb3NlZCAke25hbWV9YCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gIEVycm9yIGNsb3NpbmcgJHtuYW1lfTpgLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5tY3BDbGllbnRzLmNsZWFyKCk7XHJcbiAgICB0aGlzLmF2YWlsYWJsZVRvb2xzLmNsZWFyKCk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJHb29nbGVHZW5BSSIsIkNsaWVudCIsIlN0ZGlvQ2xpZW50VHJhbnNwb3J0IiwiQXBleE1DUEFnZW50IiwiY29uc3RydWN0b3IiLCJhcGlLZXkiLCJjb25maWciLCJtY3BDbGllbnRzIiwiTWFwIiwiYXZhaWxhYmxlVG9vbHMiLCJrZXkiLCJwcm9jZXNzIiwiZW52IiwiR0VNSU5JX0FQSV9LRVkiLCJFcnJvciIsImFpIiwibW9kZWwiLCJ0ZW1wZXJhdHVyZSIsIm1heFRva2VucyIsInRoaW5raW5nQnVkZ2V0Iiwid29ya2luZ0RpcmVjdG9yeSIsImN3ZCIsIm1jcFNlcnZlcnMiLCJwdXBwZXRlZXIiLCJjb21tYW5kIiwiYXJncyIsInBsYXl3cmlnaHQiLCJtZW1vcnkiLCJmaWxlc3lzdGVtIiwidGltZSIsImdpdGh1YiIsIkdJVEhVQl9QRVJTT05BTF9BQ0NFU1NfVE9LRU4iLCJpbml0aWFsaXplIiwiY29uc29sZSIsImxvZyIsInNlcnZlck5hbWUiLCJzZXJ2ZXJDb25maWciLCJPYmplY3QiLCJlbnRyaWVzIiwiY29ubmVjdE1DUFNlcnZlciIsImVycm9yIiwid2FybiIsIm1lc3NhZ2UiLCJzaXplIiwibG9nQXZhaWxhYmxlVG9vbHMiLCJuYW1lIiwidHJhbnNwb3J0IiwiY2xpZW50IiwidmVyc2lvbiIsImNhcGFiaWxpdGllcyIsInJlc291cmNlcyIsInRvb2xzIiwicHJvbXB0cyIsImNvbm5lY3QiLCJzZXQiLCJ0b29sc1Jlc3BvbnNlIiwibGlzdFRvb2xzIiwiZm9yRWFjaCIsInRvb2wiLCJzZXJ2ZXIiLCJsZW5ndGgiLCJ0b29sTmFtZSIsInRvb2xJbmZvIiwiZGVzY3JpcHRpb24iLCJleGVjdXRlTUNQVG9vbCIsInBhcmFtZXRlcnMiLCJnZXQiLCJyZXN1bHQiLCJjYWxsVG9vbCIsImFyZ3VtZW50cyIsImNsZWFudXAiLCJjbG9zZSIsImNsZWFyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./src/lib/ai/mcp-agent.ts\n");

/***/ }),

/***/ "?66e9":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ })

};
;