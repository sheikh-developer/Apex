"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ai-sdk";
exports.ids = ["vendor-chunks/@ai-sdk"];
exports.modules = {

/***/ "(rsc)/./node_modules/@ai-sdk/rsc/dist/rsc-server.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/rsc/dist/rsc-server.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_4___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$RSC_SERVER_ACTION_0: () => (/* binding */ $$RSC_SERVER_ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsondiffpatch */ \"(rsc)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(rsc)/./node_modules/@ai-sdk/rsc/dist/rsc-shared.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var ai__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ai */ \"(rsc)/./node_modules/@ai-sdk/rsc/node_modules/ai/dist/index.mjs\");\n/* harmony import */ var ai_internal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ai/internal */ \"(rsc)/./node_modules/@ai-sdk/rsc/node_modules/ai/dist/internal/index.mjs\");\n// src/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"7f399c0f0f8490bbb6b4b531ea66b619820f3ce8e2\":\"$$RSC_SERVER_ACTION_0\"} */ \n\n\n\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// src/util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// src/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: JSON.parse(JSON.stringify(state1)),\n        // deep clone object\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a = store.options).onSetAIState) == null ? void 0 : _b.call(_a, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// src/provider.tsx\n\n\n\nconst $$RSC_SERVER_ACTION_0 = async function innerAction({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n};\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)($$RSC_SERVER_ACTION_0, \"7f399c0f0f8490bbb6b4b531ea66b619820f3ce8e2\", null);\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name in actions){\n        wrappedActions[name] = wrapAction(actions[name], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_4__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a = props.initialUIState) != null ? _a : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_6__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n// src/stream-ui/stream-ui.tsx\n\n\n\n// src/util/is-async-generator.ts\nfunction isAsyncGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.asyncIterator in value;\n}\n// src/util/is-generator.ts\nfunction isGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.iterator in value;\n}\n// src/util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// src/streamable-ui/create-suspended-chunk.tsx\n\n\nvar R = [\n    async ({ c: current, n: next })=>{\n        const chunk = await next;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {\n                children: [\n                    current,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspendedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\n// src/streamable-ui/create-streamable-ui.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspendedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n    }\n    warnUnclosedStream();\n    const streamable = {\n        value: row,\n        update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return streamable;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n            return streamable;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return streamable;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n            return streamable;\n        }\n    };\n    return streamable;\n}\n// src/stream-ui/stream-ui.tsx\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, initial, text, providerOptions, onFinish, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    let finishEvent = null;\n    async function render({ args, renderer, streamableUI, isLastCall = false }) {\n        if (!renderer) return;\n        const renderFinished = createResolvablePromise();\n        finished = finished ? finished.then(()=>renderFinished.promise) : renderFinished.promise;\n        const rendererResult = renderer(...args);\n        if (isAsyncGenerator(rendererResult) || isGenerator(rendererResult)) {\n            while(true){\n                const { done, value } = await rendererResult.next();\n                const node = await value;\n                if (isLastCall && done) {\n                    streamableUI.done(node);\n                } else {\n                    streamableUI.update(node);\n                }\n                if (done) break;\n            }\n        } else {\n            const node = await rendererResult;\n            if (isLastCall) {\n                streamableUI.done(node);\n            } else {\n                streamableUI.update(node);\n            }\n        }\n        renderFinished.resolve(void 0);\n    }\n    const { retry } = (0,ai_internal__WEBPACK_IMPORTED_MODULE_7__.prepareRetries)({\n        maxRetries\n    });\n    const validatedPrompt = await (0,ai_internal__WEBPACK_IMPORTED_MODULE_7__.standardizePrompt)({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(async ()=>model.doStream({\n            ...(0,ai_internal__WEBPACK_IMPORTED_MODULE_7__.prepareCallSettings)(settings),\n            ...(0,ai_internal__WEBPACK_IMPORTED_MODULE_7__.prepareToolsAndToolChoice)({\n                tools,\n                toolChoice,\n                activeTools: void 0\n            }),\n            prompt: await (0,ai_internal__WEBPACK_IMPORTED_MODULE_7__.convertToLanguageModelPrompt)({\n                prompt: validatedPrompt,\n                supportedUrls: await model.supportedUrls\n            }),\n            providerOptions,\n            abortSignal,\n            headers\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            let warnings;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"stream-start\":\n                        {\n                            warnings = value.warnings;\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            content += value.text;\n                            render({\n                                renderer: textRender,\n                                args: [\n                                    {\n                                        content,\n                                        done: false,\n                                        delta: value.text\n                                    }\n                                ],\n                                streamableUI: ui\n                            });\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new ai__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new ai__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            hasToolCall = true;\n                            const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new ai__WEBPACK_IMPORTED_MODULE_8__.InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            render({\n                                renderer: tool.generate,\n                                args: [\n                                    parseResult.value,\n                                    {\n                                        toolName,\n                                        toolCallId: value.toolCallId\n                                    }\n                                ],\n                                streamableUI: ui,\n                                isLastCall: true\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {\n                            finishEvent = {\n                                finishReason: value.finishReason,\n                                usage: value.usage,\n                                warnings,\n                                response: result.response\n                            };\n                            break;\n                        }\n                }\n            }\n            if (!hasToolCall) {\n                render({\n                    renderer: textRender,\n                    args: [\n                        {\n                            content,\n                            done: true\n                        }\n                    ],\n                    streamableUI: ui,\n                    isLastCall: true\n                });\n            }\n            await finished;\n            if (finishEvent && onFinish) {\n                await onFinish({\n                    ...finishEvent,\n                    value: ui.value\n                });\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// src/streamable-value/streamable-value.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\n// src/streamable-value/create-streamable-value.ts\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable value has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    const streamable = {\n        set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        get value () {\n            return createWrapped(true);\n        },\n        update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n            return streamable;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return streamable;\n            }\n            resolvable.resolve({});\n            return streamable;\n        }\n    };\n    return streamable;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yc2MvZGlzdC9yc2Mtc2VydmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDRzs7QUNRM0IsU0FBUywwQkFJZDtJQUNBLElBQUk7SUFDSixJQUFJO0lBRUosTUFBTSxVQUFVLElBQUksUUFBVyxDQUFDLEtBQUs7UUFDbkMsVUFBVTtRQUNWLFNBQVM7SUFDWCxDQUFDO0lBRUQsT0FBTztRQUNMO1FBQ0E7UUFDQTtJQUNGO0FBQ0Y7O0FDckJPLElBQU0sYUFBYSxDQUFDLFFBQ3pCLE9BQU8sVUFBVTs7QUZPbkIsSUFBTSxzQkFBc0IsSUFBSSwwREFBaUIsQ0FPOUM7QUFFSCxTQUFTLHVCQUF1QixTQUFpQjtJQUMvQyxNQUFNLFFBQVEsb0JBQW9CLFNBQVM7SUFDM0MsSUFBSSxDQUFDLE9BQU87UUFDVixNQUFNLElBQUksTUFBTSxPQUFPO0lBQ3pCO0lBQ0EsT0FBTztBQUNUO0FBRU8sU0FBUyxZQUNkLFNBQUUsUUFBTyxRQUFRLEdBQ2pCLElBQ0c7SUFDSCxPQUFPLG9CQUFvQixJQUN6QjtRQUNFLGNBQWMsS0FBSyxNQUFNLEtBQUssVUFBVSxLQUFLLENBQUM7UUFBQTtRQUM5QyxlQUFlO1FBQ2YsUUFBUTtRQUNSO0lBQ0YsR0FDQTtBQUVKO0FBRU8sU0FBUyx5QkFBeUI7SUFDdkMsTUFBTSxRQUFRLHVCQUF1QiwwQkFBMEI7SUFDL0QsT0FBTyxNQUFNO0FBQ2Y7QUFLTyxTQUFTLHFCQUFxQjtJQUNuQyxNQUFNLFFBQVEsdUJBQXVCLDBCQUEwQjtJQUMvRCxNQUFNLFNBQVM7QUFDakI7QUFnQkEsU0FBUyxjQUNKLE1BQ0g7SUFDQSxNQUFNLFFBQVEsdUJBQ1o7SUFHRixJQUFJLEtBQUssU0FBUyxHQUFHO1FBQ25CLE1BQU0sTUFBTSxLQUFLLENBQUM7UUFDbEIsSUFBSSxPQUFPLE1BQU0saUJBQWlCLFVBQVU7WUFDMUMsTUFBTSxJQUFJLE1BQ1Isc0JBQXNCLE9BQ3BC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VDtRQUNBLFFBQU8sT0FBVTtZQUNmLGFBQWEsV0FBVztZQUV4QixJQUNFLE9BQU8saUJBQWlCLFlBQ3hCLE9BQU8saUJBQWlCLGFBQ3hCO2dCQUNBLE1BQU0sSUFBSSxNQUNSLDJEQUEyRCxPQUFPLFlBQVk7WUFFbEY7WUFDQSxJQUFJLE9BQU8sVUFBVSxVQUFVO2dCQUM3QixNQUFNLElBQUksTUFDUixtREFBbUQsT0FBTyxLQUFLO1lBRW5FO1lBRUEsTUFBTSxrQkFBa0IsV0FBVztZQUNuQyxhQUFhLHdCQUF3QjtZQUVyQyxJQUFJLE9BQU8saUJBQWlCLFVBQVU7Z0JBQ3BDLG9CQUFvQjtvQkFBQztvQkFBRyxLQUFLO2lCQUFBO2dCQUM1QixlQUEwQixlQUFlO1lBQzVDLE9BQU87Z0JBQ0wsb0JBQW9CO2dCQUNwQixlQUFlO1lBQ2pCO1lBRUEsaUJBQWlCLFdBQVc7WUFDNUIsZ0JBQWdCLGNBQWMsQ0FBQztZQUUvQixtQkFBbUI7WUFFbkIsT0FBTztRQUNUO1FBQ0EsT0FBTSxPQUFZO1lBQ2hCLGFBQWEsVUFBVTtZQUV2QixJQUFJLGdCQUFnQjtnQkFDbEIsYUFBYSxjQUFjO1lBQzdCO1lBQ0EsU0FBUztZQUNULGVBQWU7WUFDZixpQkFBaUI7WUFFakIsV0FBVyxRQUFRO2dCQUFFO1lBQU0sQ0FBQztZQUU1QixPQUFPO1FBQ1Q7UUFDQSxTQUFRLE1BQWdCO1lBQ3RCLGFBQWEsU0FBUztZQUV0QixJQUFJLGdCQUFnQjtnQkFDbEIsYUFBYSxjQUFjO1lBQzdCO1lBQ0EsU0FBUztZQUNULGlCQUFpQjtZQUVqQixJQUFJLEtBQUssUUFBUTtnQkFDZixrQkFBa0IsS0FBSyxDQUFDLENBQUM7Z0JBQ3pCLFdBQVcsUUFBUSxjQUFjLENBQUM7Z0JBQ2xDLE9BQU87WUFDVDtZQUVBLFdBQVcsUUFBUSxDQUFDLENBQUM7WUFFckIsT0FBTztRQUNUO0lBQ0Y7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXHNyY1xcYWktc3RhdGUudHN4IiwiQzpcXFVzZXJzXFxsaWtob1xcT25lRHJpdmVcXEdpdEh1Ylxcc3JjXFx1dGlsXFxjcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzIiwiQzpcXFVzZXJzXFxsaWtob1xcT25lRHJpdmVcXEdpdEh1Ylxcc3JjXFx1dGlsXFxpcy1mdW5jdGlvbi50cyIsIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXHNyY1xccHJvdmlkZXIudHN4IiwiQzpcXFVzZXJzXFxsaWtob1xcT25lRHJpdmVcXEdpdEh1Ylxcc3JjXFxzdHJlYW0tdWlcXHN0cmVhbS11aS50c3giLCJDOlxcVXNlcnNcXGxpa2hvXFxPbmVEcml2ZVxcR2l0SHViXFxzcmNcXHV0aWxcXGlzLWFzeW5jLWdlbmVyYXRvci50cyIsIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXHNyY1xcdXRpbFxcaXMtZ2VuZXJhdG9yLnRzIiwiQzpcXFVzZXJzXFxsaWtob1xcT25lRHJpdmVcXEdpdEh1Ylxcc3JjXFx1dGlsXFxjb25zdGFudHMudHMiLCJDOlxcVXNlcnNcXGxpa2hvXFxPbmVEcml2ZVxcR2l0SHViXFxzcmNcXHN0cmVhbWFibGUtdWlcXGNyZWF0ZS1zdXNwZW5kZWQtY2h1bmsudHN4IiwiQzpcXFVzZXJzXFxsaWtob1xcT25lRHJpdmVcXEdpdEh1Ylxcc3JjXFxzdHJlYW1hYmxlLXVpXFxjcmVhdGUtc3RyZWFtYWJsZS11aS50c3giLCJDOlxcVXNlcnNcXGxpa2hvXFxPbmVEcml2ZVxcR2l0SHViXFxzcmNcXHN0cmVhbWFibGUtdmFsdWVcXHN0cmVhbWFibGUtdmFsdWUudHMiLCJDOlxcVXNlcnNcXGxpa2hvXFxPbmVEcml2ZVxcR2l0SHViXFxzcmNcXHN0cmVhbWFibGUtdmFsdWVcXGNyZWF0ZS1zdHJlYW1hYmxlLXZhbHVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSAnanNvbmRpZmZwYXRjaCc7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ25vZGU6YXN5bmNfaG9va3MnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZSc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi91dGlsL2lzLWZ1bmN0aW9uJztcbmltcG9ydCB0eXBlIHtcbiAgQUlQcm92aWRlcixcbiAgSW5mZXJBSVN0YXRlLFxuICBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbiAgTXV0YWJsZUFJU3RhdGUsXG4gIFZhbHVlT3JVcGRhdGVyLFxufSBmcm9tICcuL3R5cGVzJztcblxuLy8gSXQgaXMgcG9zc2libGUgdGhhdCBtdWx0aXBsZSBBSSByZXF1ZXN0cyBnZXQgaW4gY29uY3VycmVudGx5LCBmb3IgZGlmZmVyZW50XG4vLyBBSSBpbnN0YW5jZXMuIFNvIEFMUyBpcyBuZWNlc3NhcnkgaGVyZSBmb3IgYSBzaW1wbGVyIEFQSS5cbmNvbnN0IGFzeW5jQUlTdGF0ZVN0b3JhZ2UgPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2U8e1xuICBjdXJyZW50U3RhdGU6IGFueTtcbiAgb3JpZ2luYWxTdGF0ZTogYW55O1xuICBzZWFsZWQ6IGJvb2xlYW47XG4gIG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zO1xuICBtdXRhdGlvbkRlbHRhUHJvbWlzZT86IFByb21pc2U8YW55PjtcbiAgbXV0YXRpb25EZWx0YVJlc29sdmU/OiAodjogYW55KSA9PiB2b2lkO1xufT4oKTtcblxuZnVuY3Rpb24gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc3Qgc3RvcmUgPSBhc3luY0FJU3RhdGVTdG9yYWdlLmdldFN0b3JlKCk7XG4gIGlmICghc3RvcmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aEFJU3RhdGU8UywgVD4oXG4gIHsgc3RhdGUsIG9wdGlvbnMgfTogeyBzdGF0ZTogUzsgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMgfSxcbiAgZm46ICgpID0+IFQsXG4pOiBUIHtcbiAgcmV0dXJuIGFzeW5jQUlTdGF0ZVN0b3JhZ2UucnVuKFxuICAgIHtcbiAgICAgIGN1cnJlbnRTdGF0ZTogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdGF0ZSkpLCAvLyBkZWVwIGNsb25lIG9iamVjdFxuICAgICAgb3JpZ2luYWxTdGF0ZTogc3RhdGUsXG4gICAgICBzZWFsZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9ucyxcbiAgICB9LFxuICAgIGZuLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KCdJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC4nKTtcbiAgcmV0dXJuIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlO1xufVxuXG4vLyBJbnRlcm5hbCBtZXRob2QuIFRoaXMgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIEFJIEFjdGlvbiBoYXMgYmVlbiByZXR1cm5lZFxuLy8gYW5kIHlvdSBjYW4gbm8gbG9uZ2VyIGNhbGwgYGdldE11dGFibGVBSVN0YXRlKClgIGluc2lkZSBhbnkgYXN5bmMgY2FsbGJhY2tzXG4vLyBjcmVhdGVkIGJ5IHRoYXQgQWN0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIHNlYWxNdXRhYmxlQUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KCdJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC4nKTtcbiAgc3RvcmUuc2VhbGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgQUkgc3RhdGUuXG4gKiBJZiBga2V5YCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5IGluIHRoZVxuICogQUkgc3RhdGUsIGlmIGl0J3MgYW4gb2JqZWN0LiBJZiBpdCdzIG5vdCBhbiBvYmplY3QsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKlxuICogQGV4YW1wbGUgY29uc3Qgc3RhdGUgPSBnZXRBSVN0YXRlKCkgLy8gR2V0IHRoZSBlbnRpcmUgQUkgc3RhdGVcbiAqIEBleGFtcGxlIGNvbnN0IGZpZWxkID0gZ2V0QUlTdGF0ZSgna2V5JykgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUga2V5XG4gKi9cbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBSZWFkb25seTxcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XG4+O1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IFJlYWRvbmx5PEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT47XG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICAnYGdldEFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uJyxcbiAgKTtcblxuICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAga2V5LFxuICAgICAgICApfVwiIGZpZWxkIGZyb20gdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlW2tleSBhcyBrZXlvZiB0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlXTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtdXRhYmxlIEFJIHN0YXRlLiBOb3RlIHRoYXQgeW91IG11c3QgY2FsbCBgLmRvbmUoKWAgd2hlbiBmaW5pc2hpbmdcbiAqIHVwZGF0aW5nIHRoZSBBSSBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAqIHN0YXRlLnVwZGF0ZSh7IC4uLnN0YXRlLmdldCgpLCBrZXk6ICd2YWx1ZScgfSlcbiAqIHN0YXRlLnVwZGF0ZSgoY3VycmVudFN0YXRlKSA9PiAoeyAuLi5jdXJyZW50U3RhdGUsIGtleTogJ3ZhbHVlJyB9KSlcbiAqIHN0YXRlLmRvbmUoKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gKiBzdGF0ZS5kb25lKHsgLi4uc3RhdGUuZ2V0KCksIGtleTogJ3ZhbHVlJyB9KSAvLyBEb25lIHdpdGggYSBuZXcgc3RhdGVcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IE11dGFibGVBSVN0YXRlPFxuICBJbmZlckFJU3RhdGU8QUksIGFueT5cbj47XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IE11dGFibGVBSVN0YXRlPEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT47XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICB0eXBlIEFJU3RhdGUgPSBJbmZlckFJU3RhdGU8QUksIGFueT47XG4gIHR5cGUgQUlTdGF0ZVdpdGhLZXkgPSB0eXBlb2YgYXJncyBleHRlbmRzIFtrZXk6IGtleW9mIEFJU3RhdGVdXG4gICAgPyBBSVN0YXRlWyh0eXBlb2YgYXJncylbMF1dXG4gICAgOiBBSVN0YXRlO1xuICB0eXBlIE5ld1N0YXRlT3JVcGRhdGVyID0gVmFsdWVPclVwZGF0ZXI8QUlTdGF0ZVdpdGhLZXk+O1xuXG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICAnYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYW4gQUkgQWN0aW9uLicsXG4gICk7XG5cbiAgaWYgKHN0b3JlLnNlYWxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gYW4gQUkgQWN0aW9uLiBQbGVhc2UgbW92ZSBpdCB0byB0aGUgdG9wIGxldmVsIG9mIHRoZSBBY3Rpb24ncyBmdW5jdGlvbiBib2R5LlwiLFxuICAgICk7XG4gIH1cblxuICBpZiAoIXN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlKSB7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlID0gcHJvbWlzZTtcbiAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSA9IHJlc29sdmU7XG4gIH1cblxuICBmdW5jdGlvbiBkb1VwZGF0ZShuZXdTdGF0ZTogTmV3U3RhdGVPclVwZGF0ZXIsIGRvbmU6IGJvb2xlYW4pIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgY2FuJ3QgbW9kaWZ5IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICl9XCIgZmllbGQgb2YgdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24obmV3U3RhdGUpKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZShzdG9yZS5jdXJyZW50U3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RvcmUub3B0aW9ucy5vblNldEFJU3RhdGU/Lih7XG4gICAgICBrZXk6IGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbMF0gOiB1bmRlZmluZWQsXG4gICAgICBzdGF0ZTogc3RvcmUuY3VycmVudFN0YXRlLFxuICAgICAgZG9uZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG11dGFibGVTdGF0ZSA9IHtcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGVba2V5XSBhcyBSZWFkb25seTxBSVN0YXRlV2l0aEtleT47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGUgYXMgUmVhZG9ubHk8QUlTdGF0ZT47XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShuZXdBSVN0YXRlOiBOZXdTdGF0ZU9yVXBkYXRlcikge1xuICAgICAgZG9VcGRhdGUobmV3QUlTdGF0ZSwgZmFsc2UpO1xuICAgIH0sXG4gICAgZG9uZTogZnVuY3Rpb24gZG9uZSguLi5kb25lQXJnczogW10gfCBbTmV3U3RhdGVPclVwZGF0ZXJdKSB7XG4gICAgICBpZiAoZG9uZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBkb1VwZGF0ZShkb25lQXJnc1swXSBhcyBOZXdTdGF0ZU9yVXBkYXRlciwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbHRhID0ganNvbmRpZmZwYXRjaC5kaWZmKHN0b3JlLm9yaWdpbmFsU3RhdGUsIHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSEoZGVsdGEpO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIG11dGFibGVTdGF0ZTtcbn1cblxuZXhwb3J0IHsgZ2V0QUlTdGF0ZSwgZ2V0TXV0YWJsZUFJU3RhdGUgfTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIFByb21pc2Ugd2l0aCBleHRlcm5hbGx5IGFjY2Vzc2libGUgcmVzb2x2ZSBhbmQgcmVqZWN0IGZ1bmN0aW9ucy5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0aGF0IHRoZSBQcm9taXNlIHdpbGwgcmVzb2x2ZSB0by5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nOlxuICogICAtIHByb21pc2U6IEEgUHJvbWlzZSB0aGF0IGNhbiBiZSByZXNvbHZlZCBvciByZWplY3RlZCBleHRlcm5hbGx5LlxuICogICAtIHJlc29sdmU6IEEgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgUHJvbWlzZSB3aXRoIGEgdmFsdWUgb2YgdHlwZSBULlxuICogICAtIHJlamVjdDogQSBmdW5jdGlvbiB0byByZWplY3QgdGhlIFByb21pc2Ugd2l0aCBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPFQgPSBhbnk+KCk6IHtcbiAgcHJvbWlzZTogUHJvbWlzZTxUPjtcbiAgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkO1xuICByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcbn0ge1xuICBsZXQgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkO1xuICBsZXQgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG5cbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZSEsXG4gICAgcmVqZWN0OiByZWplY3QhLFxuICB9O1xufVxuIiwiLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgRnVuY3Rpb24gPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuIiwiLy8gVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBBSSBjb250ZXh0IHRvIGFsbCBBSSBBY3Rpb25zIHZpYSBBc3luY0xvY2FsU3RvcmFnZS5cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSW50ZXJuYWxBSVByb3ZpZGVyIH0gZnJvbSAnLi9yc2Mtc2hhcmVkLm1qcyc7XG5pbXBvcnQge1xuICB3aXRoQUlTdGF0ZSxcbiAgZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSxcbiAgc2VhbE11dGFibGVBSVN0YXRlLFxufSBmcm9tICcuL2FpLXN0YXRlJztcbmltcG9ydCB0eXBlIHtcbiAgU2VydmVyV3JhcHBlZEFjdGlvbnMsXG4gIEFJQWN0aW9uLFxuICBBSUFjdGlvbnMsXG4gIEFJUHJvdmlkZXIsXG4gIEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuICBPblNldEFJU3RhdGUsXG4gIE9uR2V0VUlTdGF0ZSxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGlubmVyQWN0aW9uPFQ+KFxuICB7XG4gICAgYWN0aW9uLFxuICAgIG9wdGlvbnMsXG4gIH06IHsgYWN0aW9uOiBBSUFjdGlvbjsgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMgfSxcbiAgc3RhdGU6IFQsXG4gIC4uLmFyZ3M6IHVua25vd25bXVxuKSB7XG4gICd1c2Ugc2VydmVyJztcbiAgcmV0dXJuIGF3YWl0IHdpdGhBSVN0YXRlKFxuICAgIHtcbiAgICAgIHN0YXRlLFxuICAgICAgb3B0aW9ucyxcbiAgICB9LFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbiguLi5hcmdzKTtcbiAgICAgIHNlYWxNdXRhYmxlQUlTdGF0ZSgpO1xuICAgICAgcmV0dXJuIFtnZXRBSVN0YXRlRGVsdGFQcm9taXNlKCkgYXMgUHJvbWlzZTxUPiwgcmVzdWx0XTtcbiAgICB9LFxuICApO1xufVxuXG5mdW5jdGlvbiB3cmFwQWN0aW9uPFQgPSB1bmtub3duPihcbiAgYWN0aW9uOiBBSUFjdGlvbixcbiAgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4pIHtcbiAgcmV0dXJuIGlubmVyQWN0aW9uLmJpbmQobnVsbCwgeyBhY3Rpb24sIG9wdGlvbnMgfSkgYXMgQUlBY3Rpb248VD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBSTxcbiAgQUlTdGF0ZSA9IGFueSxcbiAgVUlTdGF0ZSA9IGFueSxcbiAgQWN0aW9ucyBleHRlbmRzIEFJQWN0aW9ucyA9IHt9LFxuPih7XG4gIGFjdGlvbnMsXG4gIGluaXRpYWxBSVN0YXRlLFxuICBpbml0aWFsVUlTdGF0ZSxcblxuICBvblNldEFJU3RhdGUsXG4gIG9uR2V0VUlTdGF0ZSxcbn06IHtcbiAgYWN0aW9uczogQWN0aW9ucztcbiAgaW5pdGlhbEFJU3RhdGU/OiBBSVN0YXRlO1xuICBpbml0aWFsVUlTdGF0ZT86IFVJU3RhdGU7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBBSSBzdGF0ZSBpcyB1cGRhdGVkIGJ5IGFuIEFjdGlvbi5cbiAgICogWW91IGNhbiB1c2UgdGhpcyB0byBwZXJzaXN0IHRoZSBBSSBzdGF0ZSB0byBhIGRhdGFiYXNlLCBvciB0byBzZW5kIGl0IHRvIGFcbiAgICogbG9nZ2luZyBzZXJ2aWNlLlxuICAgKi9cbiAgb25TZXRBSVN0YXRlPzogT25TZXRBSVN0YXRlPEFJU3RhdGU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIFVJIHN0YXRlIGJhc2VkIG9uIHRoZSBBSSBzdGF0ZS5cbiAgICogRm9yIGV4YW1wbGUsIHRvIHJlbmRlciB0aGUgaW5pdGlhbCBVSSBzdGF0ZSBiYXNlZCBvbiBhIGdpdmVuIEFJIHN0YXRlLCBvclxuICAgKiB0byBzeW5jIHRoZSBVSSBzdGF0ZSB3aGVuIHRoZSBhcHBsaWNhdGlvbiBpcyBhbHJlYWR5IGxvYWRlZC5cbiAgICpcbiAgICogSWYgcmV0dXJuaW5nIGB1bmRlZmluZWRgLCB0aGUgY2xpZW50IHNpZGUgVUkgc3RhdGUgd2lsbCBub3QgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGFubm90YXRlZCB3aXRoIHRoZSBgXCJ1c2Ugc2VydmVyXCJgIGRpcmVjdGl2ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHN4XG4gICAqIG9uR2V0VUlTdGF0ZTogYXN5bmMgKCkgPT4ge1xuICAgKiAgICd1c2Ugc2VydmVyJztcbiAgICpcbiAgICogICBjb25zdCBjdXJyZW50QUlTdGF0ZSA9IGdldEFJU3RhdGUoKTtcbiAgICogICBjb25zdCBleHRlcm5hbEFJU3RhdGUgPSBhd2FpdCBsb2FkQUlTdGF0ZUZyb21EYXRhYmFzZSgpO1xuICAgKlxuICAgKiAgIGlmIChjdXJyZW50QUlTdGF0ZSA9PT0gZXh0ZXJuYWxBSVN0YXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgKlxuICAgKiAgIC8vIFVwZGF0ZSBjdXJyZW50IEFJIHN0YXRlIGFuZCByZXR1cm4gdGhlIG5ldyBVSSBzdGF0ZVxuICAgKiAgIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICAgKiAgIHN0YXRlLmRvbmUoZXh0ZXJuYWxBSVN0YXRlKVxuICAgKlxuICAgKiAgIHJldHVybiA8ZGl2Pi4uLjwvZGl2PjtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIG9uR2V0VUlTdGF0ZT86IE9uR2V0VUlTdGF0ZTxVSVN0YXRlPjtcbn0pIHtcbiAgLy8gV3JhcCBhbGwgYWN0aW9ucyB3aXRoIG91ciBIb0MuXG4gIGNvbnN0IHdyYXBwZWRBY3Rpb25zOiBTZXJ2ZXJXcmFwcGVkQWN0aW9ucyA9IHt9O1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gYWN0aW9ucykge1xuICAgIHdyYXBwZWRBY3Rpb25zW25hbWVdID0gd3JhcEFjdGlvbihhY3Rpb25zW25hbWVdLCB7XG4gICAgICBvblNldEFJU3RhdGUsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB3cmFwcGVkU3luY1VJU3RhdGUgPSBvbkdldFVJU3RhdGVcbiAgICA/IHdyYXBBY3Rpb24ob25HZXRVSVN0YXRlLCB7fSlcbiAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBBSTogQUlQcm92aWRlcjxBSVN0YXRlLCBVSVN0YXRlLCBBY3Rpb25zPiA9IGFzeW5jIHByb3BzID0+IHtcbiAgICBpZiAoJ3VzZVN0YXRlJyBpbiBSZWFjdCkge1xuICAgICAgLy8gVGhpcyBmaWxlIG11c3QgYmUgcnVubmluZyBvbiB0aGUgUmVhY3QgU2VydmVyIGxheWVyLlxuICAgICAgLy8gSWRlYWxseSB3ZSBzaG91bGQgYmUgdXNpbmcgYGltcG9ydCBcInNlcnZlci1vbmx5XCJgIGhlcmUgYnV0IHdlIGNhbiBoYXZlIGFcbiAgICAgIC8vIG1vcmUgY3VzdG9taXplZCBlcnJvciBtZXNzYWdlIHdpdGggdGhpcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoaXMgY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIFNlcnZlciBDb21wb25lbnRzLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB1aVN0YXRlID0gcHJvcHMuaW5pdGlhbFVJU3RhdGUgPz8gaW5pdGlhbFVJU3RhdGU7XG4gICAgbGV0IGFpU3RhdGUgPSBwcm9wcy5pbml0aWFsQUlTdGF0ZSA/PyBpbml0aWFsQUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZURlbHRhID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHdyYXBwZWRTeW5jVUlTdGF0ZSkge1xuICAgICAgY29uc3QgW25ld0FJU3RhdGVEZWx0YSwgbmV3VUlTdGF0ZV0gPSBhd2FpdCB3cmFwcGVkU3luY1VJU3RhdGUoYWlTdGF0ZSk7XG4gICAgICBpZiAobmV3VUlTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFpU3RhdGVEZWx0YSA9IG5ld0FJU3RhdGVEZWx0YTtcbiAgICAgICAgdWlTdGF0ZSA9IG5ld1VJU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxJbnRlcm5hbEFJUHJvdmlkZXJcbiAgICAgICAgd3JhcHBlZEFjdGlvbnM9e3dyYXBwZWRBY3Rpb25zfVxuICAgICAgICB3cmFwcGVkU3luY1VJU3RhdGU9e3dyYXBwZWRTeW5jVUlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbFVJU3RhdGU9e3VpU3RhdGV9XG4gICAgICAgIGluaXRpYWxBSVN0YXRlPXthaVN0YXRlfVxuICAgICAgICBpbml0aWFsQUlTdGF0ZVBhdGNoPXthaVN0YXRlRGVsdGF9XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvSW50ZXJuYWxBSVByb3ZpZGVyPlxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIEFJO1xufVxuIiwiaW1wb3J0IHsgTGFuZ3VhZ2VNb2RlbFYyLCBMYW5ndWFnZU1vZGVsVjJDYWxsV2FybmluZyB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQge1xuICBDYWxsV2FybmluZyxcbiAgRmluaXNoUmVhc29uLFxuICBQcm92aWRlck9wdGlvbnMsXG4gIExhbmd1YWdlTW9kZWxVc2FnZSxcbiAgVG9vbENob2ljZSxcbiAgUHJvbXB0LFxuICBDYWxsU2V0dGluZ3MsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvcixcbiAgU2NoZW1hLFxufSBmcm9tICdhaSc7XG5pbXBvcnQge1xuICBzdGFuZGFyZGl6ZVByb21wdCxcbiAgcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSxcbiAgcHJlcGFyZVJldHJpZXMsXG4gIHByZXBhcmVDYWxsU2V0dGluZ3MsXG4gIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQsXG59IGZyb20gJ2FpL2ludGVybmFsJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGlzQXN5bmNHZW5lcmF0b3IgfSBmcm9tICcuLi91dGlsL2lzLWFzeW5jLWdlbmVyYXRvcic7XG5pbXBvcnQgeyBpc0dlbmVyYXRvciB9IGZyb20gJy4uL3V0aWwvaXMtZ2VuZXJhdG9yJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVVSSB9IGZyb20gJy4uL3N0cmVhbWFibGUtdWkvY3JlYXRlLXN0cmVhbWFibGUtdWknO1xuXG50eXBlIFN0cmVhbWFibGUgPSBSZWFjdE5vZGUgfCBQcm9taXNlPFJlYWN0Tm9kZT47XG5cbnR5cGUgUmVuZGVyZXI8VCBleHRlbmRzIEFycmF5PGFueT4+ID0gKFxuICAuLi5hcmdzOiBUXG4pID0+XG4gIHwgU3RyZWFtYWJsZVxuICB8IEdlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPlxuICB8IEFzeW5jR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+O1xuXG50eXBlIFJlbmRlclRvb2w8UEFSQU1FVEVSUyBleHRlbmRzIHouU2NoZW1hIHwgU2NoZW1hID0gYW55PiA9IHtcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHBhcmFtZXRlcnM6IFBBUkFNRVRFUlM7XG4gIGdlbmVyYXRlPzogUmVuZGVyZXI8XG4gICAgW1xuICAgICAgUEFSQU1FVEVSUyBleHRlbmRzIHouU2NoZW1hXG4gICAgICAgID8gei5pbmZlcjxQQVJBTUVURVJTPlxuICAgICAgICA6IFBBUkFNRVRFUlMgZXh0ZW5kcyBTY2hlbWE8aW5mZXIgVD5cbiAgICAgICAgICA/IFRcbiAgICAgICAgICA6IG5ldmVyLFxuICAgICAge1xuICAgICAgICB0b29sTmFtZTogc3RyaW5nO1xuICAgICAgICB0b29sQ2FsbElkOiBzdHJpbmc7XG4gICAgICB9LFxuICAgIF1cbiAgPjtcbn07XG5cbnR5cGUgUmVuZGVyVGV4dCA9IFJlbmRlcmVyPFxuICBbXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc28gZmFyLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5ldyBhcHBlbmRlZCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc2luY2UgdGhlIGxhc3QgYHRleHRgIGNhbGwuXG4gICAgICAgKi9cbiAgICAgIGRlbHRhOiBzdHJpbmc7XG5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0aGUgbW9kZWwgaXMgZG9uZSBnZW5lcmF0aW5nIHRleHQuXG4gICAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBgY29udGVudGAgd2lsbCBiZSB0aGUgZmluYWwgb3V0cHV0IGFuZCB0aGlzIGNhbGwgd2lsbCBiZSB0aGUgbGFzdC5cbiAgICAgICAqL1xuICAgICAgZG9uZTogYm9vbGVhbjtcbiAgICB9LFxuICBdXG4+O1xuXG50eXBlIFJlbmRlclJlc3VsdCA9IHtcbiAgdmFsdWU6IFJlYWN0Tm9kZTtcbn0gJiBBd2FpdGVkPFJldHVyblR5cGU8TGFuZ3VhZ2VNb2RlbFYyWydkb1N0cmVhbSddPj47XG5cbmNvbnN0IGRlZmF1bHRUZXh0UmVuZGVyZXI6IFJlbmRlclRleHQgPSAoeyBjb250ZW50IH06IHsgY29udGVudDogc3RyaW5nIH0pID0+XG4gIGNvbnRlbnQ7XG5cbi8qKlxuICogYHN0cmVhbVVJYCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdHJlYW1hYmxlIFVJIGZyb20gTExNcy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVVJPFxuICBUT09MUyBleHRlbmRzIHsgW25hbWU6IHN0cmluZ106IHouU2NoZW1hIHwgU2NoZW1hIH0gPSB7fSxcbj4oe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGluaXRpYWwsXG4gIHRleHQsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgb25GaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59OiBDYWxsU2V0dGluZ3MgJlxuICBQcm9tcHQgJiB7XG4gICAgLyoqXG4gICAgICogVGhlIGxhbmd1YWdlIG1vZGVsIHRvIHVzZS5cbiAgICAgKi9cbiAgICBtb2RlbDogTGFuZ3VhZ2VNb2RlbFYyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2xzIHRoYXQgdGhlIG1vZGVsIGNhbiBjYWxsLiBUaGUgbW9kZWwgbmVlZHMgdG8gc3VwcG9ydCBjYWxsaW5nIHRvb2xzLlxuICAgICAqL1xuICAgIHRvb2xzPzoge1xuICAgICAgW25hbWUgaW4ga2V5b2YgVE9PTFNdOiBSZW5kZXJUb29sPFRPT0xTW25hbWVdPjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2wgY2hvaWNlIHN0cmF0ZWd5LiBEZWZhdWx0OiAnYXV0bycuXG4gICAgICovXG4gICAgdG9vbENob2ljZT86IFRvb2xDaG9pY2U8VE9PTFM+O1xuXG4gICAgdGV4dD86IFJlbmRlclRleHQ7XG4gICAgaW5pdGlhbD86IFJlYWN0Tm9kZTtcblxuICAgIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBvcHRpb25zLiBUaGV5IGFyZSBwYXNzZWQgdGhyb3VnaFxudG8gdGhlIHByb3ZpZGVyIGZyb20gdGhlIEFJIFNESyBhbmQgZW5hYmxlIHByb3ZpZGVyLXNwZWNpZmljXG5mdW5jdGlvbmFsaXR5IHRoYXQgY2FuIGJlIGZ1bGx5IGVuY2Fwc3VsYXRlZCBpbiB0aGUgcHJvdmlkZXIuXG4gKi9cbiAgICBwcm92aWRlck9wdGlvbnM/OiBQcm92aWRlck9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBMTE0gcmVzcG9uc2UgYW5kIHRoZSBmaW5hbCBvYmplY3QgdmFsaWRhdGlvbiBhcmUgZmluaXNoZWQuXG4gICAgICovXG4gICAgb25GaW5pc2g/OiAoZXZlbnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJlYXNvbiB3aHkgdGhlIGdlbmVyYXRpb24gZmluaXNoZWQuXG4gICAgICAgKi9cbiAgICAgIGZpbmlzaFJlYXNvbjogRmluaXNoUmVhc29uO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9rZW4gdXNhZ2Ugb2YgdGhlIGdlbmVyYXRlZCByZXNwb25zZS5cbiAgICAgICAqL1xuICAgICAgdXNhZ2U6IExhbmd1YWdlTW9kZWxVc2FnZTtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZpbmFsIHVpIG5vZGUgdGhhdCB3YXMgZ2VuZXJhdGVkLlxuICAgICAgICovXG4gICAgICB2YWx1ZTogUmVhY3ROb2RlO1xuICAgICAgLyoqXG4gICAgICAgKiBXYXJuaW5ncyBmcm9tIHRoZSBtb2RlbCBwcm92aWRlciAoZS5nLiB1bnN1cHBvcnRlZCBzZXR0aW5ncylcbiAgICAgICAqL1xuICAgICAgd2FybmluZ3M/OiBDYWxsV2FybmluZ1tdO1xuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25hbCByZXNwb25zZSBkYXRhLlxuICAgICAgICovXG4gICAgICByZXNwb25zZT86IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3BvbnNlIGhlYWRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICAgIH07XG4gICAgfSkgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIH0pOiBQcm9taXNlPFJlbmRlclJlc3VsdD4ge1xuICAvLyBUT0RPOiBSZW1vdmUgdGhlc2UgZXJyb3JzIGFmdGVyIHRoZSBleHBlcmltZW50YWwgcGhhc2UuXG4gIGlmICh0eXBlb2YgbW9kZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Btb2RlbGAgY2Fubm90IGJlIGEgc3RyaW5nIGluIGBzdHJlYW1VSWAuIFVzZSB0aGUgYWN0dWFsIG1vZGVsIGluc3RhbmNlIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICgnZnVuY3Rpb25zJyBpbiBzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgZnVuY3Rpb25zYCBpcyBub3Qgc3VwcG9ydGVkIGluIGBzdHJlYW1VSWAsIHVzZSBgdG9vbHNgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICgncHJvdmlkZXInIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bwcm92aWRlcmAgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBgc3RyZWFtVUlgLiBVc2UgYG1vZGVsYCBpbnN0ZWFkLicsXG4gICAgKTtcbiAgfVxuICBpZiAodG9vbHMpIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB0b29sXSBvZiBPYmplY3QuZW50cmllcyh0b29scykpIHtcbiAgICAgIGlmICgncmVuZGVyJyBpbiB0b29sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVG9vbCBkZWZpbml0aW9uIGluIGBzdHJlYW1VSWAgc2hvdWxkIG5vdCBoYXZlIGByZW5kZXJgIHByb3BlcnR5LiBVc2UgYGdlbmVyYXRlYCBpbnN0ZWFkLiBGb3VuZCBpbiB0b29sOiAnICtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoaW5pdGlhbCk7XG5cbiAgLy8gVGhlIGRlZmF1bHQgdGV4dCByZW5kZXJlciBqdXN0IHJldHVybnMgdGhlIGNvbnRlbnQgYXMgc3RyaW5nLlxuICBjb25zdCB0ZXh0UmVuZGVyID0gdGV4dCB8fCBkZWZhdWx0VGV4dFJlbmRlcmVyO1xuXG4gIGxldCBmaW5pc2hlZDogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuICBsZXQgZmluaXNoRXZlbnQ6IHtcbiAgICBmaW5pc2hSZWFzb246IEZpbmlzaFJlYXNvbjtcbiAgICB1c2FnZTogTGFuZ3VhZ2VNb2RlbFVzYWdlO1xuICAgIHdhcm5pbmdzPzogQ2FsbFdhcm5pbmdbXTtcbiAgICByZXNwb25zZT86IHtcbiAgICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH07XG4gIH0gfCBudWxsID0gbnVsbDtcblxuICBhc3luYyBmdW5jdGlvbiByZW5kZXIoe1xuICAgIGFyZ3MsXG4gICAgcmVuZGVyZXIsXG4gICAgc3RyZWFtYWJsZVVJLFxuICAgIGlzTGFzdENhbGwgPSBmYWxzZSxcbiAgfToge1xuICAgIHJlbmRlcmVyOiB1bmRlZmluZWQgfCBSZW5kZXJlcjxhbnk+O1xuICAgIGFyZ3M6IFtwYXlsb2FkOiBhbnldIHwgW3BheWxvYWQ6IGFueSwgb3B0aW9uczogYW55XTtcbiAgICBzdHJlYW1hYmxlVUk6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVN0cmVhbWFibGVVST47XG4gICAgaXNMYXN0Q2FsbD86IGJvb2xlYW47XG4gIH0pIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICAvLyBjcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSByZW5kZXIgY2FsbCBpcyBmaW5pc2hlZC5cbiAgICAvLyBpdCBpcyBhcHBlbmRlZCB0byB0aGUgYGZpbmlzaGVkYCBwcm9taXNlIGNoYWluIHRvIGVuc3VyZSB0aGUgcmVuZGVyIGNhbGxcbiAgICAvLyBpcyBmaW5pc2hlZCBiZWZvcmUgdGhlIG5leHQgcmVuZGVyIGNhbGwgc3RhcnRzLlxuICAgIGNvbnN0IHJlbmRlckZpbmlzaGVkID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcbiAgICBmaW5pc2hlZCA9IGZpbmlzaGVkXG4gICAgICA/IGZpbmlzaGVkLnRoZW4oKCkgPT4gcmVuZGVyRmluaXNoZWQucHJvbWlzZSlcbiAgICAgIDogcmVuZGVyRmluaXNoZWQucHJvbWlzZTtcblxuICAgIGNvbnN0IHJlbmRlcmVyUmVzdWx0ID0gcmVuZGVyZXIoLi4uYXJncyk7XG5cbiAgICBpZiAoaXNBc3luY0dlbmVyYXRvcihyZW5kZXJlclJlc3VsdCkgfHwgaXNHZW5lcmF0b3IocmVuZGVyZXJSZXN1bHQpKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZW5kZXJlclJlc3VsdC5uZXh0KCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNMYXN0Q2FsbCAmJiBkb25lKSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVVJLmRvbmUobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVVJLnVwZGF0ZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0IHJlbmRlcmVyUmVzdWx0O1xuXG4gICAgICBpZiAoaXNMYXN0Q2FsbCkge1xuICAgICAgICBzdHJlYW1hYmxlVUkuZG9uZShub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbWFibGVVSS51cGRhdGUobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSB0aGUgcHJvbWlzZSB0byBzaWduYWwgdGhhdCB0aGUgcmVuZGVyIGNhbGwgaXMgZmluaXNoZWRcbiAgICByZW5kZXJGaW5pc2hlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIH1cblxuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXMgfSk7XG5cbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gYXdhaXQgc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShhc3luYyAoKSA9PlxuICAgIG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gICAgICAgIHRvb2xzOiB0b29scyBhcyBhbnksXG4gICAgICAgIHRvb2xDaG9pY2UsXG4gICAgICAgIGFjdGl2ZVRvb2xzOiB1bmRlZmluZWQsXG4gICAgICB9KSxcbiAgICAgIHByb21wdDogYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgIHByb21wdDogdmFsaWRhdGVkUHJvbXB0LFxuICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBtb2RlbC5zdXBwb3J0ZWRVcmxzLFxuICAgICAgfSksXG4gICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSksXG4gICk7XG5cbiAgLy8gRm9yIHRoZSBzdHJlYW0gYW5kIGNvbnN1bWUgaXQgYXN5bmNocm9ub3VzbHk6XG4gIGNvbnN0IFtzdHJlYW0sIGZvcmtlZFN0cmVhbV0gPSByZXN1bHQuc3RyZWFtLnRlZSgpO1xuICAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgbGV0IGhhc1Rvb2xDYWxsID0gZmFsc2U7XG4gICAgICBsZXQgd2FybmluZ3M6IExhbmd1YWdlTW9kZWxWMkNhbGxXYXJuaW5nW10gfCB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IHJlYWRlciA9IGZvcmtlZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcblxuICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzdHJlYW0tc3RhcnQnOiB7XG4gICAgICAgICAgICB3YXJuaW5ncyA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gdmFsdWUudGV4dDtcbiAgICAgICAgICAgIHJlbmRlcih7XG4gICAgICAgICAgICAgIHJlbmRlcmVyOiB0ZXh0UmVuZGVyLFxuICAgICAgICAgICAgICBhcmdzOiBbeyBjb250ZW50LCBkb25lOiBmYWxzZSwgZGVsdGE6IHZhbHVlLnRleHQgfV0sXG4gICAgICAgICAgICAgIHN0cmVhbWFibGVVSTogdWksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3Rvb2wtY2FsbC1kZWx0YSc6IHtcbiAgICAgICAgICAgIGhhc1Rvb2xDYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3Rvb2wtY2FsbCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdmFsdWUudG9vbE5hbWUgYXMga2V5b2YgVE9PTFMgJiBzdHJpbmc7XG5cbiAgICAgICAgICAgIGlmICghdG9vbHMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0b29sID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKCF0b29sKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scyksXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNUb29sQ2FsbCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04oe1xuICAgICAgICAgICAgICB0ZXh0OiB2YWx1ZS5hcmdzLFxuICAgICAgICAgICAgICBzY2hlbWE6IHRvb2wucGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIHRvb2xBcmdzOiB2YWx1ZS5hcmdzLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcih7XG4gICAgICAgICAgICAgIHJlbmRlcmVyOiB0b29sLmdlbmVyYXRlLFxuICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB2YWx1ZS50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIHN0cmVhbWFibGVVSTogdWksXG4gICAgICAgICAgICAgIGlzTGFzdENhbGw6IHRydWUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICB0aHJvdyB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdmaW5pc2gnOiB7XG4gICAgICAgICAgICBmaW5pc2hFdmVudCA9IHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiB2YWx1ZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgIHVzYWdlOiB2YWx1ZS51c2FnZSxcbiAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQucmVzcG9uc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzVG9vbENhbGwpIHtcbiAgICAgICAgcmVuZGVyKHtcbiAgICAgICAgICByZW5kZXJlcjogdGV4dFJlbmRlcixcbiAgICAgICAgICBhcmdzOiBbeyBjb250ZW50LCBkb25lOiB0cnVlIH1dLFxuICAgICAgICAgIHN0cmVhbWFibGVVSTogdWksXG4gICAgICAgICAgaXNMYXN0Q2FsbDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGZpbmlzaGVkO1xuXG4gICAgICBpZiAoZmluaXNoRXZlbnQgJiYgb25GaW5pc2gpIHtcbiAgICAgICAgYXdhaXQgb25GaW5pc2goe1xuICAgICAgICAgIC4uLmZpbmlzaEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiB1aS52YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIER1cmluZyB0aGUgc3RyZWFtIHJlbmRlcmluZywgd2UgZG9uJ3Qgd2FudCB0byB0aHJvdyB0aGUgZXJyb3IgdG8gdGhlXG4gICAgICAvLyBwYXJlbnQgc2NvcGUgYnV0IG9ubHkgbGV0IHRoZSBSZWFjdCdzIGVycm9yIGJvdW5kYXJ5IHRvIGNhdGNoIGl0LlxuICAgICAgdWkuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBzdHJlYW0sXG4gICAgdmFsdWU6IHVpLnZhbHVlLFxuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+KFxuICB2YWx1ZTogdW5rbm93bixcbik6IHZhbHVlIGlzIEFzeW5jR2VuZXJhdG9yPFQsIFRSZXR1cm4sIFROZXh0PiB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlXG4gICk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+KFxuICB2YWx1ZTogdW5rbm93bixcbik6IHZhbHVlIGlzIEdlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZTtcbn1cbiIsIi8qKlxuICogV2FybmluZyB0aW1lIGZvciBub3RpZnlpbmcgZGV2ZWxvcGVycyB0aGF0IGEgc3RyZWFtIGlzIGhhbmdpbmcgaW4gZGV2IG1vZGVcbiAqIHVzaW5nIGEgY29uc29sZS53YXJuLlxuICovXG5leHBvcnQgY29uc3QgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TID0gMTUgKiAxMDAwO1xuIiwiaW1wb3J0IFJlYWN0LCB7IFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuXG4vLyBSZWN1cnNpdmUgdHlwZSBmb3IgdGhlIGNodW5rLlxudHlwZSBDaHVua1R5cGUgPVxuICB8IHtcbiAgICAgIGRvbmU6IGZhbHNlO1xuICAgICAgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICAgIG5leHQ6IFByb21pc2U8Q2h1bmtUeXBlPjtcbiAgICAgIGFwcGVuZD86IGJvb2xlYW47XG4gICAgfVxuICB8IHtcbiAgICAgIGRvbmU6IHRydWU7XG4gICAgICB2YWx1ZTogUmVhY3QuUmVhY3ROb2RlO1xuICAgIH07XG5cbi8vIFVzZSBzaW5nbGUgbGV0dGVyIG5hbWVzIGZvciB0aGUgdmFyaWFibGVzIHRvIHJlZHVjZSB0aGUgc2l6ZSBvZiB0aGUgUlNDIHBheWxvYWQuXG4vLyBgUmAgZm9yIGBSb3dgLCBgY2AgZm9yIGBjdXJyZW50YCwgYG5gIGZvciBgbmV4dGAuXG4vLyBOb3RlOiBBcnJheSBjb25zdHJ1Y3Rpb24gaXMgbmVlZGVkIHRvIGFjY2VzcyB0aGUgbmFtZSBSLlxuY29uc3QgUiA9IFtcbiAgKGFzeW5jICh7XG4gICAgYzogY3VycmVudCxcbiAgICBuOiBuZXh0LFxuICB9OiB7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8Q2h1bmtUeXBlPjtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNodW5rID0gYXdhaXQgbmV4dDtcblxuICAgIGlmIChjaHVuay5kb25lKSB7XG4gICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rLmFwcGVuZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICB7Y3VycmVudH1cbiAgICAgICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgICAgIDxSIGM9e2NodW5rLnZhbHVlfSBuPXtjaHVuay5uZXh0fSAvPlxuICAgICAgICAgIDwvU3VzcGVuc2U+XG4gICAgICAgIDwvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtjaHVuay52YWx1ZX0+XG4gICAgICAgIDxSIGM9e2NodW5rLnZhbHVlfSBuPXtjaHVuay5uZXh0fSAvPlxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApO1xuICB9KSBhcyB1bmtub3duIGFzIFJlYWN0LkZDPHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxDaHVua1R5cGU+O1xuICB9Pixcbl1bMF07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN1c3BlbmRlZCBjaHVuayBmb3IgUmVhY3QgU2VydmVyIENvbXBvbmVudHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgYSBzdXNwZW5zZWZ1bCBSZWFjdCBjb21wb25lbnQgdGhhdCBjYW4gYmUgZHluYW1pY2FsbHkgdXBkYXRlZC5cbiAqIEl0J3MgdXNlZnVsIGZvciBzdHJlYW1pbmcgdXBkYXRlcyB0byB0aGUgY2xpZW50IGluIGEgUmVhY3QgU2VydmVyIENvbXBvbmVudHMgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0LlJlYWN0Tm9kZX0gaW5pdGlhbFZhbHVlIC0gVGhlIGluaXRpYWwgdmFsdWUgdG8gcmVuZGVyIHdoaWxlIHRoZSBwcm9taXNlIGlzIHBlbmRpbmcuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZzpcbiAqICAgLSByb3c6IEEgUmVhY3Qgbm9kZSB0aGF0IHJlbmRlcnMgdGhlIHN1c3BlbnNlZnVsIGNvbnRlbnQuXG4gKiAgIC0gcmVzb2x2ZTogQSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggYSBuZXcgdmFsdWUuXG4gKiAgIC0gcmVqZWN0OiBBIGZ1bmN0aW9uIHRvIHJlamVjdCB0aGUgcHJvbWlzZSB3aXRoIGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3VzcGVuZGVkQ2h1bmsoaW5pdGlhbFZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpOiB7XG4gIHJvdzogUmVhY3QuUmVhY3ROb2RlO1xuICByZXNvbHZlOiAodmFsdWU6IENodW5rVHlwZSkgPT4gdm9pZDtcbiAgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG59IHtcbiAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPENodW5rVHlwZT4oKTtcblxuICByZXR1cm4ge1xuICAgIHJvdzogKFxuICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtpbml0aWFsVmFsdWV9PlxuICAgICAgICA8UiBjPXtpbml0aWFsVmFsdWV9IG49e3Byb21pc2V9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICksXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3QsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMgfSBmcm9tICcuLi91dGlsL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZSc7XG5pbXBvcnQgeyBjcmVhdGVTdXNwZW5kZWRDaHVuayB9IGZyb20gJy4vY3JlYXRlLXN1c3BlbmRlZC1jaHVuayc7XG5cbi8vIEl0J3MgbmVjZXNzYXJ5IHRvIGRlZmluZSB0aGUgdHlwZSBtYW51YWxseSBoZXJlLCBvdGhlcndpc2UgVHlwZVNjcmlwdCBjb21waWxlclxuLy8gd2lsbCBub3QgYmUgYWJsZSB0byBpbmZlciB0aGUgY29ycmVjdCByZXR1cm4gdHlwZSBhcyBpdCdzIGNpcmN1bGFyLlxudHlwZSBTdHJlYW1hYmxlVUlXcmFwcGVyID0ge1xuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlIFVJLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmQgcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC5cbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBSZWFjdC5SZWFjdE5vZGU7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgVUkgbm9kZS4gSXQgdGFrZXMgYSBuZXcgVUkgbm9kZSBhbmQgcmVwbGFjZXMgdGhlIG9sZCBvbmUuXG4gICAqL1xuICB1cGRhdGUodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYXBwZW5kIGEgbmV3IFVJIG5vZGUgdG8gdGhlIGVuZCBvZiB0aGUgb2xkIG9uZS5cbiAgICogT25jZSBhcHBlbmRlZCBhIG5ldyBVSSBub2RlLCB0aGUgcHJldmlvdXMgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoPGRpdj5oZWxsbzwvZGl2PilcbiAgICogdWkuYXBwZW5kKDxkaXY+d29ybGQ8L2Rpdj4pXG4gICAqXG4gICAqIC8vIFRoZSBVSSBub2RlIHdpbGwgYmU6XG4gICAqIC8vIDw+XG4gICAqIC8vICAgPGRpdj5oZWxsbzwvZGl2PlxuICAgKiAvLyAgIDxkaXY+d29ybGQ8L2Rpdj5cbiAgICogLy8gPC8+XG4gICAqIGBgYFxuICAgKi9cbiAgYXBwZW5kKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNpZ25hbCB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBVSSBzdHJlYW0uXG4gICAqIEl0IHdpbGwgYmUgdGhyb3duIG9uIHRoZSBjbGllbnQgc2lkZSBhbmQgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IGNvbXBvbmVudC5cbiAgICovXG4gIGVycm9yKGVycm9yOiBhbnkpOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBtYXJrcyB0aGUgVUkgbm9kZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dCBhbnkgcGFyYW1ldGVycyBvciB3aXRoIGEgbmV3IFVJIG5vZGUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgKiBPbmNlIGNhbGxlZCwgdGhlIFVJIG5vZGUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgYWx3YXlzICoqcmVxdWlyZWQqKiB0byBiZSBjYWxsZWQsIG90aGVyd2lzZSB0aGUgcmVzcG9uc2Ugd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAqL1xuICBkb25lKC4uLmFyZ3M6IFtSZWFjdC5SZWFjdE5vZGVdIHwgW10pOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwaWVjZSBvZiBjaGFuZ2VhYmxlIFVJIHRoYXQgY2FuIGJlIHN0cmVhbWVkIHRvIHRoZSBjbGllbnQuXG4gKiBPbiB0aGUgY2xpZW50IHNpZGUsIGl0IGNhbiBiZSByZW5kZXJlZCBhcyBhIG5vcm1hbCBSZWFjdCBub2RlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVUkoaW5pdGlhbFZhbHVlPzogUmVhY3QuUmVhY3ROb2RlKSB7XG4gIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHsgcm93LCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVN1c3BlbmRlZENodW5rKGluaXRpYWxWYWx1ZSk7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0U3RyZWFtKG1ldGhvZDogc3RyaW5nKSB7XG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICc6IFVJIHN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZC4nKTtcbiAgICB9XG4gIH1cblxuICBsZXQgd2FybmluZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkO1xuICBmdW5jdGlvbiB3YXJuVW5jbG9zZWRTdHJlYW0oKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnVGhlIHN0cmVhbWFibGUgVUkgaGFzIGJlZW4gc2xvdyB0byB1cGRhdGUuIFRoaXMgbWF5IGJlIGEgYnVnIG9yIGEgcGVyZm9ybWFuY2UgaXNzdWUgb3IgeW91IGZvcmdvdCB0byBjYWxsIGAuZG9uZSgpYC4nLFxuICAgICAgICApO1xuICAgICAgfSwgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgY29uc3Qgc3RyZWFtYWJsZTogU3RyZWFtYWJsZVVJV3JhcHBlciA9IHtcbiAgICB2YWx1ZTogcm93LFxuICAgIHVwZGF0ZSh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy51cGRhdGUoKScpO1xuXG4gICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHVwZGF0ZSB0aGUgdmFsdWUgaWYgaXQncyByZWZlcmVudGlhbGx5IGVxdWFsLlxuICAgICAgaWYgKHZhbHVlID09PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGN1cnJlbnRWYWx1ZSwgZG9uZTogZmFsc2UsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgYXBwZW5kKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmFwcGVuZCgpJyk7XG5cbiAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHJlc29sdmUoeyB2YWx1ZSwgZG9uZTogZmFsc2UsIGFwcGVuZDogdHJ1ZSwgbmV4dDogcmVzb2x2YWJsZS5wcm9taXNlIH0pO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlamVjdCA9IHJlc29sdmFibGUucmVqZWN0O1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBlcnJvcihlcnJvcjogYW55KSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5lcnJvcigpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChlcnJvcik7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgZG9uZSguLi5hcmdzOiBbXSB8IFtSZWFjdC5SZWFjdE5vZGVdKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5kb25lKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmUoeyB2YWx1ZTogYXJnc1swXSwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGN1cnJlbnRWYWx1ZSwgZG9uZTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gc3RyZWFtYWJsZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJIH07XG4iLCJleHBvcnQgY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9UWVBFID0gU3ltYm9sLmZvcigndWkuc3RyZWFtYWJsZS52YWx1ZScpO1xuXG5leHBvcnQgdHlwZSBTdHJlYW1hYmxlUGF0Y2ggPSB1bmRlZmluZWQgfCBbMCwgc3RyaW5nXTsgLy8gQXBwZW5kIHN0cmluZy5cblxuZGVjbGFyZSBjb25zdCBfX2ludGVybmFsX2N1cnI6IHVuaXF1ZSBzeW1ib2w7XG5kZWNsYXJlIGNvbnN0IF9faW50ZXJuYWxfZXJyb3I6IHVuaXF1ZSBzeW1ib2w7XG5cbi8qKlxuICogU3RyZWFtYWJsZVZhbHVlIGlzIGEgdmFsdWUgdGhhdCBjYW4gYmUgc3RyZWFtZWQgb3ZlciB0aGUgbmV0d29yayB2aWEgQUkgQWN0aW9ucy5cbiAqIFRvIHJlYWQgdGhlIHN0cmVhbWVkIHZhbHVlcywgdXNlIHRoZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgb3IgYHVzZVN0cmVhbWFibGVWYWx1ZWAgQVBJcy5cbiAqL1xuZXhwb3J0IHR5cGUgU3RyZWFtYWJsZVZhbHVlPFQgPSBhbnksIEUgPSBhbnk+ID0ge1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgdHlwZT86IHR5cGVvZiBTVFJFQU1BQkxFX1ZBTFVFX1RZUEU7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBjdXJyPzogVDtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIGVycm9yPzogRTtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIGRpZmY/OiBTdHJlYW1hYmxlUGF0Y2g7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBuZXh0PzogUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+O1xuXG4gIC8vIGJyYW5kZWQgdHlwZXMgdG8gbWFpbnRhaW4gdHlwZSBzaWduYXR1cmUgYWZ0ZXIgaW50ZXJuYWwgcHJvcGVydGllcyBhcmUgc3RyaXBwZWQuXG4gIFtfX2ludGVybmFsX2N1cnJdPzogVDtcbiAgW19faW50ZXJuYWxfZXJyb3JdPzogRTtcbn07XG4iLCJpbXBvcnQgeyBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMgfSBmcm9tICcuLi91dGlsL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZSc7XG5pbXBvcnQge1xuICBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUsXG4gIFN0cmVhbWFibGVQYXRjaCxcbiAgU3RyZWFtYWJsZVZhbHVlLFxufSBmcm9tICcuL3N0cmVhbWFibGUtdmFsdWUnO1xuXG5jb25zdCBTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0sgPSBTeW1ib2woJ3N0cmVhbWFibGUudmFsdWUubG9jaycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHdyYXBwZWQsIGNoYW5nZWFibGUgdmFsdWUgdGhhdCBjYW4gYmUgc3RyZWFtZWQgdG8gdGhlIGNsaWVudC5cbiAqIE9uIHRoZSBjbGllbnQgc2lkZSwgdGhlIHZhbHVlIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGhlIHJlYWRTdHJlYW1hYmxlVmFsdWUoKSBBUEkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZTxUID0gYW55LCBFID0gYW55PihcbiAgaW5pdGlhbFZhbHVlPzogVCB8IFJlYWRhYmxlU3RyZWFtPFQ+LFxuKSB7XG4gIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPVxuICAgIGluaXRpYWxWYWx1ZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8XG4gICAgKHR5cGVvZiBpbml0aWFsVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBpbml0aWFsVmFsdWUgIT09IG51bGwgJiZcbiAgICAgICdnZXRSZWFkZXInIGluIGluaXRpYWxWYWx1ZSAmJlxuICAgICAgdHlwZW9mIGluaXRpYWxWYWx1ZS5nZXRSZWFkZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICdsb2NrZWQnIGluIGluaXRpYWxWYWx1ZSAmJlxuICAgICAgdHlwZW9mIGluaXRpYWxWYWx1ZS5sb2NrZWQgPT09ICdib29sZWFuJyk7XG5cbiAgaWYgKCFpc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGw8VCwgRT4oaW5pdGlhbFZhbHVlKTtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbWFibGVWYWx1ZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGw8VCwgRT4oKTtcblxuICAvLyBTaW5jZSB0aGUgc3RyZWFtYWJsZSB2YWx1ZSB3aWxsIGJlIGZyb20gYSByZWFkYWJsZSBzdHJlYW0sIGl0J3Mgbm90IGFsbG93ZWRcbiAgLy8gdG8gdXBkYXRlIHRoZSB2YWx1ZSBtYW51YWxseSBhcyB0aGF0IGludHJvZHVjZXMgcmFjZSBjb25kaXRpb25zIGFuZFxuICAvLyB1bmV4cGVjdGVkIGJlaGF2aW9yLlxuICAvLyBXZSBsb2NrIHRoZSB2YWx1ZSB0byBwcmV2ZW50IGFueSB1cGRhdGVzIGZyb20gdGhlIHVzZXIuXG4gIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gdHJ1ZTtcblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb25zdW1lIHRoZSByZWFkYWJsZSBzdHJlYW0gYW5kIHVwZGF0ZSB0aGUgdmFsdWUuXG4gICAgICBjb25zdCByZWFkZXIgPSBpbml0aWFsVmFsdWUuZ2V0UmVhZGVyKCk7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmxvY2sgdGhlIHZhbHVlIHRvIGFsbG93IHVwZGF0ZXMuXG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVZhbHVlLmFwcGVuZCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVZhbHVlLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9jayB0aGUgdmFsdWUgYWdhaW4uXG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZS5kb25lKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZS5lcnJvcihlKTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHN0cmVhbWFibGVWYWx1ZTtcbn1cblxuLy8gSXQncyBuZWNlc3NhcnkgdG8gZGVmaW5lIHRoZSB0eXBlIG1hbnVhbGx5IGhlcmUsIG90aGVyd2lzZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4vLyB3aWxsIG5vdCBiZSBhYmxlIHRvIGluZmVyIHRoZSBjb3JyZWN0IHJldHVybiB0eXBlIGFzIGl0J3MgY2lyY3VsYXIuXG50eXBlIFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT4gPSB7XG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZFxuICAgKiByZWNlaXZlZCBieSB0aGUgY2xpZW50LiBUbyByZWFkIHRoZSBzdHJlYW1lZCB2YWx1ZXMsIHVzZSB0aGVcbiAgICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgIEFQSXMuXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogU3RyZWFtYWJsZVZhbHVlPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IHZhbHVlIHdpdGggYSBuZXcgb25lLlxuICAgKi9cbiAgdXBkYXRlKHZhbHVlOiBUKTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBkZWx0YSBzdHJpbmcgdG8gdGhlIGN1cnJlbnQgdmFsdWUuIEl0XG4gICAqIHJlcXVpcmVzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlIHRvIGJlIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogY29uc3Qgc3RyZWFtYWJsZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgnaGVsbG8nKTtcbiAgICogc3RyZWFtYWJsZS5hcHBlbmQoJyB3b3JsZCcpO1xuICAgKlxuICAgKiAvLyBUaGUgdmFsdWUgd2lsbCBiZSAnaGVsbG8gd29ybGQnXG4gICAqIGBgYFxuICAgKi9cbiAgYXBwZW5kKHZhbHVlOiBUKTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzaWduYWwgdGhhdCB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgdmFsdWUgc3RyZWFtLlxuICAgKiBJdCB3aWxsIGJlIHRocm93biBvbiB0aGUgY2xpZW50IHNpZGUgd2hlbiBjb25zdW1lZCB2aWFcbiAgICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgLlxuICAgKi9cbiAgZXJyb3IoZXJyb3I6IGFueSk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSB2YWx1ZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dFxuICAgKiBhbnkgcGFyYW1ldGVycyBvciB3aXRoIGEgbmV3IHZhbHVlIGFzIHRoZSBmaW5hbCBzdGF0ZS5cbiAgICogT25jZSBjYWxsZWQsIHRoZSB2YWx1ZSBjYW5ub3QgYmUgdXBkYXRlZCBvciBhcHBlbmRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhbHdheXMgKipyZXF1aXJlZCoqIHRvIGJlIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSByZXNwb25zZVxuICAgKiB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICovXG4gIGRvbmUoLi4uYXJnczogW1RdIHwgW10pOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVGhpcyBpcyBhbiBpbnRlcm5hbCBsb2NrIHRvIHByZXZlbnQgdGhlIHZhbHVlIGZyb20gYmVpbmdcbiAgICogdXBkYXRlZCBieSB0aGUgdXNlci5cbiAgICovXG4gIFtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdOiBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxUID0gYW55LCBFID0gYW55Pihpbml0aWFsVmFsdWU/OiBUKSB7XG4gIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgbGV0IGxvY2tlZCA9IGZhbHNlO1xuICBsZXQgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPFN0cmVhbWFibGVWYWx1ZTxULCBFPj4oKTtcblxuICBsZXQgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBsZXQgY3VycmVudEVycm9yOiBFIHwgdW5kZWZpbmVkO1xuICBsZXQgY3VycmVudFByb21pc2U6IHR5cGVvZiByZXNvbHZhYmxlLnByb21pc2UgfCB1bmRlZmluZWQgPVxuICAgIHJlc29sdmFibGUucHJvbWlzZTtcbiAgbGV0IGN1cnJlbnRQYXRjaFZhbHVlOiBTdHJlYW1hYmxlUGF0Y2g7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0U3RyZWFtKG1ldGhvZDogc3RyaW5nKSB7XG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICc6IFZhbHVlIHN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZC4nKTtcbiAgICB9XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBtZXRob2QgKyAnOiBWYWx1ZSBzdHJlYW0gaXMgbG9ja2VkIGFuZCBjYW5ub3QgYmUgdXBkYXRlZC4nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBsZXQgd2FybmluZ1RpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkO1xuICBmdW5jdGlvbiB3YXJuVW5jbG9zZWRTdHJlYW0oKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnVGhlIHN0cmVhbWFibGUgdmFsdWUgaGFzIGJlZW4gc2xvdyB0byB1cGRhdGUuIFRoaXMgbWF5IGJlIGEgYnVnIG9yIGEgcGVyZm9ybWFuY2UgaXNzdWUgb3IgeW91IGZvcmdvdCB0byBjYWxsIGAuZG9uZSgpYC4nLFxuICAgICAgICApO1xuICAgICAgfSwgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlZChpbml0aWFsQ2h1bms/OiBib29sZWFuKTogU3RyZWFtYWJsZVZhbHVlPFQsIEU+IHtcbiAgICAvLyBUaGlzIG1ha2VzIHRoZSBwYXlsb2FkIG11Y2ggc21hbGxlciBpZiB0aGVyZSdyZSBtdXRhdGl2ZSB1cGRhdGVzIGJlZm9yZSB0aGUgZmlyc3QgcmVhZC5cbiAgICBsZXQgaW5pdDogUGFydGlhbDxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+O1xuXG4gICAgaWYgKGN1cnJlbnRFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbml0ID0geyBlcnJvcjogY3VycmVudEVycm9yIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50UGF0Y2hWYWx1ZSAmJiAhaW5pdGlhbENodW5rKSB7XG4gICAgICAgIGluaXQgPSB7IGRpZmY6IGN1cnJlbnRQYXRjaFZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0ID0geyBjdXJyOiBjdXJyZW50VmFsdWUgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFByb21pc2UpIHtcbiAgICAgIGluaXQubmV4dCA9IGN1cnJlbnRQcm9taXNlO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsQ2h1bmspIHtcbiAgICAgIGluaXQudHlwZSA9IFNUUkVBTUFCTEVfVkFMVUVfVFlQRTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgYGN1cnJlbnRWYWx1ZWAgYW5kIGBjdXJyZW50UGF0Y2hWYWx1ZWAgaWYgbmVlZGVkLlxuICBmdW5jdGlvbiB1cGRhdGVWYWx1ZVN0YXRlcyh2YWx1ZTogVCkge1xuICAgIC8vIElmIHdlIGNhbiBvbmx5IHNlbmQgYSBwYXRjaCBvdmVyIHRoZSB3aXJlLCBpdCdzIGJldHRlciB0byBkbyBzby5cbiAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZS5zbGljZShjdXJyZW50VmFsdWUubGVuZ3RoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbWFibGU6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT4gPSB7XG4gICAgc2V0IFtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdKHN0YXRlOiBib29sZWFuKSB7XG4gICAgICBsb2NrZWQgPSBzdGF0ZTtcbiAgICB9LFxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVkKHRydWUpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlOiBUKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy51cGRhdGUoKScpO1xuXG4gICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcblxuICAgICAgdXBkYXRlVmFsdWVTdGF0ZXModmFsdWUpO1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgICByZXNvbHZlUHJldmlvdXMoY3JlYXRlV3JhcHBlZCgpKTtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgYXBwZW5kKHZhbHVlOiBUKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5hcHBlbmQoKScpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAuYXBwZW5kKCk6IFRoZSBjdXJyZW50IHZhbHVlIGlzIG5vdCBhIHN0cmluZy4gUmVjZWl2ZWQ6ICR7dHlwZW9mIGN1cnJlbnRWYWx1ZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAuYXBwZW5kKCk6IFRoZSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuIFJlY2VpdmVkOiAke3R5cGVvZiB2YWx1ZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcblxuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gWzAsIHZhbHVlXTtcbiAgICAgICAgKGN1cnJlbnRWYWx1ZSBhcyBzdHJpbmcpID0gY3VycmVudFZhbHVlICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmVycm9yKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgY3VycmVudEVycm9yID0gZXJyb3I7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHsgZXJyb3IgfSk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgZG9uZSguLi5hcmdzOiBbXSB8IFtUXSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZG9uZSgpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdXBkYXRlVmFsdWVTdGF0ZXMoYXJnc1swXSk7XG4gICAgICAgIHJlc29sdmFibGUucmVzb2x2ZShjcmVhdGVXcmFwcGVkKCkpO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHt9KTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gc3RyZWFtYWJsZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVZhbHVlIH07XG4iXSwibmFtZXMiOlsianN4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/rsc/dist/rsc-shared.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/rsc/dist/rsc-shared.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),
/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),
/* harmony export */   useAIState: () => (/* binding */ useAIState),
/* harmony export */   useActions: () => (/* binding */ useActions),
/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),
/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),
/* harmony export */   useUIState: () => (/* binding */ useUIState)
/* harmony export */ });
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server.edge */ "(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server-edge.js");

const InternalAIProvider = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call InternalAIProvider() from the server but InternalAIProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\Users\\likho\\OneDrive\\GitHub\\Apex\\node_modules\\@ai-sdk\\rsc\\dist\\rsc-shared.mjs",
"InternalAIProvider",
);const readStreamableValue = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call readStreamableValue() from the server but readStreamableValue is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\Users\\likho\\OneDrive\\GitHub\\Apex\\node_modules\\@ai-sdk\\rsc\\dist\\rsc-shared.mjs",
"readStreamableValue",
);const useAIState = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useAIState() from the server but useAIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\Users\\likho\\OneDrive\\GitHub\\Apex\\node_modules\\@ai-sdk\\rsc\\dist\\rsc-shared.mjs",
"useAIState",
);const useActions = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useActions() from the server but useActions is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\Users\\likho\\OneDrive\\GitHub\\Apex\\node_modules\\@ai-sdk\\rsc\\dist\\rsc-shared.mjs",
"useActions",
);const useStreamableValue = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useStreamableValue() from the server but useStreamableValue is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\Users\\likho\\OneDrive\\GitHub\\Apex\\node_modules\\@ai-sdk\\rsc\\dist\\rsc-shared.mjs",
"useStreamableValue",
);const useSyncUIState = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useSyncUIState() from the server but useSyncUIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\Users\\likho\\OneDrive\\GitHub\\Apex\\node_modules\\@ai-sdk\\rsc\\dist\\rsc-shared.mjs",
"useSyncUIState",
);const useUIState = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call useUIState() from the server but useUIState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"C:\\Users\\likho\\OneDrive\\GitHub\\Apex\\node_modules\\@ai-sdk\\rsc\\dist\\rsc-shared.mjs",
"useUIState",
);

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncIteratorToReadableStream: () => (/* binding */ convertAsyncIteratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertToBase64: () => (/* binding */ convertToBase64),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createBinaryResponseHandler: () => (/* binding */ createBinaryResponseHandler),\n/* harmony export */   createEventSourceParserStream: () => (/* binding */ createEventSourceParserStream),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   createStatusCodeErrorResponseHandler: () => (/* binding */ createStatusCodeErrorResponseHandler),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getFromApi: () => (/* binding */ getFromApi),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isUrlSupported: () => (/* binding */ isUrlSupported),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   parseJsonEventStream: () => (/* binding */ parseJsonEventStream),\n/* harmony export */   parseProviderOptions: () => (/* binding */ parseProviderOptions),\n/* harmony export */   postFormDataToApi: () => (/* binding */ postFormDataToApi),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   removeUndefinedEntries: () => (/* binding */ removeUndefinedEntries),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   standardSchemaValidator: () => (/* binding */ standardSchemaValidator),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs == null ? Promise.resolve() : new Promise((resolve2) => setTimeout(resolve2, delayInMs));\n}\n\n// src/event-source-parser-stream.ts\nfunction createEventSourceParserStream() {\n  let buffer = \"\";\n  let event = void 0;\n  let data = [];\n  let lastEventId = void 0;\n  let retry = void 0;\n  function parseLine(line, controller) {\n    if (line === \"\") {\n      dispatchEvent(controller);\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      return;\n    }\n    const colonIndex = line.indexOf(\":\");\n    if (colonIndex === -1) {\n      handleField(line, \"\");\n      return;\n    }\n    const field = line.slice(0, colonIndex);\n    const valueStart = colonIndex + 1;\n    const value = valueStart < line.length && line[valueStart] === \" \" ? line.slice(valueStart + 1) : line.slice(valueStart);\n    handleField(field, value);\n  }\n  function dispatchEvent(controller) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join(\"\\n\"),\n        id: lastEventId,\n        retry\n      });\n      data = [];\n      event = void 0;\n      retry = void 0;\n    }\n  }\n  function handleField(field, value) {\n    switch (field) {\n      case \"event\":\n        event = value;\n        break;\n      case \"data\":\n        data.push(value);\n        break;\n      case \"id\":\n        lastEventId = value;\n        break;\n      case \"retry\":\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n      buffer = incompleteLine;\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    }\n  });\n}\nfunction splitLines(buffer, chunk) {\n  const lines = [];\n  let currentLine = buffer;\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n    if (char === \"\\n\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n    } else if (char === \"\\r\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n      if (chunk[i] === \"\\n\") {\n        i++;\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n  return { lines, incompleteLine: currentLine };\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\n\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\n\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {}\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/is-url-supported.ts\nfunction isUrlSupported({\n  mediaType,\n  url,\n  supportedUrls\n}) {\n  url = url.toLowerCase();\n  mediaType = mediaType.toLowerCase();\n  return Object.entries(supportedUrls).map(([key, value]) => {\n    const mediaType2 = key.toLowerCase();\n    return mediaType2 === \"*\" || mediaType2 === \"*/*\" ? { mediaTypePrefix: \"\", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\\*/, \"\"), regexes: value };\n  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url));\n}\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\n\n\n// src/secure-json-parse.ts\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\n\n// src/validate-types.ts\n\n\n// src/validator.ts\n\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async (value) => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? { success: true, value: result.value } : {\n      success: false,\n      error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\n\n// src/validate-types.ts\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({ value, schema });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await validator2.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: result.error }),\n      rawValue: value\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.wrap({ value, cause: error }),\n      rawValue: value\n    };\n  }\n}\n\n// src/parse-json.ts\nasync function parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError({ text, cause: error });\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError({ text, cause: error }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-json-event-stream.ts\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(\n    new TransformStream({\n      async transform({ data }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(await safeParseJSON({ text: data, schema }));\n      }\n    })\n  );\n}\n\n// src/parse-provider-options.ts\n\nasync function parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = await safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\n\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postFormDataToApi = async ({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema\n    })\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        async transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              await safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/zod-schema.ts\n\nfunction zodSchema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(zodSchema2, {\n      $refStrategy: useReferences ? \"root\" : \"none\",\n      target: \"jsonSchema7\"\n      // note: openai mode breaks various gemini conversions\n    }),\n    {\n      validate: (value) => {\n        const result = zodSchema2.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return schema == null ? jsonSchema({\n    properties: {},\n    additionalProperties: false\n  }) : isSchema(schema) ? schema : zodSchema(schema);\n}\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\nfunction convertToBase64(value) {\n  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n// src/index.ts\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yc2Mvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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QzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0M7QUE4Q3BDO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXEFwZXhcXG5vZGVfbW9kdWxlc1xcQGFpLXNka1xccnNjXFxub2RlX21vZHVsZXNcXEBhaS1zZGtcXHByb3ZpZGVyLXV0aWxzXFxkaXN0XFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbWJpbmUtaGVhZGVycy50c1xuZnVuY3Rpb24gY29tYmluZUhlYWRlcnMoLi4uaGVhZGVycykge1xuICByZXR1cm4gaGVhZGVycy5yZWR1Y2UoXG4gICAgKGNvbWJpbmVkSGVhZGVycywgY3VycmVudEhlYWRlcnMpID0+ICh7XG4gICAgICAuLi5jb21iaW5lZEhlYWRlcnMsXG4gICAgICAuLi5jdXJyZW50SGVhZGVycyAhPSBudWxsID8gY3VycmVudEhlYWRlcnMgOiB7fVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG59XG5cbi8vIHNyYy9jb252ZXJ0LWFzeW5jLWl0ZXJhdG9yLXRvLXJlYWRhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtKGl0ZXJhdG9yKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciB3YW50cyB0byBwdWxsIG1vcmUgZGF0YSBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VD59IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBlbnF1ZXVlIGRhdGEgaW50byB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciBjYW5jZWxzIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9kZWxheS50c1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zKSB7XG4gIHJldHVybiBkZWxheUluTXMgPT0gbnVsbCA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoKHJlc29sdmUyKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUyLCBkZWxheUluTXMpKTtcbn1cblxuLy8gc3JjL2V2ZW50LXNvdXJjZS1wYXJzZXItc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpIHtcbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIGxldCBldmVudCA9IHZvaWQgMDtcbiAgbGV0IGRhdGEgPSBbXTtcbiAgbGV0IGxhc3RFdmVudElkID0gdm9pZCAwO1xuICBsZXQgcmV0cnkgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lLCBjb250cm9sbGVyKSB7XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGRpc3BhdGNoRXZlbnQoY29udHJvbGxlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCI6XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICAgICAgaGFuZGxlRmllbGQobGluZSwgXCJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gbGluZS5zbGljZSgwLCBjb2xvbkluZGV4KTtcbiAgICBjb25zdCB2YWx1ZVN0YXJ0ID0gY29sb25JbmRleCArIDE7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVN0YXJ0IDwgbGluZS5sZW5ndGggJiYgbGluZVt2YWx1ZVN0YXJ0XSA9PT0gXCIgXCIgPyBsaW5lLnNsaWNlKHZhbHVlU3RhcnQgKyAxKSA6IGxpbmUuc2xpY2UodmFsdWVTdGFydCk7XG4gICAgaGFuZGxlRmllbGQoZmllbGQsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGNvbnRyb2xsZXIpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICBldmVudCxcbiAgICAgICAgZGF0YTogZGF0YS5qb2luKFwiXFxuXCIpLFxuICAgICAgICBpZDogbGFzdEV2ZW50SWQsXG4gICAgICAgIHJldHJ5XG4gICAgICB9KTtcbiAgICAgIGRhdGEgPSBbXTtcbiAgICAgIGV2ZW50ID0gdm9pZCAwO1xuICAgICAgcmV0cnkgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUZpZWxkKGZpZWxkLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICBldmVudCA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIGRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgIGxhc3RFdmVudElkID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgIGNvbnN0IHBhcnNlZFJldHJ5ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWRSZXRyeSkpIHtcbiAgICAgICAgICByZXRyeSA9IHBhcnNlZFJldHJ5O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGxpbmVzLCBpbmNvbXBsZXRlTGluZSB9ID0gc3BsaXRMaW5lcyhidWZmZXIsIGNodW5rKTtcbiAgICAgIGJ1ZmZlciA9IGluY29tcGxldGVMaW5lO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJzZUxpbmUobGluZXNbaV0sIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgcGFyc2VMaW5lKGJ1ZmZlciwgY29udHJvbGxlcik7XG4gICAgICBkaXNwYXRjaEV2ZW50KGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzcGxpdExpbmVzKGJ1ZmZlciwgY2h1bmspIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgbGV0IGN1cnJlbnRMaW5lID0gYnVmZmVyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgY2hhciA9IGNodW5rW2krK107XG4gICAgaWYgKGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgY3VycmVudExpbmUgPSBcIlwiO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCJcXHJcIikge1xuICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICBjdXJyZW50TGluZSA9IFwiXCI7XG4gICAgICBpZiAoY2h1bmtbaV0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50TGluZSArPSBjaGFyO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBsaW5lcywgaW5jb21wbGV0ZUxpbmU6IGN1cnJlbnRMaW5lIH07XG59XG5cbi8vIHNyYy9leHRyYWN0LXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtaWQudHNcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBjcmVhdGVJZEdlbmVyYXRvciA9ICh7XG4gIHByZWZpeCxcbiAgc2l6ZSA9IDE2LFxuICBhbHBoYWJldCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgc2VwYXJhdG9yID0gXCItXCJcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgY29uc3QgYWxwaGFiZXRMZW5ndGggPSBhbHBoYWJldC5sZW5ndGg7XG4gICAgY29uc3QgY2hhcnMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gYWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0TGVuZ3RoIHwgMF07XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKFwiXCIpO1xuICB9O1xuICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGlmIChhbHBoYWJldC5pbmNsdWRlcyhzZXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIGFyZ3VtZW50OiBcInNlcGFyYXRvclwiLFxuICAgICAgbWVzc2FnZTogYFRoZSBzZXBhcmF0b3IgXCIke3NlcGFyYXRvcn1cIiBtdXN0IG5vdCBiZSBwYXJ0IG9mIHRoZSBhbHBoYWJldCBcIiR7YWxwaGFiZXR9XCIuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoKSA9PiBgJHtwcmVmaXh9JHtzZXBhcmF0b3J9JHtnZW5lcmF0b3IoKX1gO1xufTtcbnZhciBnZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3IoKTtcblxuLy8gc3JjL2dldC1lcnJvci1tZXNzYWdlLnRzXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG59XG5cbi8vIHNyYy9nZXQtZnJvbS1hcGkudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9yZW1vdmUtdW5kZWZpbmVkLWVudHJpZXMudHNcbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEVudHJpZXMocmVjb3JkKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMocmVjb3JkKS5maWx0ZXIoKFtfa2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpXG4gICk7XG59XG5cbi8vIHNyYy9pcy1hYm9ydC1lcnJvci50c1xuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKTtcbn1cblxuLy8gc3JjL2dldC1mcm9tLWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBnbG9iYWxUaGlzLmZldGNoO1xudmFyIGdldEZyb21BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2ggPSBnZXRPcmlnaW5hbEZldGNoKClcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczogcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhoZWFkZXJzKSxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JJbmZvcm1hdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9ySW5mb3JtYXRpb24gPSBhd2FpdCBmYWlsZWRSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBzdWNjZXNzZnVsIHJlc3BvbnNlXCIsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikge1xuICAgICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZTtcbiAgICAgIGlmIChjYXVzZSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29ubmVjdCB0byBBUEk6ICR7Y2F1c2UubWVzc2FnZX1gLFxuICAgICAgICAgIGNhdXNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICBpc1JldHJ5YWJsZTogdHJ1ZSxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBzcmMvaXMtdXJsLXN1cHBvcnRlZC50c1xuZnVuY3Rpb24gaXNVcmxTdXBwb3J0ZWQoe1xuICBtZWRpYVR5cGUsXG4gIHVybCxcbiAgc3VwcG9ydGVkVXJsc1xufSkge1xuICB1cmwgPSB1cmwudG9Mb3dlckNhc2UoKTtcbiAgbWVkaWFUeXBlID0gbWVkaWFUeXBlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWRVcmxzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG1lZGlhVHlwZTIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbWVkaWFUeXBlMiA9PT0gXCIqXCIgfHwgbWVkaWFUeXBlMiA9PT0gXCIqLypcIiA/IHsgbWVkaWFUeXBlUHJlZml4OiBcIlwiLCByZWdleGVzOiB2YWx1ZSB9IDogeyBtZWRpYVR5cGVQcmVmaXg6IG1lZGlhVHlwZTIucmVwbGFjZSgvXFwqLywgXCJcIiksIHJlZ2V4ZXM6IHZhbHVlIH07XG4gIH0pLmZpbHRlcigoeyBtZWRpYVR5cGVQcmVmaXggfSkgPT4gbWVkaWFUeXBlLnN0YXJ0c1dpdGgobWVkaWFUeXBlUHJlZml4KSkuZmxhdE1hcCgoeyByZWdleGVzIH0pID0+IHJlZ2V4ZXMpLnNvbWUoKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdCh1cmwpKTtcbn1cblxuLy8gc3JjL2xvYWQtYXBpLWtleS50c1xuaW1wb3J0IHsgTG9hZEFQSUtleUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGxvYWRBcGlLZXkoe1xuICBhcGlLZXksXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBhcGlLZXlQYXJhbWV0ZXJOYW1lID0gXCJhcGlLZXlcIixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBhcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYXBpS2V5O1xuICB9XG4gIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBhcGlLZXkgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgYXBpS2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gc3JjL2xvYWQtb3B0aW9uYWwtc2V0dGluZy50c1xuZnVuY3Rpb24gbG9hZE9wdGlvbmFsU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCB8fCB0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc2V0dGluZ1ZhbHVlID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoc2V0dGluZ1ZhbHVlID09IG51bGwgfHwgdHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL2xvYWQtc2V0dGluZy50c1xuaW1wb3J0IHsgTG9hZFNldHRpbmdFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUsXG4gIHNldHRpbmdOYW1lLFxuICBkZXNjcmlwdGlvblxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuIFRoZSB2YWx1ZSBvZiB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuaW1wb3J0IHtcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3NlY3VyZS1qc29uLXBhcnNlLnRzXG52YXIgc3VzcGVjdFByb3RvUnggPSAvXCJfX3Byb3RvX19cIlxccyo6LztcbnZhciBzdXNwZWN0Q29uc3RydWN0b3JSeCA9IC9cImNvbnN0cnVjdG9yXCJcXHMqOi87XG5mdW5jdGlvbiBfcGFyc2UodGV4dCkge1xuICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHRleHQpO1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChzdXNwZWN0UHJvdG9SeC50ZXN0KHRleHQpID09PSBmYWxzZSAmJiBzdXNwZWN0Q29uc3RydWN0b3JSeC50ZXN0KHRleHQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcihvYmopO1xufVxuZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICBsZXQgbmV4dCA9IFtvYmpdO1xuICB3aGlsZSAobmV4dC5sZW5ndGgpIHtcbiAgICBjb25zdCBub2RlcyA9IG5leHQ7XG4gICAgbmV4dCA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBcIl9fcHJvdG9fX1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJPYmplY3QgY29udGFpbnMgZm9yYmlkZGVuIHByb3RvdHlwZSBwcm9wZXJ0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgXCJjb25zdHJ1Y3RvclwiKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZS5jb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiT2JqZWN0IGNvbnRhaW5zIGZvcmJpZGRlbiBwcm90b3R5cGUgcHJvcGVydHlcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gc2VjdXJlSnNvblBhcnNlKHRleHQpIHtcbiAgY29uc3QgeyBzdGFja1RyYWNlTGltaXQgfSA9IEVycm9yO1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuICB0cnkge1xuICAgIHJldHVybiBfcGFyc2UodGV4dCk7XG4gIH0gZmluYWxseSB7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0O1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuaW1wb3J0IHsgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy92YWxpZGF0b3IudHNcbmltcG9ydCB7IFR5cGVWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIHZhbGlkYXRvclN5bWJvbCA9IFN5bWJvbC5mb3IoXCJ2ZXJjZWwuYWkudmFsaWRhdG9yXCIpO1xuZnVuY3Rpb24gdmFsaWRhdG9yKHZhbGlkYXRlKSB7XG4gIHJldHVybiB7IFt2YWxpZGF0b3JTeW1ib2xdOiB0cnVlLCB2YWxpZGF0ZSB9O1xufVxuZnVuY3Rpb24gaXNWYWxpZGF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWxpZGF0b3JTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbdmFsaWRhdG9yU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gaXNWYWxpZGF0b3IodmFsdWUpID8gdmFsdWUgOiBzdGFuZGFyZFNjaGVtYVZhbGlkYXRvcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBzdGFuZGFyZFNjaGVtYVZhbGlkYXRvcihzdGFuZGFyZFNjaGVtYSkge1xuICByZXR1cm4gdmFsaWRhdG9yKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0YW5kYXJkU2NoZW1hW1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0Lmlzc3VlcyA9PSBudWxsID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LnZhbHVlIH0gOiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcih7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjYXVzZTogcmVzdWx0Lmlzc3Vlc1xuICAgICAgfSlcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRlLXR5cGVzLnRzXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBUeXBlVmFsaWRhdGlvbkVycm9yMi53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCB2YWxpZGF0b3IyID0gYXNWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAodmFsaWRhdG9yMi52YWxpZGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvcjIudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC52YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBUeXBlVmFsaWRhdGlvbkVycm9yMi53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSksXG4gICAgICByYXdWYWx1ZTogdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBUeXBlVmFsaWRhdGlvbkVycm9yMi53cmFwKHsgdmFsdWUsIGNhdXNlOiBlcnJvciB9KSxcbiAgICAgIHJhd1ZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gc2VjdXJlSnNvblBhcnNlKHRleHQpO1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKEpTT05QYXJzZUVycm9yLmlzSW5zdGFuY2UoZXJyb3IpIHx8IFR5cGVWYWxpZGF0aW9uRXJyb3IzLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzYWZlUGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBzZWN1cmVKc29uUGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IEpTT05QYXJzZUVycm9yLmlzSW5zdGFuY2UoZXJyb3IpID8gZXJyb3IgOiBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSksXG4gICAgICByYXdWYWx1ZTogdm9pZCAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJzYWJsZUpzb24oaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBzZWN1cmVKc29uUGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS1qc29uLWV2ZW50LXN0cmVhbS50c1xuZnVuY3Rpb24gcGFyc2VKc29uRXZlbnRTdHJlYW0oe1xuICBzdHJlYW0sXG4gIHNjaGVtYVxufSkge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybSh7IGRhdGEgfSwgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXdhaXQgc2FmZVBhcnNlSlNPTih7IHRleHQ6IGRhdGEsIHNjaGVtYSB9KSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3BhcnNlLXByb3ZpZGVyLW9wdGlvbnMudHNcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5hc3luYyBmdW5jdGlvbiBwYXJzZVByb3ZpZGVyT3B0aW9ucyh7XG4gIHByb3ZpZGVyLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIHNjaGVtYVxufSkge1xuICBpZiAoKHByb3ZpZGVyT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcHJvdmlkZXJPcHRpb25zW3Byb3ZpZGVyXSkgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcGFyc2VkUHJvdmlkZXJPcHRpb25zID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgIHZhbHVlOiBwcm92aWRlck9wdGlvbnNbcHJvdmlkZXJdLFxuICAgIHNjaGVtYVxuICB9KTtcbiAgaWYgKCFwYXJzZWRQcm92aWRlck9wdGlvbnMuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcjIoe1xuICAgICAgYXJndW1lbnQ6IFwicHJvdmlkZXJPcHRpb25zXCIsXG4gICAgICBtZXNzYWdlOiBgaW52YWxpZCAke3Byb3ZpZGVyfSBwcm92aWRlciBvcHRpb25zYCxcbiAgICAgIGNhdXNlOiBwYXJzZWRQcm92aWRlck9wdGlvbnMuZXJyb3JcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGFyc2VkUHJvdmlkZXJPcHRpb25zLnZhbHVlO1xufVxuXG4vLyBzcmMvcG9zdC10by1hcGkudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBnZXRPcmlnaW5hbEZldGNoMiA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgcG9zdEpzb25Ub0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVyczoge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIC4uLmhlYWRlcnNcbiAgfSxcbiAgYm9keToge1xuICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIHZhbHVlczogYm9keVxuICB9LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSk7XG52YXIgcG9zdEZvcm1EYXRhVG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMsXG4gIGZvcm1EYXRhLFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSkgPT4gcG9zdFRvQXBpKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBib2R5OiB7XG4gICAgY29udGVudDogZm9ybURhdGEsXG4gICAgdmFsdWVzOiBPYmplY3QuZnJvbUVudHJpZXMoZm9ybURhdGEuZW50cmllcygpKVxuICB9LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSk7XG52YXIgcG9zdFRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGJvZHksXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoID0gZ2V0T3JpZ2luYWxGZXRjaDIoKVxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhoZWFkZXJzKSxcbiAgICAgIGJvZHk6IGJvZHkuY29udGVudCxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JJbmZvcm1hdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9ySW5mb3JtYXRpb24gPSBhd2FpdCBmYWlsZWRSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2U7XG4gICAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgICAgbWVzc2FnZTogYENhbm5vdCBjb25uZWN0IHRvIEFQSTogJHtjYXVzZS5tZXNzYWdlfWAsXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlcyxcbiAgICAgICAgICBpc1JldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIC8vIHJldHJ5IHdoZW4gbmV0d29yayBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNvbHZlLnRzXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbn1cblxuLy8gc3JjL3Jlc3BvbnNlLWhhbmRsZXIudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IzLCBFbXB0eVJlc3BvbnNlQm9keUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIgPSAoe1xuICBlcnJvclNjaGVtYSxcbiAgZXJyb3JUb01lc3NhZ2UsXG4gIGlzUmV0cnlhYmxlXG59KSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZUJvZHkudHJpbSgpID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWRFcnJvciA9IGF3YWl0IHBhcnNlSlNPTih7XG4gICAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgICBzY2hlbWE6IGVycm9yU2NoZW1hXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVG9NZXNzYWdlKHBhcnNlZEVycm9yKSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgZGF0YTogcGFyc2VkRXJyb3IsXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UsIHBhcnNlZEVycm9yKVxuICAgICAgfSlcbiAgICB9O1xuICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH07XG4gIH1cbn07XG52YXIgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IHBhcnNlSnNvbkV2ZW50U3RyZWFtKHtcbiAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICB9KVxuICB9O1xufTtcbnZhciBjcmVhdGVKc29uU3RyZWFtUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIGxldCBidWZmZXIgPSBcIlwiO1xuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcmVzcG9uc2UuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rVGV4dCwgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmIChjaHVua1RleHQuZW5kc1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgYXdhaXQgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgICAgdGV4dDogYnVmZmVyICsgY2h1bmtUZXh0LFxuICAgICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtUZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgPSAocmVzcG9uc2VTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHtcbiAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgc2NoZW1hOiByZXNwb25zZVNjaGVtYVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmICghcGFyc2VkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICBtZXNzYWdlOiBcIkludmFsaWQgSlNPTiByZXNwb25zZVwiLFxuICAgICAgY2F1c2U6IHBhcnNlZFJlc3VsdC5lcnJvcixcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IHBhcnNlZFJlc3VsdC52YWx1ZSxcbiAgICByYXdWYWx1ZTogcGFyc2VkUmVzdWx0LnJhd1ZhbHVlXG4gIH07XG59O1xudmFyIGNyZWF0ZUJpbmFyeVJlc3BvbnNlSGFuZGxlciA9ICgpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgIG1lc3NhZ2U6IFwiUmVzcG9uc2UgYm9keSBpcyBlbXB0eVwiLFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHk6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHJlYWQgcmVzcG9uc2UgYXMgYXJyYXkgYnVmZmVyXCIsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdm9pZCAwLFxuICAgICAgY2F1c2U6IGVycm9yXG4gICAgfSk7XG4gIH1cbn07XG52YXIgY3JlYXRlU3RhdHVzQ29kZUVycm9yUmVzcG9uc2VIYW5kbGVyID0gKCkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5XG4gICAgfSlcbiAgfTtcbn07XG5cbi8vIHNyYy96b2Qtc2NoZW1hLnRzXG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjtcbmZ1bmN0aW9uIHpvZFNjaGVtYSh6b2RTY2hlbWEyLCBvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgdXNlUmVmZXJlbmNlcyA9IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudXNlUmVmZXJlbmNlcykgIT0gbnVsbCA/IF9hIDogZmFsc2U7XG4gIHJldHVybiBqc29uU2NoZW1hKFxuICAgIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEyLCB7XG4gICAgICAkcmVmU3RyYXRlZ3k6IHVzZVJlZmVyZW5jZXMgPyBcInJvb3RcIiA6IFwibm9uZVwiLFxuICAgICAgdGFyZ2V0OiBcImpzb25TY2hlbWE3XCJcbiAgICAgIC8vIG5vdGU6IG9wZW5haSBtb2RlIGJyZWFrcyB2YXJpb3VzIGdlbWluaSBjb252ZXJzaW9uc1xuICAgIH0pLFxuICAgIHtcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gem9kU2NoZW1hMi5zYWZlUGFyc2UodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQuZGF0YSB9IDogeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3VsdC5lcnJvciB9O1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuLy8gc3JjL3NjaGVtYS50c1xudmFyIHNjaGVtYVN5bWJvbCA9IFN5bWJvbC5mb3IoXCJ2ZXJjZWwuYWkuc2NoZW1hXCIpO1xuZnVuY3Rpb24ganNvblNjaGVtYShqc29uU2NoZW1hMiwge1xuICB2YWxpZGF0ZVxufSA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgW3NjaGVtYVN5bWJvbF06IHRydWUsXG4gICAgX3R5cGU6IHZvaWQgMCxcbiAgICAvLyBzaG91bGQgbmV2ZXIgYmUgdXNlZCBkaXJlY3RseVxuICAgIFt2YWxpZGF0b3JTeW1ib2xdOiB0cnVlLFxuICAgIGpzb25TY2hlbWE6IGpzb25TY2hlbWEyLFxuICAgIHZhbGlkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBpc1NjaGVtYSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHNjaGVtYVN5bWJvbCBpbiB2YWx1ZSAmJiB2YWx1ZVtzY2hlbWFTeW1ib2xdID09PSB0cnVlICYmIFwianNvblNjaGVtYVwiIGluIHZhbHVlICYmIFwidmFsaWRhdGVcIiBpbiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFzU2NoZW1hKHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hID09IG51bGwgPyBqc29uU2NoZW1hKHtcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgfSkgOiBpc1NjaGVtYShzY2hlbWEpID8gc2NoZW1hIDogem9kU2NoZW1hKHNjaGVtYSk7XG59XG5cbi8vIHNyYy91aW50OC11dGlscy50c1xudmFyIHsgYnRvYSwgYXRvYiB9ID0gZ2xvYmFsVGhpcztcbmZ1bmN0aW9uIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoYmFzZTY0U3RyaW5nKSB7XG4gIGNvbnN0IGJhc2U2NFVybCA9IGJhc2U2NFN0cmluZy5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgY29uc3QgbGF0aW4xc3RyaW5nID0gYXRvYihiYXNlNjRVcmwpO1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGxhdGluMXN0cmluZywgKGJ5dGUpID0+IGJ5dGUuY29kZVBvaW50QXQoMCkpO1xufVxuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChhcnJheSkge1xuICBsZXQgbGF0aW4xc3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGxhdGluMXN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EobGF0aW4xc3RyaW5nKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0Jhc2U2NCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuLy8gc3JjL3dpdGhvdXQtdHJhaWxpbmctc2xhc2gudHNcbmZ1bmN0aW9uIHdpdGhvdXRUcmFpbGluZ1NsYXNoKHVybCkge1xuICByZXR1cm4gdXJsID09IG51bGwgPyB2b2lkIDAgOiB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJAc3RhbmRhcmQtc2NoZW1hL3NwZWNcIjtcbmV4cG9ydCB7XG4gIGFzU2NoZW1hLFxuICBhc1ZhbGlkYXRvcixcbiAgY29tYmluZUhlYWRlcnMsXG4gIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFRvQmFzZTY0LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0LFxuICBjcmVhdGVCaW5hcnlSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUV2ZW50U291cmNlUGFyc2VyU3RyZWFtLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblN0cmVhbVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlU3RhdHVzQ29kZUVycm9yUmVzcG9uc2VIYW5kbGVyLFxuICBkZWxheSxcbiAgZXh0cmFjdFJlc3BvbnNlSGVhZGVycyxcbiAgZ2VuZXJhdGVJZCxcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBnZXRGcm9tQXBpLFxuICBpc0Fib3J0RXJyb3IsXG4gIGlzUGFyc2FibGVKc29uLFxuICBpc1VybFN1cHBvcnRlZCxcbiAgaXNWYWxpZGF0b3IsXG4gIGpzb25TY2hlbWEsXG4gIGxvYWRBcGlLZXksXG4gIGxvYWRPcHRpb25hbFNldHRpbmcsXG4gIGxvYWRTZXR0aW5nLFxuICBwYXJzZUpTT04sXG4gIHBhcnNlSnNvbkV2ZW50U3RyZWFtLFxuICBwYXJzZVByb3ZpZGVyT3B0aW9ucyxcbiAgcG9zdEZvcm1EYXRhVG9BcGksXG4gIHBvc3RKc29uVG9BcGksXG4gIHBvc3RUb0FwaSxcbiAgcmVtb3ZlVW5kZWZpbmVkRW50cmllcyxcbiAgcmVzb2x2ZSxcbiAgc2FmZVBhcnNlSlNPTixcbiAgc2FmZVZhbGlkYXRlVHlwZXMsXG4gIHN0YW5kYXJkU2NoZW1hVmFsaWRhdG9yLFxuICB2YWxpZGF0ZVR5cGVzLFxuICB2YWxpZGF0b3IsXG4gIHZhbGlkYXRvclN5bWJvbCxcbiAgd2l0aG91dFRyYWlsaW5nU2xhc2gsXG4gIHpvZFNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider/dist/index.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yc2Mvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQyxJQUFJO0FBQ3RELFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLHlDQUF5QyxRQUFRLFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0QsR0FBRztBQUNILFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRCxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVLElBQUksUUFBUTtBQUMvQyxHQUFHO0FBQ0gsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsa0JBQWtCLFNBQVMsZ0JBQWdCLHlCQUF5Qiw4QkFBOEIsdUJBQXVCLHVCQUF1QjtBQUNuTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLGlEQUFpRCxzQkFBc0I7QUFDdkUsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0hBQWdILGNBQWM7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQyxHQUFHO0FBQ0gsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXEFwZXhcXG5vZGVfbW9kdWxlc1xcQGFpLXNka1xccnNjXFxub2RlX21vZHVsZXNcXEBhaS1zZGtcXHByb3ZpZGVyXFxkaXN0XFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9haS1zZGstZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxNCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTE0O1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSkge1xuICAgIGNvbnN0IG1hcmtlclN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xuICAgIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBtYXJrZXJTeW1ib2wgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yW21hcmtlclN5bWJvbF0gPT09IFwiYm9vbGVhblwiICYmIGVycm9yW21hcmtlclN5bWJvbF0gPT09IHRydWU7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcbnZhciBBSVNES0Vycm9yID0gX0FJU0RLRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvYXBpLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvcnMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlLFxuICAgIGFyZ3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1yZXNwb25zZS1kYXRhLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSlNPTlBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNixcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU3ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtc2V0dGluZy1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Mb2FkU2V0dGluZ0Vycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBMb2FkU2V0dGluZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvcnMvbm8tY29udGVudC1nZW5lcmF0ZWQtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gY29udGVudCBnZW5lcmF0ZWQuXCJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBzcmMvZXJyb3JzL25vLXN1Y2gtbW9kZWwtZXJyb3IudHNcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lMTAsXG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogZXJyb3JOYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHZhbGlkYXRpb24gZmFpbGVkOiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHJldHVybiBfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZnVuY3Rpb25hbGl0eSxcbiAgICBtZXNzYWdlID0gYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3QsXG4gIGlzSlNPTlZhbHVlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/rsc/node_modules/ai/dist/index.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@ai-sdk/rsc/node_modules/ai/dist/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   ChatStore: () => (/* binding */ ChatStore),\n/* harmony export */   DefaultChatTransport: () => (/* binding */ DefaultChatTransport),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   JsonToSseTransformStream: () => (/* binding */ JsonToSseTransformStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MCPClientError: () => (/* binding */ MCPClientError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputSpecifiedError: () => (/* binding */ NoOutputSpecifiedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   ToolExecutionError: () => (/* binding */ ToolExecutionError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   appendClientMessage: () => (/* binding */ appendClientMessage),\n/* harmony export */   asSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema),\n/* harmony export */   assistantModelMessageSchema: () => (/* binding */ assistantModelMessageSchema),\n/* harmony export */   callChatApi: () => (/* binding */ callChatApi),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   convertFileListToFileUIParts: () => (/* binding */ convertFileListToFileUIParts),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   convertToModelMessages: () => (/* binding */ convertToModelMessages),\n/* harmony export */   coreAssistantMessageSchema: () => (/* binding */ coreAssistantMessageSchema),\n/* harmony export */   coreMessageSchema: () => (/* binding */ coreMessageSchema),\n/* harmony export */   coreSystemMessageSchema: () => (/* binding */ coreSystemMessageSchema),\n/* harmony export */   coreToolMessageSchema: () => (/* binding */ coreToolMessageSchema),\n/* harmony export */   coreUserMessageSchema: () => (/* binding */ coreUserMessageSchema),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   createTextStreamResponse: () => (/* binding */ createTextStreamResponse),\n/* harmony export */   createUIMessageStream: () => (/* binding */ createUIMessageStream),\n/* harmony export */   createUIMessageStreamResponse: () => (/* binding */ createUIMessageStreamResponse),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultChatStore: () => (/* binding */ defaultChatStore),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createMCPClient: () => (/* binding */ createMCPClient),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   extractMaxToolInvocationStep: () => (/* binding */ extractMaxToolInvocationStep),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   getToolInvocations: () => (/* binding */ getToolInvocations),\n/* harmony export */   hasToolCall: () => (/* binding */ hasToolCall),\n/* harmony export */   isAssistantMessageWithCompletedToolCalls: () => (/* binding */ isAssistantMessageWithCompletedToolCalls),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema),\n/* harmony export */   maxSteps: () => (/* binding */ maxSteps),\n/* harmony export */   modelMessageSchema: () => (/* binding */ modelMessageSchema),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   pipeTextStreamToResponse: () => (/* binding */ pipeTextStreamToResponse),\n/* harmony export */   pipeUIMessageStreamToResponse: () => (/* binding */ pipeUIMessageStreamToResponse),\n/* harmony export */   shouldResubmitMessages: () => (/* binding */ shouldResubmitMessages),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   systemModelMessageSchema: () => (/* binding */ systemModelMessageSchema),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   toolModelMessageSchema: () => (/* binding */ toolModelMessageSchema),\n/* harmony export */   updateToolCallResult: () => (/* binding */ updateToolCallResult),\n/* harmony export */   userModelMessageSchema: () => (/* binding */ userModelMessageSchema),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/trace-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/trace/status.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name17 in all)\n    __defProp(target, name17, { get: all[name17], enumerable: true });\n};\n\n// src/index.ts\n\n\n// src/error/index.ts\n\n\n// src/error/invalid-argument-error.ts\n\nvar name = \"AI_InvalidArgumentError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n};\n_a = symbol;\n\n// src/error/invalid-stream-part-error.ts\n\nvar name2 = \"AI_InvalidStreamPartError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    chunk,\n    message\n  }) {\n    super({ name: name2, message });\n    this[_a2] = true;\n    this.chunk = chunk;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/error/invalid-tool-arguments-error.ts\n\nvar name3 = \"AI_InvalidToolArgumentsError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(\n      cause\n    )}`\n  }) {\n    super({ name: name3, message, cause });\n    this[_a3] = true;\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/error/mcp-client-error.ts\n\nvar name4 = \"AI_MCPClientError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar MCPClientError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    name: name17 = \"MCPClientError\",\n    message,\n    cause\n  }) {\n    super({ name: name17, message, cause });\n    this[_a4] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/error/no-image-generated-error.ts\n\nvar name5 = \"AI_NoImageGeneratedError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No image generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name5, message, cause });\n    this[_a5] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/error/no-object-generated-error.ts\n\nvar name6 = \"AI_NoObjectGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No object generated.\",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name6, message, cause });\n    this[_a6] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/error/no-output-specified-error.ts\n\nvar name7 = \"AI_NoOutputSpecifiedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoOutputSpecifiedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({ message = \"No output specified.\" } = {}) {\n    super({ name: name7, message });\n    this[_a7] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/error/no-such-tool-error.ts\n\nvar name8 = \"AI_NoSuchToolError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name8, message });\n    this[_a8] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/error/tool-call-repair-error.ts\n\nvar name9 = \"AI_ToolCallRepairError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name9, message, cause });\n    this[_a9] = true;\n    this.originalError = originalError;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/error/tool-execution-error.ts\n\nvar name10 = \"AI_ToolExecutionError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar ToolExecutionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolArgs,\n    toolName,\n    toolCallId,\n    cause,\n    message = `Error executing tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name10, message, cause });\n    this[_a10] = true;\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n    this.toolCallId = toolCallId;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name11 = \"AI_InvalidDataContentError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name11, message, cause });\n    this[_a11] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// core/prompt/invalid-message-role-error.ts\n\nvar name12 = \"AI_InvalidMessageRoleError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name12, message });\n    this[_a12] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// core/prompt/message-conversion-error.ts\n\nvar name13 = \"AI_MessageConversionError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name13, message });\n    this[_a13] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker13);\n  }\n};\n_a13 = symbol13;\n\n// src/util/download-error.ts\n\nvar name14 = \"AI_DownloadError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name14, message, cause });\n    this[_a14] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/util/retry-error.ts\n\nvar name15 = \"AI_RetryError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name: name15, message });\n    this[_a15] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker15);\n  }\n};\n_a15 = symbol15;\n\n// src/util/prepare-headers.ts\nfunction prepareHeaders(headers, defaultHeaders) {\n  const responseHeaders = new Headers(headers != null ? headers : {});\n  for (const [key, value] of Object.entries(defaultHeaders)) {\n    if (!responseHeaders.has(key)) {\n      responseHeaders.set(key, value);\n    }\n  }\n  return responseHeaders;\n}\n\n// src/text-stream/create-text-stream-response.ts\nfunction createTextStreamResponse({\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n    status: status != null ? status : 200,\n    statusText,\n    headers: prepareHeaders(headers, {\n      \"content-type\": \"text/plain; charset=utf-8\"\n    })\n  });\n}\n\n// src/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  response.writeHead(status != null ? status : 200, statusText, headers);\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// src/text-stream/pipe-text-stream-to-response.ts\nfunction pipeTextStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, {\n        \"content-type\": \"text/plain; charset=utf-8\"\n      }).entries()\n    ),\n    stream: textStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/ui/append-client-message.ts\nfunction appendClientMessage({\n  messages,\n  message\n}) {\n  return [\n    ...messages.length > 0 && messages[messages.length - 1].id === message.id ? messages.slice(0, -1) : messages,\n    message\n  ];\n}\n\n// src/ui/call-chat-api.ts\n\n\n// src/ui-message-stream/ui-message-stream-parts.ts\n\nvar uiMessageStreamPartSchema = zod__WEBPACK_IMPORTED_MODULE_1__.union([\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"error\"),\n    errorText: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"tool-call-streaming-start\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"tool-call-delta\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    argsTextDelta: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"tool-call\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    args: zod__WEBPACK_IMPORTED_MODULE_1__.unknown()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"tool-result\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    result: zod__WEBPACK_IMPORTED_MODULE_1__.unknown(),\n    providerMetadata: zod__WEBPACK_IMPORTED_MODULE_1__.any().optional()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"reasoning\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    providerMetadata: zod__WEBPACK_IMPORTED_MODULE_1__.record(zod__WEBPACK_IMPORTED_MODULE_1__.any()).optional()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"source\"),\n    sourceType: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"url\"),\n    id: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    url: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    title: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n    providerMetadata: zod__WEBPACK_IMPORTED_MODULE_1__.any().optional()\n    // Use z.any() for generic metadata\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"file\"),\n    url: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    mediaType: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.string().startsWith(\"data-\"),\n    id: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n    data: zod__WEBPACK_IMPORTED_MODULE_1__.unknown()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"metadata\"),\n    value: zod__WEBPACK_IMPORTED_MODULE_1__.object({ metadata: zod__WEBPACK_IMPORTED_MODULE_1__.unknown() })\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"start-step\"),\n    metadata: zod__WEBPACK_IMPORTED_MODULE_1__.unknown().optional()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"finish-step\"),\n    metadata: zod__WEBPACK_IMPORTED_MODULE_1__.unknown().optional()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"start\"),\n    messageId: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n    metadata: zod__WEBPACK_IMPORTED_MODULE_1__.unknown().optional()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"finish\"),\n    metadata: zod__WEBPACK_IMPORTED_MODULE_1__.unknown().optional()\n  }),\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"reasoning-part-finish\")\n  })\n]);\n\n// src/util/consume-stream.ts\nasync function consumeStream({\n  stream,\n  onError\n}) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done)\n        break;\n    }\n  } catch (error) {\n    onError == null ? void 0 : onError(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/ui/process-ui-message-stream.ts\n\n\n// src/util/merge-objects.ts\nfunction mergeObjects(base, overrides) {\n  if (base === void 0 && overrides === void 0) {\n    return void 0;\n  }\n  if (base === void 0) {\n    return overrides;\n  }\n  if (overrides === void 0) {\n    return base;\n  }\n  const result = { ...base };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === void 0)\n        continue;\n      const baseValue = key in base ? base[key] : void 0;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(\n          baseValue,\n          overridesValue\n        );\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\n\n\n// src/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\nasync function parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/ui/extract-max-tool-invocation-step.ts\nfunction extractMaxToolInvocationStep(toolInvocations) {\n  return toolInvocations == null ? void 0 : toolInvocations.reduce((max, toolInvocation) => {\n    var _a17;\n    return Math.max(max, (_a17 = toolInvocation.step) != null ? _a17 : 0);\n  }, 0);\n}\n\n// src/ui/get-tool-invocations.ts\nfunction getToolInvocations(message) {\n  return message.parts.filter(\n    (part) => part.type === \"tool-invocation\"\n  ).map((part) => part.toolInvocation);\n}\n\n// src/ui/process-ui-message-stream.ts\nfunction createStreamingUIMessageState({\n  lastMessage,\n  newMessageId = \"no-id\"\n} = {}) {\n  var _a17;\n  const isContinuation = (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\";\n  const step = isContinuation ? 1 + ((_a17 = extractMaxToolInvocationStep(getToolInvocations(lastMessage))) != null ? _a17 : 0) : 0;\n  const message = isContinuation ? structuredClone(lastMessage) : {\n    id: newMessageId,\n    metadata: {},\n    role: \"assistant\",\n    parts: []\n  };\n  return {\n    message,\n    activeTextPart: void 0,\n    activeReasoningPart: void 0,\n    partialToolCalls: {},\n    step\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  onToolCall,\n  messageMetadataSchema,\n  runUpdateMessageJob\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      async transform(part, controller) {\n        await runUpdateMessageJob(async ({ state, write }) => {\n          function updateToolInvocationPart(toolCallId, invocation) {\n            const part2 = state.message.parts.find(\n              (part3) => part3.type === \"tool-invocation\" && part3.toolInvocation.toolCallId === toolCallId\n            );\n            if (part2 != null) {\n              part2.toolInvocation = invocation;\n            } else {\n              state.message.parts.push({\n                type: \"tool-invocation\",\n                toolInvocation: invocation\n              });\n            }\n          }\n          async function updateMessageMetadata(metadata) {\n            if (metadata != null) {\n              const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n              if (messageMetadataSchema != null) {\n                await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                  value: mergedMetadata,\n                  schema: messageMetadataSchema\n                });\n              }\n              state.message.metadata = mergedMetadata;\n            }\n          }\n          switch (part.type) {\n            case \"text\": {\n              if (state.activeTextPart == null) {\n                state.activeTextPart = {\n                  type: \"text\",\n                  text: part.text\n                };\n                state.message.parts.push(state.activeTextPart);\n              } else {\n                state.activeTextPart.text += part.text;\n              }\n              write();\n              break;\n            }\n            case \"reasoning\": {\n              if (state.activeReasoningPart == null) {\n                state.activeReasoningPart = {\n                  type: \"reasoning\",\n                  text: part.text,\n                  providerMetadata: part.providerMetadata\n                };\n                state.message.parts.push(state.activeReasoningPart);\n              } else {\n                state.activeReasoningPart.text += part.text;\n                state.activeReasoningPart.providerMetadata = part.providerMetadata;\n              }\n              write();\n              break;\n            }\n            case \"reasoning-part-finish\": {\n              if (state.activeReasoningPart != null) {\n                state.activeReasoningPart = void 0;\n              }\n              break;\n            }\n            case \"file\": {\n              state.message.parts.push({\n                type: \"file\",\n                mediaType: part.mediaType,\n                url: part.url\n              });\n              write();\n              break;\n            }\n            case \"source\": {\n              state.message.parts.push({\n                type: \"source\",\n                source: {\n                  sourceType: \"url\",\n                  id: part.id,\n                  url: part.url,\n                  title: part.title,\n                  providerMetadata: part.providerMetadata\n                }\n              });\n              write();\n              break;\n            }\n            case \"tool-call-streaming-start\": {\n              const toolInvocations = getToolInvocations(state.message);\n              state.partialToolCalls[part.toolCallId] = {\n                text: \"\",\n                step: state.step,\n                toolName: part.toolName,\n                index: toolInvocations.length\n              };\n              updateToolInvocationPart(part.toolCallId, {\n                state: \"partial-call\",\n                step: state.step,\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                args: void 0\n              });\n              write();\n              break;\n            }\n            case \"tool-call-delta\": {\n              const partialToolCall = state.partialToolCalls[part.toolCallId];\n              partialToolCall.text += part.argsTextDelta;\n              const { value: partialArgs } = await parsePartialJson(\n                partialToolCall.text\n              );\n              updateToolInvocationPart(part.toolCallId, {\n                state: \"partial-call\",\n                step: partialToolCall.step,\n                toolCallId: part.toolCallId,\n                toolName: partialToolCall.toolName,\n                args: partialArgs\n              });\n              write();\n              break;\n            }\n            case \"tool-call\": {\n              updateToolInvocationPart(part.toolCallId, {\n                state: \"call\",\n                step: state.step,\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                args: part.args\n              });\n              write();\n              if (onToolCall) {\n                const result = await onToolCall({\n                  toolCall: part\n                });\n                if (result != null) {\n                  updateToolInvocationPart(part.toolCallId, {\n                    state: \"result\",\n                    step: state.step,\n                    toolCallId: part.toolCallId,\n                    toolName: part.toolName,\n                    args: part.args,\n                    result\n                  });\n                  write();\n                }\n              }\n              break;\n            }\n            case \"tool-result\": {\n              const toolInvocations = getToolInvocations(state.message);\n              if (toolInvocations == null) {\n                throw new Error(\"tool_result must be preceded by a tool_call\");\n              }\n              const toolInvocationIndex = toolInvocations.findIndex(\n                (invocation) => invocation.toolCallId === part.toolCallId\n              );\n              if (toolInvocationIndex === -1) {\n                throw new Error(\n                  \"tool_result must be preceded by a tool_call with the same toolCallId\"\n                );\n              }\n              updateToolInvocationPart(part.toolCallId, {\n                ...toolInvocations[toolInvocationIndex],\n                state: \"result\",\n                result: part.result\n              });\n              write();\n              break;\n            }\n            case \"start-step\": {\n              state.message.parts.push({ type: \"step-start\" });\n              await updateMessageMetadata(part.metadata);\n              write();\n              break;\n            }\n            case \"finish-step\": {\n              state.step += 1;\n              state.activeTextPart = void 0;\n              state.activeReasoningPart = void 0;\n              await updateMessageMetadata(part.metadata);\n              if (part.metadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"start\": {\n              if (part.messageId != null) {\n                state.message.id = part.messageId;\n              }\n              await updateMessageMetadata(part.metadata);\n              if (part.messageId != null || part.metadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"finish\": {\n              await updateMessageMetadata(part.metadata);\n              if (part.metadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"metadata\": {\n              await updateMessageMetadata(part.metadata);\n              if (part.metadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"error\": {\n              throw new Error(part.errorText);\n            }\n            default: {\n              if (part.type.startsWith(\"data-\")) {\n                const existingPart = part.id != null ? state.message.parts.find(\n                  (partArg) => part.type === partArg.type && part.id === partArg.id\n                ) : void 0;\n                if (existingPart != null) {\n                  existingPart.value = mergeObjects(\n                    existingPart.data,\n                    part.data\n                  );\n                } else {\n                  state.message.parts.push({\n                    type: part.type,\n                    id: part.id,\n                    value: part.data\n                  });\n                }\n                write();\n              }\n            }\n          }\n          controller.enqueue(part);\n        });\n      }\n    })\n  );\n}\n\n// src/ui/transform-text-to-ui-message-stream.ts\nfunction transformTextToUiMessageStream({\n  stream\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      start(controller) {\n        controller.enqueue({ type: \"start\" });\n        controller.enqueue({ type: \"start-step\" });\n      },\n      async transform(part, controller) {\n        controller.enqueue({ type: \"text\", text: part });\n      },\n      async flush(controller) {\n        controller.enqueue({ type: \"finish-step\" });\n        controller.enqueue({ type: \"finish\" });\n      }\n    })\n  );\n}\n\n// src/ui/call-chat-api.ts\nvar getOriginalFetch = () => fetch;\nasync function fetchUIMessageStream({\n  api,\n  body,\n  streamProtocol = \"ui-message\",\n  credentials,\n  headers,\n  abortController,\n  fetch: fetch2 = getOriginalFetch(),\n  requestType = \"generate\"\n}) {\n  var _a17, _b, _c;\n  const response = requestType === \"resume\" ? await fetch2(`${api}?chatId=${body.id}`, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_a17 = abortController == null ? void 0 : abortController()) == null ? void 0 : _a17.signal,\n    credentials\n  }) : await fetch2(api, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_b = abortController == null ? void 0 : abortController()) == null ? void 0 : _b.signal,\n    credentials\n  });\n  if (!response.ok) {\n    throw new Error(\n      (_c = await response.text()) != null ? _c : \"Failed to fetch the chat response.\"\n    );\n  }\n  if (!response.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  return streamProtocol === \"text\" ? transformTextToUiMessageStream({\n    stream: response.body.pipeThrough(new TextDecoderStream())\n  }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n    stream: response.body,\n    schema: uiMessageStreamPartSchema\n  }).pipeThrough(\n    new TransformStream({\n      async transform(part, controller) {\n        if (!part.success) {\n          throw part.error;\n        }\n        controller.enqueue(part.value);\n      }\n    })\n  );\n}\nasync function consumeUIMessageStream({\n  stream,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId: generateId3,\n  lastMessage,\n  messageMetadataSchema\n}) {\n  const state = createStreamingUIMessageState({\n    lastMessage,\n    newMessageId: generateId3()\n  });\n  const runUpdateMessageJob = async (job) => {\n    await job({\n      state,\n      write: () => {\n        onUpdate({ message: state.message });\n      }\n    });\n  };\n  await consumeStream({\n    stream: processUIMessageStream({\n      stream,\n      onToolCall,\n      messageMetadataSchema,\n      runUpdateMessageJob\n    }),\n    onError: (error) => {\n      throw error;\n    }\n  });\n  onFinish == null ? void 0 : onFinish({ message: state.message });\n}\nasync function callChatApi({\n  api,\n  body,\n  streamProtocol = \"ui-message\",\n  credentials,\n  headers,\n  abortController,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId: generateId3,\n  fetch: fetch2 = getOriginalFetch(),\n  lastMessage,\n  requestType = \"generate\",\n  messageMetadataSchema\n}) {\n  const stream = await fetchUIMessageStream({\n    api,\n    body,\n    streamProtocol,\n    credentials,\n    headers,\n    abortController,\n    fetch: fetch2,\n    requestType\n  });\n  await consumeUIMessageStream({\n    stream,\n    onUpdate,\n    onFinish,\n    onToolCall,\n    generateId: generateId3,\n    lastMessage,\n    messageMetadataSchema\n  });\n}\n\n// src/ui/call-completion-api.ts\n\n\n// src/ui/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/ui/call-completion-api.ts\nvar getOriginalFetch2 = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onFinish,\n  onError,\n  fetch: fetch2 = getOriginalFetch2()\n}) {\n  var _a17;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_a17 = await response.text()) != null ? _a17 : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await consumeStream({\n          stream: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n            stream: response.body,\n            schema: uiMessageStreamPartSchema\n          }).pipeThrough(\n            new TransformStream({\n              async transform(part) {\n                if (!part.success) {\n                  throw part.error;\n                }\n                const streamPart = part.value;\n                if (streamPart.type === \"text\") {\n                  result += streamPart.text;\n                  setCompletion(result);\n                } else if (streamPart.type === \"error\") {\n                  throw new Error(streamPart.errorText);\n                }\n              }\n            })\n          ),\n          onError: (error) => {\n            throw error;\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/ui/chat-store.ts\n\n\n// src/util/serial-job-executor.ts\nvar SerialJobExecutor = class {\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n  }\n  async processQueue() {\n    if (this.isProcessing) {\n      return;\n    }\n    this.isProcessing = true;\n    while (this.queue.length > 0) {\n      await this.queue[0]();\n      this.queue.shift();\n    }\n    this.isProcessing = false;\n  }\n  async run(job) {\n    return new Promise((resolve, reject) => {\n      this.queue.push(async () => {\n        try {\n          await job();\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n      void this.processQueue();\n    });\n  }\n};\n\n// src/ui/should-resubmit-messages.ts\nfunction shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps: maxSteps2,\n  messages\n}) {\n  var _a17;\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps2 > 1 && // ensure there is a last message:\n    lastMessage != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount || extractMaxToolInvocationStep(getToolInvocations(lastMessage)) !== originalMaxToolInvocationStep) && // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic steps:\n    ((_a17 = extractMaxToolInvocationStep(getToolInvocations(lastMessage))) != null ? _a17 : 0) < maxSteps2\n  );\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter((part) => part.type === \"tool-invocation\");\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part) => \"result\" in part.toolInvocation);\n}\n\n// src/ui/update-tool-call-result.ts\nfunction updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result\n}) {\n  const lastMessage = messages[messages.length - 1];\n  const invocationPart = lastMessage.parts.find(\n    (part) => part.type === \"tool-invocation\" && part.toolInvocation.toolCallId === toolCallId\n  );\n  if (invocationPart == null) {\n    return;\n  }\n  invocationPart.toolInvocation = {\n    ...invocationPart.toolInvocation,\n    state: \"result\",\n    result\n  };\n}\n\n// src/ui/chat-store.ts\nvar ChatStore = class {\n  constructor({\n    chats = {},\n    generateId: generateId3,\n    messageMetadataSchema,\n    transport,\n    maxSteps: maxSteps2 = 1\n  }) {\n    this.chats = new Map(\n      Object.entries(chats).map(([id, state]) => [\n        id,\n        {\n          messages: [...state.messages],\n          status: \"ready\",\n          activeResponse: void 0,\n          error: void 0,\n          jobExecutor: new SerialJobExecutor()\n        }\n      ])\n    );\n    this.maxSteps = maxSteps2;\n    this.transport = transport;\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.generateId = generateId3 != null ? generateId3 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId;\n    this.messageMetadataSchema = messageMetadataSchema;\n  }\n  hasChat(id) {\n    return this.chats.has(id);\n  }\n  addChat(id, messages) {\n    this.chats.set(id, {\n      messages,\n      status: \"ready\",\n      jobExecutor: new SerialJobExecutor()\n    });\n  }\n  getChats() {\n    return Array.from(this.chats.entries());\n  }\n  get chatCount() {\n    return this.chats.size;\n  }\n  getStatus(id) {\n    return this.getChat(id).status;\n  }\n  setStatus({\n    id,\n    status,\n    error\n  }) {\n    const chat = this.getChat(id);\n    if (chat.status === status)\n      return;\n    chat.status = status;\n    chat.error = error;\n    this.emit({ type: \"chat-status-changed\", chatId: id, error });\n  }\n  getError(id) {\n    return this.getChat(id).error;\n  }\n  getMessages(id) {\n    return this.getChat(id).messages;\n  }\n  getLastMessage(id) {\n    const chat = this.getChat(id);\n    return chat.messages[chat.messages.length - 1];\n  }\n  subscribe(subscriber) {\n    this.subscribers.add(subscriber);\n    return () => this.subscribers.delete(subscriber);\n  }\n  setMessages({\n    id,\n    messages\n  }) {\n    this.getChat(id).messages = [...messages];\n    this.emit({ type: \"chat-messages-changed\", chatId: id });\n  }\n  removeAssistantResponse(id) {\n    const chat = this.getChat(id);\n    const lastMessage = chat.messages[chat.messages.length - 1];\n    if (lastMessage == null) {\n      throw new Error(\"Cannot remove assistant response from empty chat\");\n    }\n    if (lastMessage.role !== \"assistant\") {\n      throw new Error(\"Last message is not an assistant message\");\n    }\n    this.setMessages({ id, messages: chat.messages.slice(0, -1) });\n  }\n  async submitMessage({\n    chatId,\n    message,\n    headers,\n    body,\n    onError,\n    onToolCall,\n    onFinish\n  }) {\n    var _a17;\n    const chat = this.getChat(chatId);\n    const currentMessages = chat.messages;\n    await this.triggerRequest({\n      chatId,\n      messages: currentMessages.concat({\n        ...message,\n        id: (_a17 = message.id) != null ? _a17 : this.generateId()\n      }),\n      headers,\n      body,\n      requestType: \"generate\",\n      onError,\n      onToolCall,\n      onFinish\n    });\n  }\n  async resubmitLastUserMessage({\n    chatId,\n    headers,\n    body,\n    onError,\n    onToolCall,\n    onFinish\n  }) {\n    const messages = this.getChat(chatId).messages;\n    const messagesToSubmit = messages[messages.length - 1].role === \"assistant\" ? messages.slice(0, -1) : messages;\n    if (messagesToSubmit.length === 0) {\n      return;\n    }\n    return this.triggerRequest({\n      chatId,\n      requestType: \"generate\",\n      messages: messagesToSubmit,\n      headers,\n      body,\n      onError,\n      onToolCall,\n      onFinish\n    });\n  }\n  async resumeStream({\n    chatId,\n    headers,\n    body,\n    onError,\n    onToolCall,\n    onFinish\n  }) {\n    const chat = this.getChat(chatId);\n    const currentMessages = chat.messages;\n    return this.triggerRequest({\n      chatId,\n      messages: currentMessages,\n      requestType: \"resume\",\n      headers,\n      body,\n      onError,\n      onToolCall,\n      onFinish\n    });\n  }\n  async addToolResult({\n    chatId,\n    toolCallId,\n    result\n  }) {\n    const chat = this.getChat(chatId);\n    chat.jobExecutor.run(async () => {\n      const currentMessages = chat.messages;\n      updateToolCallResult({\n        messages: currentMessages,\n        toolCallId,\n        toolResult: result\n      });\n      this.setMessages({ id: chatId, messages: currentMessages });\n      if (chat.status === \"submitted\" || chat.status === \"streaming\") {\n        return;\n      }\n      const lastMessage = currentMessages[currentMessages.length - 1];\n      if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {\n        await this.triggerRequest({\n          messages: currentMessages,\n          requestType: \"generate\",\n          chatId\n        });\n      }\n    });\n  }\n  async stopStream({ chatId }) {\n    var _a17;\n    const chat = this.getChat(chatId);\n    if (chat.status !== \"streaming\" && chat.status !== \"submitted\")\n      return;\n    if ((_a17 = chat.activeResponse) == null ? void 0 : _a17.abortController) {\n      chat.activeResponse.abortController.abort();\n      chat.activeResponse.abortController = void 0;\n    }\n  }\n  emit(event) {\n    for (const subscriber of this.subscribers) {\n      subscriber.onChatChanged(event);\n    }\n  }\n  getChat(id) {\n    if (!this.hasChat(id)) {\n      throw new Error(`chat '${id}' not found`);\n    }\n    return this.chats.get(id);\n  }\n  async triggerRequest({\n    chatId,\n    messages: chatMessages,\n    requestType,\n    headers,\n    body,\n    onError,\n    onToolCall,\n    onFinish\n  }) {\n    const self = this;\n    const chat = this.getChat(chatId);\n    this.setMessages({ id: chatId, messages: chatMessages });\n    this.setStatus({ id: chatId, status: \"submitted\", error: void 0 });\n    const messageCount = chatMessages.length;\n    const maxStep = extractMaxToolInvocationStep(\n      getToolInvocations(chatMessages[chatMessages.length - 1])\n    );\n    try {\n      const activeResponse = {\n        state: createStreamingUIMessageState({\n          lastMessage: chatMessages[chatMessages.length - 1],\n          newMessageId: self.generateId()\n        }),\n        abortController: new AbortController()\n      };\n      chat.activeResponse = activeResponse;\n      const stream = await self.transport.submitMessages({\n        chatId,\n        messages: chatMessages,\n        body,\n        headers,\n        abortController: activeResponse.abortController,\n        requestType\n      });\n      const runUpdateMessageJob = (job) => (\n        // serialize the job execution to avoid race conditions:\n        chat.jobExecutor.run(\n          () => job({\n            state: activeResponse.state,\n            write: () => {\n              self.setStatus({ id: chatId, status: \"streaming\" });\n              const replaceLastMessage = activeResponse.state.message.id === chatMessages[chatMessages.length - 1].id;\n              const newMessages = [\n                ...replaceLastMessage ? chatMessages.slice(0, chatMessages.length - 1) : chatMessages,\n                activeResponse.state.message\n              ];\n              self.setMessages({\n                id: chatId,\n                messages: newMessages\n              });\n            }\n          })\n        )\n      );\n      await consumeStream({\n        stream: processUIMessageStream({\n          stream,\n          onToolCall,\n          messageMetadataSchema: self.messageMetadataSchema,\n          runUpdateMessageJob\n        }),\n        onError: (error) => {\n          throw error;\n        }\n      });\n      onFinish == null ? void 0 : onFinish({ message: activeResponse.state.message });\n      this.setStatus({ id: chatId, status: \"ready\" });\n    } catch (err) {\n      if (err.name === \"AbortError\") {\n        this.setStatus({ id: chatId, status: \"ready\" });\n        return null;\n      }\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n      this.setStatus({ id: chatId, status: \"error\", error: err });\n    } finally {\n      chat.activeResponse = void 0;\n    }\n    const currentMessages = self.getMessages(chatId);\n    if (shouldResubmitMessages({\n      originalMaxToolInvocationStep: maxStep,\n      originalMessageCount: messageCount,\n      maxSteps: self.maxSteps,\n      messages: currentMessages\n    })) {\n      await self.triggerRequest({\n        chatId,\n        requestType,\n        onError,\n        onToolCall,\n        onFinish,\n        headers,\n        body,\n        messages: currentMessages\n      });\n    }\n  }\n};\n\n// src/ui/chat-transport.ts\nvar DefaultChatTransport = class {\n  constructor({\n    api,\n    credentials,\n    headers,\n    body,\n    streamProtocol,\n    fetch: fetch2,\n    prepareRequestBody\n  }) {\n    this.api = api;\n    this.credentials = credentials;\n    this.headers = headers;\n    this.body = body;\n    this.streamProtocol = streamProtocol;\n    this.fetch = fetch2;\n    this.prepareRequestBody = prepareRequestBody;\n  }\n  submitMessages({\n    chatId,\n    messages,\n    abortController,\n    body,\n    headers,\n    requestType\n  }) {\n    var _a17, _b;\n    return fetchUIMessageStream({\n      api: this.api,\n      headers: {\n        ...this.headers,\n        ...headers\n      },\n      body: (_b = (_a17 = this.prepareRequestBody) == null ? void 0 : _a17.call(this, {\n        id: chatId,\n        // TODO change to chatId\n        messages,\n        ...this.body,\n        ...body\n      })) != null ? _b : {\n        id: chatId,\n        // TODO change to chatId\n        messages,\n        ...this.body,\n        ...body\n      },\n      streamProtocol: this.streamProtocol,\n      credentials: this.credentials,\n      abortController: () => abortController,\n      fetch: this.fetch,\n      requestType\n    });\n  }\n};\n\n// src/ui/convert-file-list-to-file-ui-parts.ts\nasync function convertFileListToFileUIParts(files) {\n  if (files == null) {\n    return [];\n  }\n  if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n    throw new Error(\"FileList is not supported in the current environment\");\n  }\n  return Promise.all(\n    Array.from(files).map(async (file) => {\n      const { name: name17, type } = file;\n      const dataUrl = await new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (readerEvent) => {\n          var _a17;\n          resolve((_a17 = readerEvent.target) == null ? void 0 : _a17.result);\n        };\n        reader.onerror = (error) => reject(error);\n        reader.readAsDataURL(file);\n      });\n      return {\n        type: \"file\",\n        mediaType: type,\n        filename: name17,\n        url: dataUrl\n      };\n    })\n  );\n}\n\n// src/ui/convert-to-model-messages.ts\nfunction convertToModelMessages(messages, options) {\n  var _a17, _b;\n  const tools = (_a17 = options == null ? void 0 : options.tools) != null ? _a17 : {};\n  const modelMessages = [];\n  for (const message of messages) {\n    switch (message.role) {\n      case \"system\": {\n        modelMessages.push({\n          role: \"system\",\n          content: message.parts.map((part) => part.type === \"text\" ? part.text : \"\").join(\"\")\n        });\n        break;\n      }\n      case \"user\": {\n        modelMessages.push({\n          role: \"user\",\n          content: message.parts.filter(\n            (part) => part.type === \"text\" || part.type === \"file\"\n          ).map(\n            (part) => part.type === \"file\" ? {\n              type: \"file\",\n              mediaType: part.mediaType,\n              filename: part.filename,\n              data: part.url\n            } : part\n          )\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (message.parts != null) {\n          let processBlock2 = function() {\n            const content = [];\n            for (const part of block) {\n              switch (part.type) {\n                case \"text\": {\n                  content.push(part);\n                  break;\n                }\n                case \"file\": {\n                  content.push({\n                    type: \"file\",\n                    mediaType: part.mediaType,\n                    data: part.url\n                  });\n                  break;\n                }\n                case \"reasoning\": {\n                  content.push({\n                    type: \"reasoning\",\n                    text: part.text,\n                    providerOptions: part.providerMetadata\n                  });\n                  break;\n                }\n                case \"tool-invocation\":\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolInvocation.toolCallId,\n                    toolName: part.toolInvocation.toolName,\n                    args: part.toolInvocation.args\n                  });\n                  break;\n                default: {\n                  const _exhaustiveCheck = part;\n                  throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                }\n              }\n            }\n            modelMessages.push({\n              role: \"assistant\",\n              content\n            });\n            const stepInvocations = block.filter(\n              (part) => part.type === \"tool-invocation\"\n            ).map((part) => part.toolInvocation);\n            if (stepInvocations.length > 0) {\n              modelMessages.push({\n                role: \"tool\",\n                content: stepInvocations.map(\n                  (toolInvocation) => {\n                    if (!(\"result\" in toolInvocation)) {\n                      throw new MessageConversionError({\n                        originalMessage: message,\n                        message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                      });\n                    }\n                    const { toolCallId, toolName, result } = toolInvocation;\n                    const tool2 = tools[toolName];\n                    return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                      type: \"tool-result\",\n                      toolCallId,\n                      toolName,\n                      result: tool2.experimental_toToolResultContent(result),\n                      experimental_content: tool2.experimental_toToolResultContent(result)\n                    } : {\n                      type: \"tool-result\",\n                      toolCallId,\n                      toolName,\n                      result\n                    };\n                  }\n                )\n              });\n            }\n            block = [];\n            blockHasToolInvocations = false;\n            currentStep++;\n          };\n          var processBlock = processBlock2;\n          let currentStep = 0;\n          let blockHasToolInvocations = false;\n          let block = [];\n          for (const part of message.parts) {\n            switch (part.type) {\n              case \"text\": {\n                if (blockHasToolInvocations) {\n                  processBlock2();\n                }\n                block.push(part);\n                break;\n              }\n              case \"file\":\n              case \"reasoning\": {\n                block.push(part);\n                break;\n              }\n              case \"tool-invocation\": {\n                if (((_b = part.toolInvocation.step) != null ? _b : 0) !== currentStep) {\n                  processBlock2();\n                }\n                block.push(part);\n                blockHasToolInvocations = true;\n                break;\n              }\n            }\n          }\n          processBlock2();\n          break;\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return modelMessages;\n}\nvar convertToCoreMessages = convertToModelMessages;\n\n// src/ui/default-chat-store.ts\n\nfunction defaultChatStore({\n  api,\n  fetch: fetch2,\n  streamProtocol = \"ui-message\",\n  credentials,\n  headers,\n  body,\n  prepareRequestBody,\n  generateId: generateId3 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId,\n  messageMetadataSchema,\n  maxSteps: maxSteps2 = 1,\n  chats\n}) {\n  return new ChatStore({\n    transport: new DefaultChatTransport({\n      api,\n      fetch: fetch2,\n      streamProtocol,\n      credentials,\n      headers,\n      body,\n      prepareRequestBody\n    }),\n    generateId: generateId3,\n    messageMetadataSchema,\n    maxSteps: maxSteps2,\n    chats\n  });\n}\n\n// src/ui-message-stream/create-ui-message-stream.ts\nfunction createUIMessageStream({\n  execute,\n  onError = () => \"An error occurred.\"\n  // mask error messages for safety by default\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n    }\n  }\n  try {\n    const result = execute({\n      write(part) {\n        safeEnqueue(part);\n      },\n      merge(streamArg) {\n        ongoingStreamPromises.push(\n          (async () => {\n            const reader = streamArg.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done)\n                break;\n              safeEnqueue(value);\n            }\n          })().catch((error) => {\n            safeEnqueue({ type: \"error\", errorText: onError(error) });\n          })\n        );\n      },\n      onError\n    });\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch((error) => {\n          safeEnqueue({ type: \"error\", errorText: onError(error) });\n        })\n      );\n    }\n  } catch (error) {\n    safeEnqueue({ type: \"error\", errorText: onError(error) });\n  }\n  const waitForStreams = new Promise(async (resolve) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n    }\n  });\n  return stream;\n}\n\n// src/ui-message-stream/ui-message-stream-headers.ts\nvar uiMessageStreamHeaders = {\n  \"content-type\": \"text/event-stream\",\n  \"cache-control\": \"no-cache\",\n  connection: \"keep-alive\",\n  \"x-vercel-ai-ui-message-stream\": \"v1\",\n  \"x-accel-buffering\": \"no\"\n  // disable nginx buffering\n};\n\n// src/ui-message-stream/json-to-sse-transform-stream.ts\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(\"data: [DONE]\\n\\n\");\n      }\n    });\n  }\n};\n\n// src/ui-message-stream/create-ui-message-stream-response.ts\nfunction createUIMessageStreamResponse({\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  return new Response(\n    stream.pipeThrough(new JsonToSseTransformStream()).pipeThrough(new TextEncoderStream()),\n    {\n      status,\n      statusText,\n      headers: prepareHeaders(headers, uiMessageStreamHeaders)\n    }\n  );\n}\n\n// src/ui-message-stream/pipe-ui-message-stream-to-response.ts\nfunction pipeUIMessageStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, uiMessageStreamHeaders).entries()\n    ),\n    stream: stream.pipeThrough(new JsonToSseTransformStream()).pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/util/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mediaType = header.split(\";\")[0].split(\":\")[1];\n  if (mediaType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: \"vector1,vector2\",\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`\n    });\n  }\n  const n = vector1.length;\n  if (n === 0) {\n    return 0;\n  }\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n\n// src/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal\n}) {\n  var _a17;\n  const delay2 = (_a17 = _internal == null ? void 0 : _internal.delay) != null ? _a17 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n  let index = 0;\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    }\n  });\n}\n\n// src/util/retry-with-exponential-backoff.ts\n\n\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// src/util/prepare-retries.ts\nfunction prepareRetries({\n  maxRetries\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult })\n  };\n}\n\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a17;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// core/telemetry/get-tracer.ts\n\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name17, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// core/telemetry/get-tracer.ts\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_3__.trace.getTracer(\"ai\");\n}\n\n// core/telemetry/record-span.ts\n\nfunction recordSpan({\n  name: name17,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name17, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          });\n          span.setStatus({\n            code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.SpanStatusCode.ERROR,\n            message: error.message\n          });\n        } else {\n          span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.SpanStatusCode.ERROR });\n        }\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\n\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n    return {};\n  }\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value === void 0) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// core/embed/embed.ts\nasync function embed({\n  model,\n  value,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const { embedding, usage, response } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a17;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers,\n                providerOptions\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                response: modelResponse.response\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({\n        value,\n        embedding,\n        usage,\n        response\n      });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.response = options.response;\n  }\n};\n\n// src/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// core/embed/embed-many.ts\nasync function embedMany({\n  model,\n  values,\n  maxParallelCalls = Infinity,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry\n}) {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n        model.maxEmbeddingsPerCall,\n        model.supportsParallelCalls\n      ]);\n      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n        const { embeddings: embeddings2, usage, response } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => values.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a17;\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers,\n                providerOptions\n              });\n              const embeddings3 = modelResponse.embeddings;\n              const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings3.map((embedding) => JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embeddings: embeddings3,\n                usage: usage2,\n                response: modelResponse.response\n              };\n            }\n          });\n        });\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({\n          values,\n          embeddings: embeddings2,\n          usage,\n          responses: [response]\n        });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      const responses = [];\n      let tokens = 0;\n      const parallelChunks = splitArray(\n        valueChunks,\n        supportsParallelCalls ? maxParallelCalls : 1\n      );\n      for (const parallelChunk of parallelChunks) {\n        const results = await Promise.all(\n          parallelChunk.map((chunk) => {\n            return retry(() => {\n              return recordSpan({\n                name: \"ai.embedMany.doEmbed\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.embedMany.doEmbed\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.values\": {\n                      input: () => chunk.map((value) => JSON.stringify(value))\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (doEmbedSpan) => {\n                  var _a17;\n                  const modelResponse = await model.doEmbed({\n                    values: chunk,\n                    abortSignal,\n                    headers,\n                    providerOptions\n                  });\n                  const embeddings2 = modelResponse.embeddings;\n                  const usage = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n                  doEmbedSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.embeddings\": {\n                          output: () => embeddings2.map(\n                            (embedding) => JSON.stringify(embedding)\n                          )\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                      }\n                    })\n                  );\n                  return {\n                    embeddings: embeddings2,\n                    usage,\n                    response: modelResponse.response\n                  };\n                }\n              });\n            });\n          })\n        );\n        for (const result of results) {\n          embeddings.push(...result.embeddings);\n          responses.push(result.response);\n          tokens += result.usage.tokens;\n        }\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n        responses\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n    this.responses = options.responses;\n  }\n};\n\n// src/util/detect-media-type.ts\n\nvar imageMediaTypeSignatures = [\n  {\n    mediaType: \"image/gif\",\n    bytesPrefix: [71, 73, 70],\n    base64Prefix: \"R0lG\"\n  },\n  {\n    mediaType: \"image/png\",\n    bytesPrefix: [137, 80, 78, 71],\n    base64Prefix: \"iVBORw\"\n  },\n  {\n    mediaType: \"image/jpeg\",\n    bytesPrefix: [255, 216],\n    base64Prefix: \"/9j/\"\n  },\n  {\n    mediaType: \"image/webp\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGRg\"\n  },\n  {\n    mediaType: \"image/bmp\",\n    bytesPrefix: [66, 77],\n    base64Prefix: \"Qk\"\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [73, 73, 42, 0],\n    base64Prefix: \"SUkqAA\"\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [77, 77, 0, 42],\n    base64Prefix: \"TU0AKg\"\n  },\n  {\n    mediaType: \"image/avif\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      97,\n      118,\n      105,\n      102\n    ],\n    base64Prefix: \"AAAAIGZ0eXBhdmlm\"\n  },\n  {\n    mediaType: \"image/heic\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      104,\n      101,\n      105,\n      99\n    ],\n    base64Prefix: \"AAAAIGZ0eXBoZWlj\"\n  }\n];\nvar audioMediaTypeSignatures = [\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 251],\n    base64Prefix: \"//s=\"\n  },\n  {\n    mediaType: \"audio/wav\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGR\"\n  },\n  {\n    mediaType: \"audio/ogg\",\n    bytesPrefix: [79, 103, 103, 83],\n    base64Prefix: \"T2dnUw\"\n  },\n  {\n    mediaType: \"audio/flac\",\n    bytesPrefix: [102, 76, 97, 67],\n    base64Prefix: \"ZkxhQw\"\n  },\n  {\n    mediaType: \"audio/aac\",\n    bytesPrefix: [64, 21, 0, 0],\n    base64Prefix: \"QBUA\"\n  },\n  {\n    mediaType: \"audio/mp4\",\n    bytesPrefix: [102, 116, 121, 112],\n    base64Prefix: \"ZnR5cA\"\n  }\n];\nvar stripID3 = (data) => {\n  const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n  data[1] === 68 && // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  for (const signature of signatures) {\n    if (typeof processedData === \"string\" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(\n      (byte, index) => processedData[index] === byte\n    )) {\n      return signature.mediaType;\n    }\n  }\n  return void 0;\n}\n\n// core/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n  constructor({\n    data,\n    mediaType\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? void 0 : data;\n    this.uint8ArrayData = isUint8Array ? data : void 0;\n    this.mediaType = mediaType;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n    }\n    return this.base64Data;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n    }\n    return this.uint8ArrayData;\n  }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n  constructor(options) {\n    super(options);\n    this.type = \"file\";\n  }\n};\n\n// core/generate-image/generate-image.ts\nasync function generateImage({\n  model,\n  prompt,\n  n = 1,\n  maxImagesPerCall,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a17, _b;\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const maxImagesPerCallWithDefault = (_a17 = maxImagesPerCall != null ? maxImagesPerCall : model.maxImagesPerCall) != null ? _a17 : 1;\n  const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCallWithDefault;\n    }\n    const remainder = n % maxImagesPerCallWithDefault;\n    return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(\n      async (callImageCount) => retry(\n        () => model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions != null ? providerOptions : {}\n        })\n      )\n    )\n  );\n  const images = [];\n  const warnings = [];\n  const responses = [];\n  const providerMetadata = {};\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        (image) => {\n          var _a18;\n          return new DefaultGeneratedFile({\n            data: image,\n            mediaType: (_a18 = detectMediaType({\n              data: image,\n              signatures: imageMediaTypeSignatures\n            })) != null ? _a18 : \"image/png\"\n          });\n        }\n      )\n    );\n    warnings.push(...result.warnings);\n    if (result.providerMetadata) {\n      for (const [providerName, metadata] of Object.entries(result.providerMetadata)) {\n        (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = { images: [] };\n        providerMetadata[providerName].images.push(\n          ...result.providerMetadata[providerName].images\n        );\n      }\n    }\n    responses.push(result.response);\n  }\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n  return new DefaultGenerateImageResult({\n    images,\n    warnings,\n    responses,\n    providerMetadata\n  });\n}\nvar DefaultGenerateImageResult = class {\n  constructor(options) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata;\n  }\n  get image() {\n    return this.images[0];\n  }\n};\n\n// core/generate-object/generate-object.ts\n\n\n\n// core/generate-text/extract-content-text.ts\nfunction extractContentText(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"text\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((content2) => content2.text).join(\"\");\n}\n\n// core/prompt/convert-to-language-model-prompt.ts\n\n\n// src/util/download.ts\nasync function download({ url }) {\n  var _a17;\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: (_a17 = response.headers.get(\"content-type\")) != null ? _a17 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n\n// core/prompt/data-content.ts\n\n\n\n\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mediaType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mediaType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// core/prompt/data-content.ts\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_1__.union([\n  zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  zod__WEBPACK_IMPORTED_MODULE_1__[\"instanceof\"](Uint8Array),\n  zod__WEBPACK_IMPORTED_MODULE_1__[\"instanceof\"](ArrayBuffer),\n  zod__WEBPACK_IMPORTED_MODULE_1__.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a17, _b;\n      return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertToLanguageModelV2DataContent(content) {\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: void 0 };\n  }\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: void 0 };\n  }\n  if (typeof content === \"string\") {\n    try {\n      content = new URL(content);\n    } catch (error) {\n    }\n  }\n  if (content instanceof URL && content.protocol === \"data:\") {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString()\n    );\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n        name: \"InvalidDataContentError\",\n        message: `Invalid data URL format in content ${content.toString()}`\n      });\n    }\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n  return { data: content, mediaType: void 0 };\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\n\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  downloadImplementation = download\n}) {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    downloadImplementation,\n    supportedUrls\n  );\n  return [\n    ...prompt.system != null ? [{ role: \"system\", content: prompt.system }] : [],\n    ...prompt.messages.map(\n      (message) => convertToLanguageModelMessage(message, downloadedAssets)\n    )\n  ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        ).map((part) => {\n          const providerOptions = part.providerOptions;\n          switch (part.type) {\n            case \"file\": {\n              const { data, mediaType } = convertToLanguageModelV2DataContent(\n                part.data\n              );\n              return {\n                type: \"file\",\n                data,\n                filename: part.filename,\n                mediaType: mediaType != null ? mediaType : part.mediaType,\n                providerOptions\n              };\n            }\n            case \"reasoning\": {\n              return {\n                type: \"reasoning\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"tool-call\": {\n              return {\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                args: part.args,\n                providerOptions\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => ({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          content: part.experimental_content,\n          isError: part.isError,\n          providerOptions: part.providerOptions\n        })),\n        providerOptions: message.providerOptions\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, downloadImplementation, supportedUrls) {\n  const urls = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).map((part) => {\n    var _a17;\n    const mediaType = (_a17 = part.mediaType) != null ? _a17 : part.type === \"image\" ? \"image/*\" : void 0;\n    let data = part.type === \"image\" ? part.image : part.data;\n    if (typeof data === \"string\") {\n      try {\n        data = new URL(data);\n      } catch (ignored) {\n      }\n    }\n    return { mediaType, data };\n  }).filter(\n    (part) => part.data instanceof URL && part.mediaType != null && !(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isUrlSupported)({\n      url: part.data.toString(),\n      mediaType: part.mediaType,\n      supportedUrls\n    })\n  ).map((part) => part.data);\n  const downloadedImages = await Promise.all(\n    urls.map(async (url) => ({\n      url,\n      data: await downloadImplementation({ url })\n    }))\n  );\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data])\n  );\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a17, _b;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerOptions: part.providerOptions\n    };\n  }\n  let originalData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      originalData = part.image;\n      break;\n    case \"file\":\n      originalData = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);\n  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n  let data = convertedData;\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType = (_a17 = downloadedFile.mediaType) != null ? _a17 : mediaType;\n    }\n  }\n  switch (type) {\n    case \"image\": {\n      if (data instanceof Uint8Array || typeof data === \"string\") {\n        mediaType = (_b = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _b : mediaType;\n      }\n      return {\n        type: \"file\",\n        mediaType: mediaType != null ? mediaType : \"image/*\",\n        // any image\n        filename: void 0,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n    case \"file\": {\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n      return {\n        type: \"file\",\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n  }\n}\n\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences\n}) {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be an integer\"\n      });\n    }\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed\n  };\n}\n\n// core/prompt/standardize-prompt.ts\n\n\n\n\n// core/prompt/message.ts\n\n\n// core/types/provider-metadata.ts\n\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_1__.lazy(\n  () => zod__WEBPACK_IMPORTED_MODULE_1__.union([\n    zod__WEBPACK_IMPORTED_MODULE_1__[\"null\"](),\n    zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    zod__WEBPACK_IMPORTED_MODULE_1__.number(),\n    zod__WEBPACK_IMPORTED_MODULE_1__.boolean(),\n    zod__WEBPACK_IMPORTED_MODULE_1__.record(zod__WEBPACK_IMPORTED_MODULE_1__.string(), jsonValueSchema),\n    zod__WEBPACK_IMPORTED_MODULE_1__.array(jsonValueSchema)\n  ])\n);\n\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_1__.record(\n  zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  zod__WEBPACK_IMPORTED_MODULE_1__.record(zod__WEBPACK_IMPORTED_MODULE_1__.string(), jsonValueSchema)\n);\n\n// core/prompt/content-part.ts\n\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_1__.array(\n  zod__WEBPACK_IMPORTED_MODULE_1__.union([\n    zod__WEBPACK_IMPORTED_MODULE_1__.object({ type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"text\"), text: zod__WEBPACK_IMPORTED_MODULE_1__.string() }),\n    zod__WEBPACK_IMPORTED_MODULE_1__.object({\n      type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"image\"),\n      data: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n      mediaType: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n    })\n  ])\n);\n\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"text\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"image\"),\n  image: zod__WEBPACK_IMPORTED_MODULE_1__.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_1__[\"instanceof\"](URL)]),\n  mediaType: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"file\"),\n  data: zod__WEBPACK_IMPORTED_MODULE_1__.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_1__[\"instanceof\"](URL)]),\n  filename: zod__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n  mediaType: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"reasoning\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"tool-call\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  args: zod__WEBPACK_IMPORTED_MODULE_1__.unknown(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"tool-result\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  result: zod__WEBPACK_IMPORTED_MODULE_1__.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: zod__WEBPACK_IMPORTED_MODULE_1__.boolean().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\n\n// core/prompt/message.ts\nvar systemModelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object(\n  {\n    role: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    providerOptions: providerMetadataSchema.optional()\n  }\n);\nvar coreSystemMessageSchema = systemModelMessageSchema;\nvar userModelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"user\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_1__.union([\n    zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    zod__WEBPACK_IMPORTED_MODULE_1__.array(zod__WEBPACK_IMPORTED_MODULE_1__.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = userModelMessageSchema;\nvar assistantModelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"assistant\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_1__.union([\n    zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    zod__WEBPACK_IMPORTED_MODULE_1__.array(\n      zod__WEBPACK_IMPORTED_MODULE_1__.union([\n        textPartSchema,\n        filePartSchema,\n        reasoningPartSchema,\n        toolCallPartSchema\n      ])\n    )\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = assistantModelMessageSchema;\nvar toolModelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"tool\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_1__.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = toolModelMessageSchema;\nvar modelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_1__.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\nvar coreMessageSchema = modelMessageSchema;\n\n// core/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  let messages;\n  if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n    messages = [{ role: \"user\", content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (messages.length === 0) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"messages must not be empty\"\n    });\n  }\n  const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n    value: messages,\n    schema: zod__WEBPACK_IMPORTED_MODULE_1__.array(modelMessageSchema)\n  });\n  if (!validationResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.\",\n      cause: validationResult.error\n    });\n  }\n  return {\n    messages,\n    system: prompt.system\n  };\n}\n\n// core/generate-object/output-strategy.ts\n\n\n\n// src/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n  const stream = source.pipeThrough(new TransformStream());\n  stream[Symbol.asyncIterator] = () => {\n    const reader = stream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return stream;\n}\n\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: void 0,\n  async validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  async validateFinalResult(value, context) {\n    return value === void 0 ? {\n      success: false,\n      error: new NoObjectGeneratedError({\n        message: \"No object generated: response did not match schema.\",\n        text: context.text,\n        response: context.response,\n        usage: context.usage,\n        finishReason: context.finishReason\n      })\n    } : { success: true, value };\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: schema.jsonSchema,\n  async validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  async validateFinalResult(value) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value, schema });\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n  return {\n    type: \"enum\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        elements: { type: \"array\", items: itemSchema }\n      },\n      required: [\"elements\"],\n      additionalProperties: false\n    },\n    async validatePartialResult({\n      value,\n      latestObject,\n      isFirstDelta,\n      isFinalDelta\n    }) {\n      var _a17;\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"object\": {\n                  const array = chunk.object;\n                  for (; publishedElements < array.length; publishedElements++) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n                  break;\n                }\n                case \"text-delta\":\n                case \"finish\":\n                case \"error\":\n                  break;\n                default: {\n                  const _exhaustiveCheck = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`\n                  );\n                }\n              }\n            }\n          })\n        )\n      );\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    },\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    async validatePartialResult({ value, textDelta }) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      const possibleEnumValues = enumValues.filter(\n        (enumValue) => enumValue.startsWith(result)\n      );\n      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be a string in the enum\"\n          })\n        };\n      }\n      return {\n        success: true,\n        value: {\n          partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n          textDelta\n        }\n      };\n    },\n    createElementStream() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"array\":\n      return arrayOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nasync function generateObject(options) {\n  const {\n    model,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    providerOptions,\n    _internal: {\n      generateId: generateId3 = originalGenerateId,\n      currentDate = () => /* @__PURE__ */ new Date()\n    } = {},\n    ...settings\n  } = options;\n  const enumValues = \"enum\" in options ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  const callSettings = prepareCallSettings(settings);\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...callSettings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.generateObject\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.generateObject\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        },\n        \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n        \"ai.schema.name\": schemaName,\n        \"ai.schema.description\": schemaDescription,\n        \"ai.settings.output\": outputStrategy.type\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a17;\n      let result;\n      let finishReason;\n      let usage;\n      let warnings;\n      let response;\n      let request;\n      let resultProviderMetadata;\n      const standardizedPrompt = await standardizePrompt({\n        system,\n        prompt,\n        messages\n      });\n      const promptMessages = await convertToLanguageModelPrompt({\n        prompt: standardizedPrompt,\n        supportedUrls: await model.supportedUrls\n      });\n      const generateResult = await retry(\n        () => recordSpan({\n          name: \"ai.generateObject.doGenerate\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: \"ai.generateObject.doGenerate\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              \"ai.prompt.messages\": {\n                input: () => JSON.stringify(promptMessages)\n              },\n              // standardized gen-ai llm span attributes:\n              \"gen_ai.system\": model.provider,\n              \"gen_ai.request.model\": model.modelId,\n              \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n              \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n              \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n              \"gen_ai.request.temperature\": callSettings.temperature,\n              \"gen_ai.request.top_k\": callSettings.topK,\n              \"gen_ai.request.top_p\": callSettings.topP\n            }\n          }),\n          tracer,\n          fn: async (span2) => {\n            var _a18, _b, _c, _d, _e, _f, _g, _h;\n            const result2 = await model.doGenerate({\n              responseFormat: {\n                type: \"json\",\n                schema: outputStrategy.jsonSchema,\n                name: schemaName,\n                description: schemaDescription\n              },\n              ...prepareCallSettings(settings),\n              prompt: promptMessages,\n              providerOptions,\n              abortSignal,\n              headers\n            });\n            const responseData = {\n              id: (_b = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b : generateId3(),\n              timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n              modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n              headers: (_g = result2.response) == null ? void 0 : _g.headers,\n              body: (_h = result2.response) == null ? void 0 : _h.body\n            };\n            const text2 = extractContentText(result2.content);\n            if (text2 === void 0) {\n              throw new NoObjectGeneratedError({\n                message: \"No object generated: the model did not return a response.\",\n                response: responseData,\n                usage: result2.usage,\n                finishReason: result2.finishReason\n              });\n            }\n            span2.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.response.finishReason\": result2.finishReason,\n                  \"ai.response.object\": { output: () => text2 },\n                  \"ai.response.id\": responseData.id,\n                  \"ai.response.model\": responseData.modelId,\n                  \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                  // TODO rename telemetry attributes to inputTokens and outputTokens\n                  \"ai.usage.promptTokens\": result2.usage.inputTokens,\n                  \"ai.usage.completionTokens\": result2.usage.outputTokens,\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                  \"gen_ai.response.id\": responseData.id,\n                  \"gen_ai.response.model\": responseData.modelId,\n                  \"gen_ai.usage.input_tokens\": result2.usage.inputTokens,\n                  \"gen_ai.usage.output_tokens\": result2.usage.outputTokens\n                }\n              })\n            );\n            return { ...result2, objectText: text2, responseData };\n          }\n        })\n      );\n      result = generateResult.objectText;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      resultProviderMetadata = generateResult.providerMetadata;\n      request = (_a17 = generateResult.request) != null ? _a17 : {};\n      response = generateResult.responseData;\n      async function processResult(result2) {\n        const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: result2 });\n        if (!parseResult.success) {\n          throw new NoObjectGeneratedError({\n            message: \"No object generated: could not parse the response.\",\n            cause: parseResult.error,\n            text: result2,\n            response,\n            usage,\n            finishReason\n          });\n        }\n        const validationResult = await outputStrategy.validateFinalResult(\n          parseResult.value,\n          {\n            text: result2,\n            response,\n            usage\n          }\n        );\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: \"No object generated: response did not match schema.\",\n            cause: validationResult.error,\n            text: result2,\n            response,\n            usage,\n            finishReason\n          });\n        }\n        return validationResult.value;\n      }\n      let object2;\n      try {\n        object2 = await processResult(result);\n      } catch (error) {\n        if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error.cause))) {\n          const repairedText = await repairText({\n            text: result,\n            error: error.cause\n          });\n          if (repairedText === null) {\n            throw error;\n          }\n          object2 = await processResult(repairedText);\n        } else {\n          throw error;\n        }\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": finishReason,\n            \"ai.response.object\": {\n              output: () => JSON.stringify(object2)\n            },\n            // TODO rename telemetry attributes to inputTokens and outputTokens\n            \"ai.usage.promptTokens\": usage.inputTokens,\n            \"ai.usage.completionTokens\": usage.outputTokens\n          }\n        })\n      );\n      return new DefaultGenerateObjectResult({\n        object: object2,\n        finishReason,\n        usage,\n        warnings,\n        request,\n        response,\n        providerMetadata: resultProviderMetadata\n      });\n    }\n  });\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n  }\n  toJsonResponse(init) {\n    var _a17;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,\n      headers: prepareHeaders(init == null ? void 0 : init.headers, {\n        \"content-type\": \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// core/generate-object/stream-object.ts\n\n\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n\n// src/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise();\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller == null ? void 0 : controller.close();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    },\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      innerStreamReaders.forEach((reader) => reader.cancel());\n      innerStreamReaders = [];\n      controller == null ? void 0 : controller.close();\n    }\n  };\n}\n\n// src/util/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get value() {\n    if (this.promise) {\n      return this.promise;\n    }\n    this.promise = new Promise((resolve, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    return this.promise;\n  }\n  resolve(value) {\n    var _a17;\n    this.status = { type: \"resolved\", value };\n    if (this.promise) {\n      (_a17 = this._resolve) == null ? void 0 : _a17.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a17;\n    this.status = { type: \"rejected\", error };\n    if (this.promise) {\n      (_a17 = this._reject) == null ? void 0 : _a17.call(this, error);\n    }\n  }\n};\n\n// src/util/now.ts\nfunction now() {\n  var _a17, _b;\n  return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();\n}\n\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nfunction streamObject(options) {\n  const {\n    model,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries,\n    abortSignal,\n    headers,\n    experimental_telemetry: telemetry,\n    providerOptions,\n    onError,\n    onFinish,\n    _internal: {\n      generateId: generateId3 = originalGenerateId2,\n      currentDate = () => /* @__PURE__ */ new Date(),\n      now: now2 = now\n    } = {},\n    ...settings\n  } = options;\n  const enumValues = \"enum\" in options && options.enum ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    onError,\n    onFinish,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    model,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    onError,\n    onFinish,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  }) {\n    this.objectPromise = new DelayedPromise();\n    this.usagePromise = new DelayedPromise();\n    this.providerMetadataPromise = new DelayedPromise();\n    this.warningsPromise = new DelayedPromise();\n    this.requestPromise = new DelayedPromise();\n    this.responsePromise = new DelayedPromise();\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg\n    });\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const tracer = getTracer(telemetry);\n    const self = this;\n    const stitchableStream = createStitchableStream();\n    const eventProcessor = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"error\") {\n          onError == null ? void 0 : onError({ error: chunk.error });\n        }\n      }\n    });\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n    recordSpan({\n      name: \"ai.streamObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.streamObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpan) => {\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const callOptions = {\n          responseFormat: {\n            type: \"json\",\n            schema: outputStrategy.jsonSchema,\n            name: schemaName,\n            description: schemaDescription\n          },\n          ...prepareCallSettings(settings),\n          prompt: await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            supportedUrls: await model.supportedUrls\n          }),\n          providerOptions,\n          abortSignal,\n          headers\n        };\n        const transformer = {\n          transform: (chunk, controller) => {\n            switch (chunk.type) {\n              case \"text\":\n                controller.enqueue(chunk.text);\n                break;\n              case \"response-metadata\":\n              case \"finish\":\n              case \"error\":\n                controller.enqueue(chunk);\n                break;\n            }\n          }\n        };\n        const {\n          result: { stream, response, request },\n          doStreamSpan,\n          startTimestampMs\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamObject.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamObject.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => JSON.stringify(callOptions.prompt)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan2) => ({\n              startTimestampMs: now2(),\n              doStreamSpan: doStreamSpan2,\n              result: await model.doStream(callOptions)\n            })\n          })\n        );\n        self.requestPromise.resolve(request != null ? request : {});\n        let warnings;\n        let usage = {\n          inputTokens: void 0,\n          outputTokens: void 0,\n          totalTokens: void 0\n        };\n        let finishReason;\n        let providerMetadata;\n        let object2;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let fullResponse = {\n          id: generateId3(),\n          timestamp: currentDate(),\n          modelId: model.modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a17, _b, _c;\n              if (typeof chunk === \"object\" && chunk.type === \"stream-start\") {\n                warnings = chunk.warnings;\n                return;\n              }\n              if (isFirstChunk) {\n                const msToFirstChunk = now2() - startTimestampMs;\n                isFirstChunk = false;\n                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan.setAttributes({\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (typeof chunk === \"string\") {\n                accumulatedText += chunk;\n                textDelta += chunk;\n                const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);\n                if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {\n                  const validationResult = await outputStrategy.validatePartialResult({\n                    value: currentObjectJson,\n                    textDelta,\n                    latestObject,\n                    isFirstDelta,\n                    isFinalDelta: parseState === \"successful-parse\"\n                  });\n                  if (validationResult.success && !isDeepEqualData(\n                    latestObject,\n                    validationResult.value.partial\n                  )) {\n                    latestObjectJson = currentObjectJson;\n                    latestObject = validationResult.value.partial;\n                    controller.enqueue({\n                      type: \"object\",\n                      object: latestObject\n                    });\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      textDelta: validationResult.value.textDelta\n                    });\n                    textDelta = \"\";\n                    isFirstDelta = false;\n                  }\n                }\n                return;\n              }\n              switch (chunk.type) {\n                case \"response-metadata\": {\n                  fullResponse = {\n                    id: (_a17 = chunk.id) != null ? _a17 : fullResponse.id,\n                    timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  if (textDelta !== \"\") {\n                    controller.enqueue({ type: \"text-delta\", textDelta });\n                  }\n                  finishReason = chunk.finishReason;\n                  usage = chunk.usage;\n                  providerMetadata = chunk.providerMetadata;\n                  controller.enqueue({\n                    ...chunk,\n                    usage,\n                    response: fullResponse\n                  });\n                  self.usagePromise.resolve(usage);\n                  self.providerMetadataPromise.resolve(providerMetadata);\n                  self.responsePromise.resolve({\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  });\n                  const validationResult = await outputStrategy.validateFinalResult(\n                    latestObjectJson,\n                    {\n                      text: accumulatedText,\n                      response: fullResponse,\n                      usage\n                    }\n                  );\n                  if (validationResult.success) {\n                    object2 = validationResult.value;\n                    self.objectPromise.resolve(object2);\n                  } else {\n                    error = new NoObjectGeneratedError({\n                      message: \"No object generated: response did not match schema.\",\n                      cause: validationResult.error,\n                      text: accumulatedText,\n                      response: fullResponse,\n                      usage,\n                      finishReason\n                    });\n                    self.objectPromise.reject(error);\n                  }\n                  break;\n                }\n                default: {\n                  controller.enqueue(chunk);\n                  break;\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              try {\n                const finalUsage = usage != null ? usage : {\n                  promptTokens: NaN,\n                  completionTokens: NaN,\n                  totalTokens: NaN\n                };\n                doStreamSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": finishReason,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.id\": fullResponse.id,\n                      \"ai.response.model\": fullResponse.modelId,\n                      \"ai.response.timestamp\": fullResponse.timestamp.toISOString(),\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [finishReason],\n                      \"gen_ai.response.id\": fullResponse.id,\n                      \"gen_ai.response.model\": fullResponse.modelId,\n                      \"gen_ai.usage.input_tokens\": finalUsage.inputTokens,\n                      \"gen_ai.usage.output_tokens\": finalUsage.outputTokens\n                    }\n                  })\n                );\n                doStreamSpan.end();\n                rootSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      }\n                    }\n                  })\n                );\n                await (onFinish == null ? void 0 : onFinish({\n                  usage: finalUsage,\n                  object: object2,\n                  error,\n                  response: {\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  },\n                  warnings,\n                  providerMetadata\n                }));\n              } catch (error2) {\n                controller.enqueue({ type: \"error\", error: error2 });\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        );\n        stitchableStream.addStream(transformedStream);\n      }\n    }).catch((error) => {\n      stitchableStream.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n    }).finally(() => {\n      stitchableStream.close();\n    });\n    this.outputStrategy = outputStrategy;\n  }\n  get object() {\n    return this.objectPromise.value;\n  }\n  get usage() {\n    return this.usagePromise.value;\n  }\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n  get request() {\n    return this.requestPromise.value;\n  }\n  get response() {\n    return this.responsePromise.value;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"object\":\n                controller.enqueue(chunk.object);\n                break;\n              case \"text-delta\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.textDelta);\n                break;\n              case \"object\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.baseStream);\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/error/no-speech-generated-error.ts\n\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_NoSpeechGeneratedError\",\n      message: \"No speech audio generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// core/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n  constructor({\n    data,\n    mediaType\n  }) {\n    super({ data, mediaType });\n    let format = \"mp3\";\n    if (mediaType) {\n      const mediaTypeParts = mediaType.split(\"/\");\n      if (mediaTypeParts.length === 2) {\n        if (mediaType !== \"audio/mpeg\") {\n          format = mediaTypeParts[1];\n        }\n      }\n    }\n    if (!format) {\n      throw new Error(\n        \"Audio format must be provided or determinable from media type\"\n      );\n    }\n    this.format = format;\n  }\n};\n\n// core/generate-speech/generate-speech.ts\nasync function generateSpeech({\n  model,\n  text: text2,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a17;\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const result = await retry(\n    () => model.doGenerate({\n      text: text2,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      abortSignal,\n      headers,\n      providerOptions\n    })\n  );\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mediaType: (_a17 = detectMediaType({\n        data: result.audio,\n        signatures: audioMediaTypeSignatures\n      })) != null ? _a17 : \"audio/mp3\"\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultSpeechResult = class {\n  constructor(options) {\n    var _a17;\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n  }\n};\n\n// core/generate-text/generate-text.ts\n\n\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n  return object2 != null && Object.keys(object2).length > 0;\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(\n    ([name17]) => activeTools.includes(name17)\n  ) : Object.entries(tools);\n  return {\n    tools: filteredTools.map(([name17, tool2]) => {\n      const toolType = tool2.type;\n      switch (toolType) {\n        case void 0:\n        case \"function\":\n          return {\n            type: \"function\",\n            name: name17,\n            description: tool2.description,\n            parameters: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.parameters).jsonSchema\n          };\n        case \"provider-defined\":\n          return {\n            type: \"provider-defined\",\n            name: name17,\n            id: tool2.id,\n            args: tool2.args\n          };\n        default: {\n          const exhaustiveCheck = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// core/types/usage.ts\nfunction addLanguageModelUsage(usage1, usage2) {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(\n      usage1.reasoningTokens,\n      usage2.reasoningTokens\n    ),\n    cachedInputTokens: addTokenCounts(\n      usage1.cachedInputTokens,\n      usage2.cachedInputTokens\n    )\n  };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\n\n// core/generate-text/as-content.ts\nfunction asContent({\n  content,\n  toolCalls,\n  toolResults\n}) {\n  return [\n    ...content.map((part) => {\n      switch (part.type) {\n        case \"text\":\n        case \"reasoning\":\n        case \"source\":\n          return part;\n        case \"file\": {\n          return {\n            type: \"file\",\n            file: new DefaultGeneratedFile(part)\n          };\n        }\n        case \"tool-call\": {\n          return toolCalls.find(\n            (toolCall) => toolCall.toolCallId === part.toolCallId\n          );\n        }\n      }\n    }),\n    ...toolResults\n  ];\n}\n\n// core/generate-text/parse-tool-call.ts\n\nasync function parseToolCall({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages\n}) {\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  try {\n    return await doParseToolCall({ toolCall, tools });\n  } catch (error) {\n    if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolArgumentsError.isInstance(error))) {\n      throw error;\n    }\n    let repairedToolCall = null;\n    try {\n      repairedToolCall = await repairToolCall({\n        toolCall,\n        tools,\n        parameterSchema: ({ toolName }) => {\n          const { parameters } = tools[toolName];\n          return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(parameters).jsonSchema;\n        },\n        system,\n        messages,\n        error\n      });\n    } catch (repairError) {\n      throw new ToolCallRepairError({\n        cause: repairError,\n        originalError: error\n      });\n    }\n    if (repairedToolCall == null) {\n      throw error;\n    }\n    return await doParseToolCall({ toolCall: repairedToolCall, tools });\n  }\n}\nasync function doParseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.parameters);\n  const parseResult = toolCall.args.trim() === \"\" ? await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: {}, schema }) : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.args, schema });\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult == null ? void 0 : parseResult.value\n  };\n}\n\n// core/generate-text/step-result.ts\nvar DefaultStepResult = class {\n  constructor({\n    content,\n    finishReason,\n    usage,\n    warnings,\n    request,\n    response,\n    providerMetadata\n  }) {\n    this.content = content;\n    this.finishReason = finishReason;\n    this.usage = usage;\n    this.warnings = warnings;\n    this.request = request;\n    this.response = response;\n    this.providerMetadata = providerMetadata;\n  }\n  get text() {\n    return this.content.filter((part) => part.type === \"text\").map((part) => part.text).join(\"\");\n  }\n  get reasoning() {\n    return this.content.filter((part) => part.type === \"reasoning\");\n  }\n  get reasoningText() {\n    return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join(\"\");\n  }\n  get files() {\n    return this.content.filter((part) => part.type === \"file\").map((part) => part.file);\n  }\n  get sources() {\n    return this.content.filter((part) => part.type === \"source\");\n  }\n  get toolCalls() {\n    return this.content.filter((part) => part.type === \"tool-call\");\n  }\n  get toolResults() {\n    return this.content.filter((part) => part.type === \"tool-result\");\n  }\n};\n\n// core/generate-text/stop-condition.ts\nfunction maxSteps(maxSteps2) {\n  return ({ steps }) => steps.length >= maxSteps2;\n}\nfunction hasToolCall(toolName) {\n  return ({ steps }) => {\n    var _a17, _b, _c;\n    return (_c = (_b = (_a17 = steps[steps.length - 1]) == null ? void 0 : _a17.toolCalls) == null ? void 0 : _b.some(\n      (toolCall) => toolCall.toolName === toolName\n    )) != null ? _c : false;\n  };\n}\n\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({\n  content: inputContent,\n  tools\n}) {\n  const responseMessages = [];\n  const content = inputContent.filter((part) => part.type !== \"tool-result\" && part.type !== \"source\").filter((part) => part.type !== \"text\" || part.text.length > 0).map((part) => {\n    switch (part.type) {\n      case \"text\":\n        return part;\n      case \"reasoning\":\n        return {\n          type: \"reasoning\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"file\":\n        return {\n          type: \"file\",\n          data: part.file.base64,\n          mediaType: part.file.mediaType\n        };\n      case \"tool-call\":\n        return part;\n    }\n  });\n  if (content.length > 0) {\n    responseMessages.push({\n      role: \"assistant\",\n      content\n    });\n  }\n  const toolResultContent = inputContent.filter((part) => part.type === \"tool-result\").map((toolResult) => {\n    const tool2 = tools[toolResult.toolName];\n    return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n      type: \"tool-result\",\n      toolCallId: toolResult.toolCallId,\n      toolName: toolResult.toolName,\n      result: tool2.experimental_toToolResultContent(toolResult.result),\n      experimental_content: tool2.experimental_toToolResultContent(\n        toolResult.result\n      )\n    } : {\n      type: \"tool-result\",\n      toolCallId: toolResult.toolCallId,\n      toolName: toolResult.toolName,\n      result: toolResult.result\n    };\n  });\n  if (toolResultContent.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResultContent\n    });\n  }\n  return responseMessages;\n}\n\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nasync function generateText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  continueUntil = maxSteps(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_activeTools: activeTools,\n  experimental_prepareStep: prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  _internal: {\n    generateId: generateId3 = originalGenerateId3,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  onStepFinish,\n  ...settings\n}) {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const callSettings = prepareCallSettings(settings);\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...callSettings, maxRetries }\n  });\n  const initialPrompt = await standardizePrompt({\n    system,\n    prompt,\n    messages\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.generateText\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.generateText\",\n          telemetry\n        }),\n        ...baseTelemetryAttributes,\n        // model:\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // specific settings that only make sense on the outer level:\n        \"ai.prompt\": {\n          input: () => JSON.stringify({ system, prompt, messages })\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a17, _b, _c, _d;\n      const callSettings2 = prepareCallSettings(settings);\n      let currentModelResponse;\n      let currentToolCalls = [];\n      let currentToolResults = [];\n      const responseMessages = [];\n      const steps = [];\n      do {\n        const stepInputMessages = [\n          ...initialPrompt.messages,\n          ...responseMessages\n        ];\n        const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n          model,\n          steps,\n          stepNumber: steps.length\n        }));\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            system: initialPrompt.system,\n            messages: stepInputMessages\n          },\n          supportedUrls: await model.supportedUrls\n        });\n        const stepModel = (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a17 : model;\n        const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({\n          tools,\n          toolChoice: (_b = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _b : toolChoice,\n          activeTools: (_c = prepareStepResult == null ? void 0 : prepareStepResult.experimental_activeTools) != null ? _c : activeTools\n        });\n        currentModelResponse = await retry(\n          () => {\n            var _a18;\n            return recordSpan({\n              name: \"ai.generateText.doGenerate\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.generateText.doGenerate\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  // model:\n                  \"ai.model.provider\": stepModel.provider,\n                  \"ai.model.id\": stepModel.modelId,\n                  // prompt:\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.prompt.tools\": {\n                    // convert the language model level tools:\n                    input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))\n                  },\n                  \"ai.prompt.toolChoice\": {\n                    input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": stepModel.provider,\n                  \"gen_ai.request.model\": stepModel.modelId,\n                  \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                  \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                  \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                  \"gen_ai.request.temperature\": (_a18 = settings.temperature) != null ? _a18 : void 0,\n                  \"gen_ai.request.top_k\": settings.topK,\n                  \"gen_ai.request.top_p\": settings.topP\n                }\n              }),\n              tracer,\n              fn: async (span2) => {\n                var _a19, _b2, _c2, _d2, _e, _f, _g, _h;\n                const result = await stepModel.doGenerate({\n                  ...callSettings2,\n                  tools: stepTools,\n                  toolChoice: stepToolChoice,\n                  responseFormat: output == null ? void 0 : output.responseFormat,\n                  prompt: promptMessages,\n                  providerOptions,\n                  abortSignal,\n                  headers\n                });\n                const responseData = {\n                  id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId3(),\n                  timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                  modelId: (_f = (_e = result.response) == null ? void 0 : _e.modelId) != null ? _f : stepModel.modelId,\n                  headers: (_g = result.response) == null ? void 0 : _g.headers,\n                  body: (_h = result.response) == null ? void 0 : _h.body\n                };\n                span2.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": result.finishReason,\n                      \"ai.response.text\": {\n                        output: () => extractContentText(result.content)\n                      },\n                      \"ai.response.toolCalls\": {\n                        output: () => {\n                          const toolCalls = asToolCalls(result.content);\n                          return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                        }\n                      },\n                      \"ai.response.id\": responseData.id,\n                      \"ai.response.model\": responseData.modelId,\n                      \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                      // TODO rename telemetry attributes to inputTokens and outputTokens\n                      \"ai.usage.promptTokens\": result.usage.inputTokens,\n                      \"ai.usage.completionTokens\": result.usage.outputTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [result.finishReason],\n                      \"gen_ai.response.id\": responseData.id,\n                      \"gen_ai.response.model\": responseData.modelId,\n                      \"gen_ai.usage.input_tokens\": result.usage.inputTokens,\n                      \"gen_ai.usage.output_tokens\": result.usage.outputTokens\n                    }\n                  })\n                );\n                return { ...result, response: responseData };\n              }\n            });\n          }\n        );\n        currentToolCalls = await Promise.all(\n          currentModelResponse.content.filter(\n            (part) => part.type === \"tool-call\"\n          ).map(\n            (toolCall) => parseToolCall({\n              toolCall,\n              tools,\n              repairToolCall,\n              system,\n              messages: stepInputMessages\n            })\n          )\n        );\n        currentToolResults = tools == null ? [] : await executeTools({\n          toolCalls: currentToolCalls,\n          tools,\n          tracer,\n          telemetry,\n          messages: stepInputMessages,\n          abortSignal\n        });\n        const stepContent = asContent({\n          content: currentModelResponse.content,\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults\n        });\n        responseMessages.push(\n          ...toResponseMessages({\n            content: stepContent,\n            tools: tools != null ? tools : {}\n          })\n        );\n        const currentStepResult = new DefaultStepResult({\n          content: stepContent,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentModelResponse.usage,\n          warnings: currentModelResponse.warnings,\n          providerMetadata: currentModelResponse.providerMetadata,\n          request: (_d = currentModelResponse.request) != null ? _d : {},\n          response: {\n            ...currentModelResponse.response,\n            // deep clone msgs to avoid mutating past messages in multi-step:\n            messages: structuredClone(responseMessages)\n          }\n        });\n        steps.push(currentStepResult);\n        await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n      } while (\n        // there are tool calls:\n        currentToolCalls.length > 0 && // all current tool calls have results:\n        currentToolResults.length === currentToolCalls.length && // continue until the stop condition is met:\n        !await continueUntil({ steps })\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.response.finishReason\": currentModelResponse.finishReason,\n            \"ai.response.text\": {\n              output: () => extractContentText(currentModelResponse.content)\n            },\n            \"ai.response.toolCalls\": {\n              output: () => {\n                const toolCalls = asToolCalls(currentModelResponse.content);\n                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n              }\n            },\n            // TODO rename telemetry attributes to inputTokens and outputTokens\n            \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens,\n            \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens\n          }\n        })\n      );\n      const lastStep = steps[steps.length - 1];\n      return new DefaultGenerateTextResult({\n        steps,\n        resolvedOutput: await (output == null ? void 0 : output.parseOutput(\n          { text: lastStep.text },\n          {\n            response: lastStep.response,\n            usage: lastStep.usage,\n            finishReason: lastStep.finishReason\n          }\n        ))\n      });\n    }\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, args }) => {\n      const tool2 = tools[toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolName,\n            \"ai.toolCall.id\": toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(args)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          try {\n            const result2 = await tool2.execute(args, {\n              toolCallId,\n              messages,\n              abortSignal\n            });\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.toolCall.result\": {\n                      output: () => JSON.stringify(result2)\n                    }\n                  }\n                })\n              );\n            } catch (ignored) {\n            }\n            return result2;\n          } catch (error) {\n            throw new ToolExecutionError({\n              toolCallId,\n              toolName,\n              toolArgs: args,\n              cause: error\n            });\n          }\n        }\n      });\n      return {\n        type: \"tool-result\",\n        toolCallId,\n        toolName,\n        args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.steps = options.steps;\n    this.resolvedOutput = options.resolvedOutput;\n  }\n  get finalStep() {\n    return this.steps[this.steps.length - 1];\n  }\n  get content() {\n    return this.finalStep.content;\n  }\n  get text() {\n    return this.finalStep.text;\n  }\n  get files() {\n    return this.finalStep.files;\n  }\n  get reasoningText() {\n    return this.finalStep.reasoningText;\n  }\n  get reasoning() {\n    return this.finalStep.reasoning;\n  }\n  get toolCalls() {\n    return this.finalStep.toolCalls;\n  }\n  get toolResults() {\n    return this.finalStep.toolResults;\n  }\n  get sources() {\n    return this.finalStep.sources;\n  }\n  get finishReason() {\n    return this.finalStep.finishReason;\n  }\n  get warnings() {\n    return this.finalStep.warnings;\n  }\n  get providerMetadata() {\n    return this.finalStep.providerMetadata;\n  }\n  get response() {\n    return this.finalStep.response;\n  }\n  get request() {\n    return this.finalStep.request;\n  }\n  get usage() {\n    return this.finalStep.usage;\n  }\n  get totalUsage() {\n    return this.steps.reduce(\n      (totalUsage, step) => {\n        return addLanguageModelUsage(totalUsage, step.usage);\n      },\n      {\n        inputTokens: void 0,\n        outputTokens: void 0,\n        totalTokens: void 0,\n        reasoningTokens: void 0,\n        cachedInputTokens: void 0\n      }\n    );\n  }\n  get experimental_output() {\n    if (this.resolvedOutput == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return this.resolvedOutput;\n  }\n};\nfunction asToolCalls(content) {\n  const parts = content.filter(\n    (part) => part.type === \"tool-call\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((toolCall) => ({\n    toolCallType: toolCall.toolCallType,\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    args: toolCall.args\n  }));\n}\n\n// core/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n  object: () => object,\n  text: () => text\n});\n\nvar text = () => ({\n  type: \"text\",\n  responseFormat: { type: \"text\" },\n  async parsePartial({ text: text2 }) {\n    return { partial: text2 };\n  },\n  async parseOutput({ text: text2 }) {\n    return text2;\n  }\n});\nvar object = ({\n  schema: inputSchema\n}) => {\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema);\n  return {\n    type: \"object\",\n    responseFormat: {\n      type: \"json\",\n      schema: schema.jsonSchema\n    },\n    async parsePartial({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\":\n          return void 0;\n        case \"repaired-parse\":\n        case \"successful-parse\":\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value\n          };\n        default: {\n          const _exhaustiveCheck = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    async parseOutput({ text: text2 }, context) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: validationResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      return validationResult.value;\n    }\n  };\n};\n\n// core/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m\n};\nfunction smoothStream({\n  delayInMs = 10,\n  chunking = \"word\",\n  _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {}\n} = {}) {\n  let detectChunk;\n  if (typeof chunking === \"function\") {\n    detectChunk = (buffer) => {\n      const match = chunking(buffer);\n      if (match == null) {\n        return null;\n      }\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`\n        );\n      }\n      return match;\n    };\n  } else {\n    const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking;\n    if (chunkingRegex == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n        argument: \"chunking\",\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`\n      });\n    }\n    detectChunk = (buffer) => {\n      const match = chunkingRegex.exec(buffer);\n      if (!match) {\n        return null;\n      }\n      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n    };\n  }\n  return () => {\n    let buffer = \"\";\n    return new TransformStream({\n      async transform(chunk, controller) {\n        if (chunk.type !== \"text\") {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: \"text\", text: buffer });\n            buffer = \"\";\n          }\n          controller.enqueue(chunk);\n          return;\n        }\n        buffer += chunk.text;\n        let match;\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: \"text\", text: match });\n          buffer = buffer.slice(match.length);\n          await delay2(delayInMs);\n        }\n      }\n    });\n  };\n}\n\n// core/generate-text/stream-text.ts\n\n\n// src/util/as-array.ts\nfunction asArray(value) {\n  return value === void 0 ? [] : Array.isArray(value) ? value : [value];\n}\n\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall\n}) {\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const activeToolCalls = {};\n  const outstandingToolResults = /* @__PURE__ */ new Set();\n  let canClose = false;\n  let finishChunk = void 0;\n  function attemptClose() {\n    if (canClose && outstandingToolResults.size === 0) {\n      if (finishChunk != null) {\n        toolResultsStreamController.enqueue(finishChunk);\n      }\n      toolResultsStreamController.close();\n    }\n  }\n  const forwardStream = new TransformStream({\n    async transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"stream-start\":\n        case \"finish\":\n        case \"text\":\n        case \"reasoning\":\n        case \"reasoning-part-finish\":\n        case \"source\":\n        case \"response-metadata\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"file\": {\n          controller.enqueue({\n            type: \"file\",\n            file: new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mediaType: chunk.mediaType\n            })\n          });\n          break;\n        }\n        case \"tool-call-delta\": {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: \"tool-call-streaming-start\",\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName\n              });\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n            controller.enqueue({\n              type: \"tool-call-delta\",\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta\n            });\n          }\n          break;\n        }\n        case \"tool-call\": {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages\n            });\n            controller.enqueue(toolCall);\n            const tool2 = tools[toolCall.toolName];\n            if (tool2.execute != null) {\n              const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId)();\n              outstandingToolResults.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.args)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => tool2.execute(toolCall.args, {\n                  toolCallId: toolCall.toolCallId,\n                  messages,\n                  abortSignal\n                }).then(\n                  (result) => {\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-result\",\n                      result\n                    });\n                    outstandingToolResults.delete(toolExecutionId);\n                    attemptClose();\n                    try {\n                      span.setAttributes(\n                        selectTelemetryAttributes({\n                          telemetry,\n                          attributes: {\n                            \"ai.toolCall.result\": {\n                              output: () => JSON.stringify(result)\n                            }\n                          }\n                        })\n                      );\n                    } catch (ignored) {\n                    }\n                  },\n                  (error) => {\n                    toolResultsStreamController.enqueue({\n                      type: \"error\",\n                      error: new ToolExecutionError({\n                        toolCallId: toolCall.toolCallId,\n                        toolName: toolCall.toolName,\n                        toolArgs: toolCall.args,\n                        cause: error\n                      })\n                    });\n                    outstandingToolResults.delete(toolExecutionId);\n                    attemptClose();\n                  }\n                )\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      attemptClose();\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nfunction streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxSteps: maxSteps2 = 1,\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_toolCallStreaming = false,\n  toolCallStreaming = experimental_toolCallStreaming,\n  experimental_activeTools: activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  onChunk,\n  onError,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now: now2 = now,\n    generateId: generateId3 = originalGenerateId4,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  return new DefaultStreamTextResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    maxSteps: maxSteps2,\n    output,\n    providerOptions,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n    now: now2,\n    currentDate,\n    generateId: generateId3\n  });\n}\nfunction createOutputTransformStream(output) {\n  if (!output) {\n    return new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n      }\n    });\n  }\n  let text2 = \"\";\n  let textChunk = \"\";\n  let lastPublishedJson = \"\";\n  function publishTextChunk({\n    controller,\n    partialOutput = void 0\n  }) {\n    controller.enqueue({\n      part: { type: \"text\", text: textChunk },\n      partialOutput\n    });\n    textChunk = \"\";\n  }\n  return new TransformStream({\n    async transform(chunk, controller) {\n      if (chunk.type === \"finish-step\") {\n        publishTextChunk({ controller });\n      }\n      if (chunk.type !== \"text\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      text2 += chunk.text;\n      textChunk += chunk.text;\n      const result = await output.parsePartial({ text: text2 });\n      if (result != null) {\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    },\n    flush(controller) {\n      if (textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms,\n    activeTools,\n    repairToolCall,\n    maxSteps: maxSteps2,\n    output,\n    providerOptions,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish\n  }) {\n    this.totalUsagePromise = new DelayedPromise();\n    this.finishReasonPromise = new DelayedPromise();\n    this.stepsPromise = new DelayedPromise();\n    if (maxSteps2 < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxSteps\",\n        value: maxSteps2,\n        message: \"maxSteps must be at least 1\"\n      });\n    }\n    this.output = output;\n    this.generateId = generateId3;\n    let activeReasoningPart = void 0;\n    let recordedContent = [];\n    const recordedResponseMessages = [];\n    let recordedFinishReason = void 0;\n    let recordedTotalUsage = void 0;\n    let recordedRequest = {};\n    let recordedWarnings = [];\n    const recordedSteps = [];\n    let rootSpan;\n    const eventProcessor = new TransformStream({\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        const { part } = chunk;\n        if (part.type === \"text\" || part.type === \"reasoning\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-call-streaming-start\" || part.type === \"tool-call-delta\") {\n          await (onChunk == null ? void 0 : onChunk({ chunk: part }));\n        }\n        if (part.type === \"error\") {\n          await (onError == null ? void 0 : onError({ error: part.error }));\n        }\n        if (part.type === \"text\") {\n          const latestContent = recordedContent[recordedContent.length - 1];\n          if ((latestContent == null ? void 0 : latestContent.type) === \"text\") {\n            latestContent.text += part.text;\n          } else {\n            recordedContent.push({ type: \"text\", text: part.text });\n          }\n        }\n        if (part.type === \"reasoning\") {\n          if (activeReasoningPart == null) {\n            activeReasoningPart = {\n              type: \"reasoning\",\n              text: part.text,\n              providerMetadata: part.providerMetadata\n            };\n            recordedContent.push(activeReasoningPart);\n          } else {\n            activeReasoningPart.text += part.text;\n            activeReasoningPart.providerMetadata = part.providerMetadata;\n          }\n        }\n        if (part.type === \"reasoning-part-finish\" && activeReasoningPart != null) {\n          activeReasoningPart = void 0;\n        }\n        if (part.type === \"file\") {\n          recordedContent.push({ type: \"file\", file: part.file });\n        }\n        if (part.type === \"source\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-call\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-result\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"start-step\") {\n          recordedRequest = part.request;\n          recordedWarnings = part.warnings;\n        }\n        if (part.type === \"finish-step\") {\n          const stepMessages = toResponseMessages({\n            content: recordedContent,\n            tools: tools != null ? tools : {}\n          });\n          const currentStepResult = new DefaultStepResult({\n            content: recordedContent,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: recordedWarnings,\n            request: recordedRequest,\n            response: {\n              ...part.response,\n              messages: [...recordedResponseMessages, ...stepMessages]\n            },\n            providerMetadata: part.providerMetadata\n          });\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          recordedSteps.push(currentStepResult);\n          recordedContent = [];\n          activeReasoningPart = void 0;\n          recordedResponseMessages.push(...stepMessages);\n        }\n        if (part.type === \"finish\") {\n          recordedTotalUsage = part.totalUsage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            return;\n          }\n          const finishReason = recordedFinishReason != null ? recordedFinishReason : \"unknown\";\n          const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          self.finishReasonPromise.resolve(finishReason);\n          self.totalUsagePromise.resolve(totalUsage);\n          self.stepsPromise.resolve(recordedSteps);\n          const finalStep = recordedSteps[recordedSteps.length - 1];\n          await (onFinish == null ? void 0 : onFinish({\n            finishReason,\n            totalUsage,\n            usage: finalStep.usage,\n            content: finalStep.content,\n            text: finalStep.text,\n            reasoningText: finalStep.reasoningText,\n            reasoning: finalStep.reasoning,\n            files: finalStep.files,\n            sources: finalStep.sources,\n            toolCalls: finalStep.toolCalls,\n            toolResults: finalStep.toolResults,\n            request: finalStep.request,\n            response: finalStep.response,\n            warnings: finalStep.warnings,\n            providerMetadata: finalStep.providerMetadata,\n            steps: recordedSteps\n          }));\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.response.finishReason\": finishReason,\n                \"ai.response.text\": { output: () => finalStep.text },\n                \"ai.response.toolCalls\": {\n                  output: () => {\n                    var _a17;\n                    return ((_a17 = finalStep.toolCalls) == null ? void 0 : _a17.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                  }\n                },\n                \"ai.usage.inputTokens\": totalUsage.inputTokens,\n                \"ai.usage.outputTokens\": totalUsage.outputTokens,\n                \"ai.usage.totalTokens\": totalUsage.totalTokens,\n                \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n                \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n              }\n            })\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      }\n    });\n    const stitchableStream = createStitchableStream();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n    let stream = stitchableStream.stream;\n    stream = stream.pipeThrough(\n      new TransformStream({\n        start(controller) {\n          controller.enqueue({ type: \"start\" });\n        }\n      })\n    );\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools,\n          stopStream() {\n            stitchableStream.terminate();\n          }\n        })\n      );\n    }\n    this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg\n    });\n    const tracer = getTracer(telemetry);\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const self = this;\n    recordSpan({\n      name: \"ai.streamText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.settings.maxSteps\": maxSteps2\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpanArg) => {\n        rootSpan = rootSpanArg;\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage\n        }) {\n          const initialPrompt = await standardizePrompt({\n            system,\n            prompt,\n            messages\n          });\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages\n          ];\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: initialPrompt.system,\n              messages: stepInputMessages\n            },\n            supportedUrls: await model.supportedUrls\n          });\n          const toolsAndToolChoice = {\n            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools })\n          };\n          const {\n            result: { stream: stream2, response, request },\n            doStreamSpan,\n            startTimestampMs\n          } = await retry(\n            () => recordSpan({\n              name: \"ai.streamText.doStream\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.streamText.doStream\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  \"ai.prompt.messages\": {\n                    input: () => JSON.stringify(promptMessages)\n                  },\n                  \"ai.prompt.tools\": {\n                    // convert the language model level tools:\n                    input: () => {\n                      var _a17;\n                      return (_a17 = toolsAndToolChoice.tools) == null ? void 0 : _a17.map(\n                        (tool2) => JSON.stringify(tool2)\n                      );\n                    }\n                  },\n                  \"ai.prompt.toolChoice\": {\n                    input: () => toolsAndToolChoice.toolChoice != null ? JSON.stringify(toolsAndToolChoice.toolChoice) : void 0\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": model.provider,\n                  \"gen_ai.request.model\": model.modelId,\n                  \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                  \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                  \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                  \"gen_ai.request.temperature\": callSettings.temperature,\n                  \"gen_ai.request.top_k\": callSettings.topK,\n                  \"gen_ai.request.top_p\": callSettings.topP\n                }\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async (doStreamSpan2) => {\n                return {\n                  startTimestampMs: now2(),\n                  // get before the call\n                  doStreamSpan: doStreamSpan2,\n                  result: await model.doStream({\n                    ...callSettings,\n                    ...toolsAndToolChoice,\n                    responseFormat: output == null ? void 0 : output.responseFormat,\n                    prompt: promptMessages,\n                    providerOptions,\n                    abortSignal,\n                    headers\n                  })\n                };\n              }\n            })\n          );\n          const transformedStream = runToolsTransformation({\n            tools,\n            generatorStream: stream2,\n            toolCallStreaming,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal\n          });\n          const stepRequest = request != null ? request : {};\n          const stepToolCalls = [];\n          const stepToolResults = [];\n          let warnings;\n          const stepContent = [];\n          let activeReasoningPart2 = void 0;\n          let stepFinishReason = \"unknown\";\n          let stepUsage = {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          let stepProviderMetadata;\n          let stepFirstChunk = true;\n          let stepText = \"\";\n          let stepResponse = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId: model.modelId\n          };\n          async function publishTextChunk({\n            controller,\n            chunk\n          }) {\n            controller.enqueue(chunk);\n            stepText += chunk.text;\n          }\n          self.addStream(\n            transformedStream.pipeThrough(\n              new TransformStream({\n                async transform(chunk, controller) {\n                  var _a17, _b, _c, _d;\n                  if (chunk.type === \"stream-start\") {\n                    warnings = chunk.warnings;\n                    return;\n                  }\n                  if (stepFirstChunk) {\n                    const msToFirstChunk = now2() - startTimestampMs;\n                    stepFirstChunk = false;\n                    doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    doStreamSpan.setAttributes({\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    controller.enqueue({\n                      type: \"start-step\",\n                      request: stepRequest,\n                      warnings: warnings != null ? warnings : []\n                    });\n                  }\n                  if (chunk.type === \"text\" && chunk.text.length === 0) {\n                    return;\n                  }\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case \"text\": {\n                      await publishTextChunk({ controller, chunk });\n                      break;\n                    }\n                    case \"reasoning\": {\n                      controller.enqueue(chunk);\n                      if (activeReasoningPart2 == null) {\n                        activeReasoningPart2 = {\n                          type: \"reasoning\",\n                          text: chunk.text,\n                          providerMetadata: chunk.providerMetadata\n                        };\n                        stepContent.push(activeReasoningPart2);\n                      } else {\n                        activeReasoningPart2.text += chunk.text;\n                        activeReasoningPart2.providerMetadata = chunk.providerMetadata;\n                      }\n                      break;\n                    }\n                    case \"reasoning-part-finish\": {\n                      activeReasoningPart2 = void 0;\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"tool-call\": {\n                      controller.enqueue(chunk);\n                      stepToolCalls.push(chunk);\n                      stepContent.push(chunk);\n                      break;\n                    }\n                    case \"tool-result\": {\n                      controller.enqueue(chunk);\n                      stepToolResults.push(chunk);\n                      stepContent.push(chunk);\n                      break;\n                    }\n                    case \"response-metadata\": {\n                      stepResponse = {\n                        id: (_a17 = chunk.id) != null ? _a17 : stepResponse.id,\n                        timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                        modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                      };\n                      break;\n                    }\n                    case \"finish\": {\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata = chunk.providerMetadata;\n                      const msToFinish = now2() - startTimestampMs;\n                      doStreamSpan.addEvent(\"ai.stream.finish\");\n                      doStreamSpan.setAttributes({\n                        \"ai.response.msToFinish\": msToFinish,\n                        \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d = stepUsage.outputTokens) != null ? _d : 0) / msToFinish\n                      });\n                      break;\n                    }\n                    case \"file\": {\n                      stepContent.push(chunk);\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"source\": {\n                      stepContent.push(chunk);\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"tool-call-streaming-start\":\n                    case \"tool-call-delta\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"error\": {\n                      controller.enqueue(chunk);\n                      stepFinishReason = \"error\";\n                      break;\n                    }\n                    default: {\n                      const exhaustiveCheck = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.response.finishReason\": stepFinishReason,\n                          \"ai.response.text\": { output: () => stepText },\n                          \"ai.response.toolCalls\": {\n                            output: () => stepToolCallsJson\n                          },\n                          \"ai.response.id\": stepResponse.id,\n                          \"ai.response.model\": stepResponse.modelId,\n                          \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                          \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                          \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                          \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                          \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                          \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                          // standardized gen-ai llm span attributes:\n                          \"gen_ai.response.finish_reasons\": [stepFinishReason],\n                          \"gen_ai.response.id\": stepResponse.id,\n                          \"gen_ai.response.model\": stepResponse.modelId,\n                          \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                          \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                        }\n                      })\n                    );\n                  } catch (error) {\n                  } finally {\n                    doStreamSpan.end();\n                  }\n                  controller.enqueue({\n                    type: \"finish-step\",\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    response: {\n                      ...stepResponse,\n                      headers: response == null ? void 0 : response.headers\n                    }\n                  });\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                  if (currentStep + 1 < maxSteps2 && // there are tool calls:\n                  stepToolCalls.length > 0 && // all current tool calls have results:\n                  stepToolResults.length === stepToolCalls.length) {\n                    responseMessages.push(\n                      ...toResponseMessages({\n                        content: stepContent,\n                        tools: tools != null ? tools : {}\n                      })\n                    );\n                    await streamStep({\n                      currentStep: currentStep + 1,\n                      responseMessages,\n                      usage: combinedUsage\n                    });\n                  } else {\n                    controller.enqueue({\n                      type: \"finish\",\n                      finishReason: stepFinishReason,\n                      totalUsage: combinedUsage\n                    });\n                    self.closeStream();\n                  }\n                }\n              })\n            )\n          );\n        }\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          }\n        });\n      }\n    }).catch((error) => {\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n      self.closeStream();\n    });\n  }\n  get steps() {\n    return this.stepsPromise.value;\n  }\n  get finalStep() {\n    return this.steps.then((steps) => steps[steps.length - 1]);\n  }\n  get content() {\n    return this.finalStep.then((step) => step.content);\n  }\n  get warnings() {\n    return this.finalStep.then((step) => step.warnings);\n  }\n  get providerMetadata() {\n    return this.finalStep.then((step) => step.providerMetadata);\n  }\n  get text() {\n    return this.finalStep.then((step) => step.text);\n  }\n  get reasoningText() {\n    return this.finalStep.then((step) => step.reasoningText);\n  }\n  get reasoning() {\n    return this.finalStep.then((step) => step.reasoning);\n  }\n  get sources() {\n    return this.finalStep.then((step) => step.sources);\n  }\n  get files() {\n    return this.finalStep.then((step) => step.files);\n  }\n  get toolCalls() {\n    return this.finalStep.then((step) => step.toolCalls);\n  }\n  get toolResults() {\n    return this.finalStep.then((step) => step.toolResults);\n  }\n  get usage() {\n    return this.finalStep.then((step) => step.usage);\n  }\n  get request() {\n    return this.finalStep.then((step) => step.request);\n  }\n  get response() {\n    return this.finalStep.then((step) => step.response);\n  }\n  get totalUsage() {\n    return this.totalUsagePromise.value;\n  }\n  get finishReason() {\n    return this.finishReasonPromise.value;\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            if (part.type === \"text\") {\n              controller.enqueue(part.text);\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          }\n        })\n      )\n    );\n  }\n  async consumeStream(options) {\n    var _a17;\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options == null ? void 0 : options.onError\n      });\n    } catch (error) {\n      (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);\n    }\n  }\n  get experimental_partialOutputStream() {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          }\n        })\n      )\n    );\n  }\n  toUIMessageStream({\n    newMessageId,\n    originalMessages = [],\n    onFinish,\n    messageMetadata,\n    sendReasoning = false,\n    sendSources = false,\n    experimental_sendStart = true,\n    experimental_sendFinish = true,\n    onError = () => \"An error occurred.\"\n    // mask error messages for safety by default\n  } = {}) {\n    const lastMessage = originalMessages[originalMessages.length - 1];\n    const isContinuation = (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\";\n    const messageId = isContinuation ? lastMessage.id : newMessageId;\n    const baseStream = this.fullStream.pipeThrough(\n      new TransformStream({\n        transform: async (part, controller) => {\n          const partType = part.type;\n          switch (partType) {\n            case \"text\": {\n              controller.enqueue({\n                type: \"text\",\n                text: part.text\n              });\n              break;\n            }\n            case \"reasoning\": {\n              if (sendReasoning) {\n                controller.enqueue({\n                  type: \"reasoning\",\n                  text: part.text,\n                  providerMetadata: part.providerMetadata\n                });\n              }\n              break;\n            }\n            case \"reasoning-part-finish\": {\n              if (sendReasoning) {\n                controller.enqueue({ type: \"reasoning-part-finish\" });\n              }\n              break;\n            }\n            case \"file\": {\n              controller.enqueue({\n                type: \"file\",\n                mediaType: part.file.mediaType,\n                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n              });\n              break;\n            }\n            case \"source\": {\n              if (sendSources) {\n                controller.enqueue({\n                  type: \"source\",\n                  sourceType: part.sourceType,\n                  id: part.id,\n                  url: part.url,\n                  title: part.title,\n                  providerMetadata: part.providerMetadata\n                });\n              }\n              break;\n            }\n            case \"tool-call-streaming-start\": {\n              controller.enqueue({\n                type: \"tool-call-streaming-start\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName\n              });\n              break;\n            }\n            case \"tool-call-delta\": {\n              controller.enqueue({\n                type: \"tool-call-delta\",\n                toolCallId: part.toolCallId,\n                argsTextDelta: part.argsTextDelta\n              });\n              break;\n            }\n            case \"tool-call\": {\n              controller.enqueue({\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                args: part.args\n              });\n              break;\n            }\n            case \"tool-result\": {\n              controller.enqueue({\n                type: \"tool-result\",\n                toolCallId: part.toolCallId,\n                result: part.result\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: \"error\",\n                errorText: onError(part.error)\n              });\n              break;\n            }\n            case \"start-step\": {\n              const metadata = messageMetadata == null ? void 0 : messageMetadata({ part });\n              controller.enqueue({\n                type: \"start-step\",\n                metadata\n              });\n              break;\n            }\n            case \"finish-step\": {\n              const metadata = messageMetadata == null ? void 0 : messageMetadata({ part });\n              controller.enqueue({\n                type: \"finish-step\",\n                metadata\n              });\n              break;\n            }\n            case \"start\": {\n              if (experimental_sendStart) {\n                const metadata = messageMetadata == null ? void 0 : messageMetadata({ part });\n                controller.enqueue({\n                  type: \"start\",\n                  messageId,\n                  metadata\n                });\n              }\n              break;\n            }\n            case \"finish\": {\n              if (experimental_sendFinish) {\n                const metadata = messageMetadata == null ? void 0 : messageMetadata({ part });\n                controller.enqueue({\n                  type: \"finish\",\n                  metadata\n                });\n              }\n              break;\n            }\n            default: {\n              const exhaustiveCheck = partType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        }\n      })\n    );\n    if (onFinish == null) {\n      return baseStream;\n    }\n    const state = createStreamingUIMessageState({\n      lastMessage,\n      newMessageId: messageId != null ? messageId : this.generateId()\n    });\n    const runUpdateMessageJob = async (job) => {\n      await job({ state, write: () => {\n      } });\n    };\n    return processUIMessageStream({\n      stream: baseStream,\n      runUpdateMessageJob\n    }).pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          controller.enqueue(chunk);\n        },\n        flush() {\n          const isContinuation2 = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n          onFinish({\n            isContinuation: isContinuation2,\n            responseMessage: state.message,\n            messages: [\n              ...isContinuation2 ? originalMessages.slice(0, -1) : originalMessages,\n              state.message\n            ]\n          });\n        }\n      })\n    );\n  }\n  pipeUIMessageStreamToResponse(response, {\n    newMessageId,\n    originalMessages,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish,\n    experimental_sendStart,\n    onError,\n    ...init\n  } = {}) {\n    pipeUIMessageStreamToResponse({\n      response,\n      stream: this.toUIMessageStream({\n        newMessageId,\n        originalMessages,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n        experimental_sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toUIMessageStreamResponse({\n    newMessageId,\n    originalMessages,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish,\n    experimental_sendStart,\n    onError,\n    ...init\n  } = {}) {\n    return createUIMessageStreamResponse({\n      stream: this.toUIMessageStream({\n        newMessageId,\n        originalMessages,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n        experimental_sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// core/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({\n  settings\n}) {\n  return {\n    middlewareVersion: \"v2\",\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params);\n    }\n  };\n}\n\n// src/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n  if (searchedText.length === 0) {\n    return null;\n  }\n  const directIndex = text2.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n  for (let i = text2.length - 1; i >= 0; i--) {\n    const suffix = text2.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n  return null;\n}\n\n// core/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({\n  tagName,\n  separator = \"\\n\",\n  startWithReasoning = false\n}) {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `</${tagName}>`;\n  return {\n    middlewareVersion: \"v2\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n      const transformedContent = [];\n      for (const part of content) {\n        if (part.type !== \"text\") {\n          transformedContent.push(part);\n          continue;\n        }\n        const text2 = startWithReasoning ? openingTag + part.text : part.text;\n        const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n        const matches = Array.from(text2.matchAll(regexp));\n        if (!matches.length) {\n          transformedContent.push(part);\n          continue;\n        }\n        const reasoningText = matches.map((match) => match[1]).join(separator);\n        let textWithoutReasoning = text2;\n        for (let i = matches.length - 1; i >= 0; i--) {\n          const match = matches[i];\n          const beforeMatch = textWithoutReasoning.slice(0, match.index);\n          const afterMatch = textWithoutReasoning.slice(\n            match.index + match[0].length\n          );\n          textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n        }\n        transformedContent.push({\n          type: \"reasoning\",\n          text: reasoningText\n        });\n        transformedContent.push({\n          type: \"text\",\n          text: textWithoutReasoning\n        });\n      }\n      return { content: transformedContent, ...rest };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      let isFirstReasoning = true;\n      let isFirstText = true;\n      let afterSwitch = false;\n      let isReasoning = startWithReasoning;\n      let buffer = \"\";\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type !== \"text\") {\n                controller.enqueue(chunk);\n                return;\n              }\n              buffer += chunk.text;\n              function publish(text2) {\n                if (text2.length > 0) {\n                  const prefix = afterSwitch && (isReasoning ? !isFirstReasoning : !isFirstText) ? separator : \"\";\n                  controller.enqueue(\n                    isReasoning ? {\n                      type: \"reasoning\",\n                      text: prefix + text2\n                    } : {\n                      type: \"text\",\n                      text: prefix + text2\n                    }\n                  );\n                  afterSwitch = false;\n                  if (isReasoning) {\n                    isFirstReasoning = false;\n                  } else {\n                    isFirstText = false;\n                  }\n                }\n              }\n              do {\n                const nextTag = isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(buffer, nextTag);\n                if (startIndex == null) {\n                  publish(buffer);\n                  buffer = \"\";\n                  break;\n                }\n                publish(buffer.slice(0, startIndex));\n                const foundFullMatch = startIndex + nextTag.length <= buffer.length;\n                if (foundFullMatch) {\n                  buffer = buffer.slice(startIndex + nextTag.length);\n                  if (isReasoning) {\n                    controller.enqueue({ type: \"reasoning-part-finish\" });\n                  }\n                  isReasoning = !isReasoning;\n                  afterSwitch = true;\n                } else {\n                  buffer = buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// core/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n  return {\n    middlewareVersion: \"v2\",\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings: result.warnings\n          });\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          for (const part of result.content) {\n            controller.enqueue(part);\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        request: result.request,\n        response: result.response\n      };\n    }\n  };\n}\n\n// core/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return asArray(middlewareArg).reverse().reduce((wrappedModel, middleware) => {\n    return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId\n}) => {\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n  return {\n    specificationVersion: \"v2\",\n    provider: providerId != null ? providerId : model.provider,\n    modelId: modelId != null ? modelId : model.modelId,\n    // TODO middleware should be able to modify the supported urls\n    get supportedUrls() {\n      return model.supportedUrls;\n    },\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        doStream,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doGenerate, doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\n\n// core/registry/custom-provider.ts\n\nfunction customProvider({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  fallbackProvider\n}) {\n  return {\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"languageModel\" });\n    },\n    textEmbeddingModel(modelId) {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"textEmbeddingModel\" });\n    },\n    imageModel(modelId) {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"imageModel\" });\n    }\n  };\n}\nvar experimental_customProvider = customProvider;\n\n// core/registry/no-such-provider-error.ts\n\nvar name16 = \"AI_NoSuchProviderError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name16, modelId, modelType, message });\n    this[_a16] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker16);\n  }\n};\n_a16 = symbol16;\n\n// core/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, {\n  separator = \":\"\n} = {}) {\n  const registry = new DefaultProviderRegistry({\n    separator\n  });\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor({ separator }) {\n    this.providers = {};\n    this.separator = separator;\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: \"languageModel\",\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(this.separator);\n    if (index === -1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n  languageModel(id) {\n    var _a17, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    const model = (_b = (_a17 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a17, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n    const provider = this.getProvider(providerId);\n    const model = (_a17 = provider.textEmbeddingModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"textEmbeddingModel\"\n      });\n    }\n    return model;\n  }\n  imageModel(id) {\n    var _a17;\n    const [providerId, modelId] = this.splitId(id, \"imageModel\");\n    const provider = this.getProvider(providerId);\n    const model = (_a17 = provider.imageModel) == null ? void 0 : _a17.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"imageModel\" });\n    }\n    return model;\n  }\n};\n\n// core/tool/mcp/mcp-client.ts\n\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/tool/mcp/mcp-sse-transport.ts\n\n\n// core/tool/mcp/json-rpc-message.ts\n\n\n// core/tool/mcp/types.ts\n\nvar LATEST_PROTOCOL_VERSION = \"2024-11-05\";\nvar SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  \"2024-10-07\"\n];\nvar ClientOrServerImplementationSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  version: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n}).passthrough();\nvar BaseParamsSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  _meta: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.object({}).passthrough())\n}).passthrough();\nvar ResultSchema = BaseParamsSchema;\nvar RequestSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  method: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  params: zod__WEBPACK_IMPORTED_MODULE_1__.optional(BaseParamsSchema)\n});\nvar ServerCapabilitiesSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  experimental: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.object({}).passthrough()),\n  logging: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.object({}).passthrough()),\n  prompts: zod__WEBPACK_IMPORTED_MODULE_1__.optional(\n    zod__WEBPACK_IMPORTED_MODULE_1__.object({\n      listChanged: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.boolean())\n    }).passthrough()\n  ),\n  resources: zod__WEBPACK_IMPORTED_MODULE_1__.optional(\n    zod__WEBPACK_IMPORTED_MODULE_1__.object({\n      subscribe: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.boolean()),\n      listChanged: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.boolean())\n    }).passthrough()\n  ),\n  tools: zod__WEBPACK_IMPORTED_MODULE_1__.optional(\n    zod__WEBPACK_IMPORTED_MODULE_1__.object({\n      listChanged: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.boolean())\n    }).passthrough()\n  )\n}).passthrough();\nvar InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.string())\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.string())\n});\nvar ToolSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  name: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  description: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.string()),\n  inputSchema: zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"object\"),\n    properties: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.object({}).passthrough())\n  }).passthrough()\n}).passthrough();\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: zod__WEBPACK_IMPORTED_MODULE_1__.array(ToolSchema)\n});\nvar TextContentSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"text\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n}).passthrough();\nvar ImageContentSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"image\"),\n  data: zod__WEBPACK_IMPORTED_MODULE_1__.string().base64(),\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n}).passthrough();\nvar ResourceContentsSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  /**\n   * The URI of this resource.\n   */\n  uri: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.string())\n}).passthrough();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: zod__WEBPACK_IMPORTED_MODULE_1__.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: zod__WEBPACK_IMPORTED_MODULE_1__.string().base64()\n});\nvar EmbeddedResourceSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_1__.literal(\"resource\"),\n  resource: zod__WEBPACK_IMPORTED_MODULE_1__.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n}).passthrough();\nvar CallToolResultSchema = ResultSchema.extend({\n  content: zod__WEBPACK_IMPORTED_MODULE_1__.array(\n    zod__WEBPACK_IMPORTED_MODULE_1__.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])\n  ),\n  isError: zod__WEBPACK_IMPORTED_MODULE_1__.boolean().default(false).optional()\n}).or(\n  ResultSchema.extend({\n    toolResult: zod__WEBPACK_IMPORTED_MODULE_1__.unknown()\n  })\n);\n\n// core/tool/mcp/json-rpc-message.ts\nvar JSONRPC_VERSION = \"2.0\";\nvar JSONRPCRequestSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  jsonrpc: zod__WEBPACK_IMPORTED_MODULE_1__.literal(JSONRPC_VERSION),\n  id: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.string(), zod__WEBPACK_IMPORTED_MODULE_1__.number().int()])\n}).merge(RequestSchema).strict();\nvar JSONRPCResponseSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  jsonrpc: zod__WEBPACK_IMPORTED_MODULE_1__.literal(JSONRPC_VERSION),\n  id: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.string(), zod__WEBPACK_IMPORTED_MODULE_1__.number().int()]),\n  result: ResultSchema\n}).strict();\nvar JSONRPCErrorSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  jsonrpc: zod__WEBPACK_IMPORTED_MODULE_1__.literal(JSONRPC_VERSION),\n  id: zod__WEBPACK_IMPORTED_MODULE_1__.union([zod__WEBPACK_IMPORTED_MODULE_1__.string(), zod__WEBPACK_IMPORTED_MODULE_1__.number().int()]),\n  error: zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    code: zod__WEBPACK_IMPORTED_MODULE_1__.number().int(),\n    message: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    data: zod__WEBPACK_IMPORTED_MODULE_1__.optional(zod__WEBPACK_IMPORTED_MODULE_1__.unknown())\n  })\n}).strict();\nvar JSONRPCNotificationSchema = zod__WEBPACK_IMPORTED_MODULE_1__.object({\n  jsonrpc: zod__WEBPACK_IMPORTED_MODULE_1__.literal(JSONRPC_VERSION)\n}).merge(\n  zod__WEBPACK_IMPORTED_MODULE_1__.object({\n    method: zod__WEBPACK_IMPORTED_MODULE_1__.string(),\n    params: zod__WEBPACK_IMPORTED_MODULE_1__.optional(BaseParamsSchema)\n  })\n).strict();\nvar JSONRPCMessageSchema = zod__WEBPACK_IMPORTED_MODULE_1__.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema\n]);\n\n// core/tool/mcp/mcp-sse-transport.ts\nvar SseMCPTransport = class {\n  constructor({\n    url,\n    headers\n  }) {\n    this.connected = false;\n    this.url = new URL(url);\n    this.headers = headers;\n  }\n  async start() {\n    return new Promise((resolve, reject) => {\n      if (this.connected) {\n        return resolve();\n      }\n      this.abortController = new AbortController();\n      const establishConnection = async () => {\n        var _a17, _b, _c;\n        try {\n          const headers = new Headers(this.headers);\n          headers.set(\"Accept\", \"text/event-stream\");\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n          });\n          if (!response.ok || !response.body) {\n            const error = new MCPClientError({\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`\n            });\n            (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n            return reject(error);\n          }\n          const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createEventSourceParserStream)());\n          const reader = stream.getReader();\n          const processEvents = async () => {\n            var _a18, _b2, _c2;\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message: \"MCP SSE Transport Error: Connection closed unexpectedly\"\n                    });\n                  }\n                  return;\n                }\n                const { event, data } = value;\n                if (event === \"endpoint\") {\n                  this.endpoint = new URL(data, this.url);\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`\n                    });\n                  }\n                  this.connected = true;\n                  resolve();\n                } else if (event === \"message\") {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data)\n                    );\n                    (_a18 = this.onmessage) == null ? void 0 : _a18.call(this, message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message: \"MCP SSE Transport Error: Failed to parse message\",\n                      cause: error\n                    });\n                    (_b2 = this.onerror) == null ? void 0 : _b2.call(this, e);\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === \"AbortError\") {\n                return;\n              }\n              (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error);\n              reject(error);\n            }\n          };\n          this.sseConnection = {\n            close: () => reader.cancel()\n          };\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === \"AbortError\") {\n            return;\n          }\n          (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n          reject(error);\n        }\n      };\n      establishConnection();\n    });\n  }\n  async close() {\n    var _a17, _b, _c;\n    this.connected = false;\n    (_a17 = this.sseConnection) == null ? void 0 : _a17.close();\n    (_b = this.abortController) == null ? void 0 : _b.abort();\n    (_c = this.onclose) == null ? void 0 : _c.call(this);\n  }\n  async send(message) {\n    var _a17, _b, _c;\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: \"MCP SSE Transport Error: Not connected\"\n      });\n    }\n    try {\n      const headers = new Headers(this.headers);\n      headers.set(\"Content-Type\", \"application/json\");\n      const init = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(message),\n        signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal\n      };\n      const response = await fetch(this.endpoint, init);\n      if (!response.ok) {\n        const text2 = await response.text().catch(() => null);\n        const error = new MCPClientError({\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text2}`\n        });\n        (_b = this.onerror) == null ? void 0 : _b.call(this, error);\n        return;\n      }\n    } catch (error) {\n      (_c = this.onerror) == null ? void 0 : _c.call(this, error);\n      return;\n    }\n  }\n};\n\n// core/tool/mcp/mcp-transport.ts\nfunction createMcpTransport(config) {\n  if (config.type !== \"sse\") {\n    throw new MCPClientError({\n      message: \"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.\"\n    });\n  }\n  return new SseMCPTransport(config);\n}\nfunction isCustomMcpTransport(transport) {\n  return \"start\" in transport && typeof transport.start === \"function\" && \"send\" in transport && typeof transport.send === \"function\" && \"close\" in transport && typeof transport.close === \"function\";\n}\n\n// core/tool/mcp/mcp-client.ts\nvar CLIENT_VERSION = \"1.0.0\";\nasync function createMCPClient(config) {\n  const client = new MCPClient(config);\n  await client.init();\n  return client;\n}\nvar MCPClient = class {\n  constructor({\n    transport: transportConfig,\n    name: name17 = \"ai-sdk-mcp-client\",\n    onUncaughtError\n  }) {\n    this.requestMessageId = 0;\n    this.responseHandlers = /* @__PURE__ */ new Map();\n    this.serverCapabilities = {};\n    this.isClosed = true;\n    this.onUncaughtError = onUncaughtError;\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error) => this.onError(error);\n    this.transport.onmessage = (message) => {\n      if (\"method\" in message) {\n        this.onError(\n          new MCPClientError({\n            message: \"Unsupported message type\"\n          })\n        );\n        return;\n      }\n      this.onResponse(message);\n    };\n    this.clientInfo = {\n      name: name17,\n      version: CLIENT_VERSION\n    };\n  }\n  async init() {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n      const result = await this.request({\n        request: {\n          method: \"initialize\",\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo\n          }\n        },\n        resultSchema: InitializeResultSchema\n      });\n      if (result === void 0) {\n        throw new MCPClientError({\n          message: \"Server sent invalid initialize result\"\n        });\n      }\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`\n        });\n      }\n      this.serverCapabilities = result.capabilities;\n      await this.notification({\n        method: \"notifications/initialized\"\n      });\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n  async close() {\n    var _a17;\n    if (this.isClosed)\n      return;\n    await ((_a17 = this.transport) == null ? void 0 : _a17.close());\n    this.onClose();\n  }\n  assertCapability(method) {\n    switch (method) {\n      case \"initialize\":\n        break;\n      case \"tools/list\":\n      case \"tools/call\":\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`\n        });\n    }\n  }\n  async request({\n    request,\n    resultSchema,\n    options\n  }) {\n    return new Promise((resolve, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: \"Attempted to send a request from a closed client\"\n          })\n        );\n      }\n      this.assertCapability(request.method);\n      const signal = options == null ? void 0 : options.signal;\n      signal == null ? void 0 : signal.throwIfAborted();\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest = {\n        ...request,\n        jsonrpc: \"2.0\",\n        id: messageId\n      };\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n      this.responseHandlers.set(messageId, (response) => {\n        if (signal == null ? void 0 : signal.aborted) {\n          return reject(\n            new MCPClientError({\n              message: \"Request was aborted\",\n              cause: signal.reason\n            })\n          );\n        }\n        if (response instanceof Error) {\n          return reject(response);\n        }\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: \"Failed to parse server response\",\n            cause: error\n          });\n          reject(parseError);\n        }\n      });\n      this.transport.send(jsonrpcRequest).catch((error) => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n  async listTools({\n    params,\n    options\n  } = {}) {\n    try {\n      return this.request({\n        request: { method: \"tools/list\", params },\n        resultSchema: ListToolsResultSchema,\n        options\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async callTool({\n    name: name17,\n    args,\n    options\n  }) {\n    try {\n      return this.request({\n        request: { method: \"tools/call\", params: { name: name17, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options == null ? void 0 : options.abortSignal\n        }\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n  async notification(notification) {\n    const jsonrpcNotification = {\n      ...notification,\n      jsonrpc: \"2.0\"\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools({\n    schemas = \"automatic\"\n  } = {}) {\n    var _a17;\n    const tools = {};\n    try {\n      const listToolsResult = await this.listTools();\n      for (const { name: name17, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== \"automatic\" && !(name17 in schemas)) {\n          continue;\n        }\n        const parameters = schemas === \"automatic\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema)({\n          ...inputSchema,\n          properties: (_a17 = inputSchema.properties) != null ? _a17 : {},\n          additionalProperties: false\n        }) : schemas[name17].parameters;\n        const self = this;\n        const toolWithExecute = tool({\n          description,\n          parameters,\n          execute: async (args, options) => {\n            var _a18;\n            (_a18 = options == null ? void 0 : options.abortSignal) == null ? void 0 : _a18.throwIfAborted();\n            return self.callTool({\n              name: name17,\n              args,\n              options\n            });\n          }\n        });\n        tools[name17] = toolWithExecute;\n      }\n      return tools;\n    } catch (error) {\n      throw error;\n    }\n  }\n  onClose() {\n    if (this.isClosed)\n      return;\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: \"Connection closed\"\n    });\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n    this.responseHandlers.clear();\n  }\n  onError(error) {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n  onResponse(response) {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n    if (handler === void 0) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response\n        )}`\n      });\n    }\n    this.responseHandlers.delete(messageId);\n    handler(\n      \"result\" in response ? response : new MCPClientError({\n        message: response.error.message,\n        cause: response.error\n      })\n    );\n  }\n};\n\n// src/error/no-transcript-generated-error.ts\n\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_NoTranscriptGeneratedError\",\n      message: \"No transcript generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// core/transcribe/transcribe.ts\nasync function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const audioData = audio instanceof URL ? (await download({ url: audio })).data : convertDataContentToUint8Array(audio);\n  const result = await retry(\n    () => {\n      var _a17;\n      return model.doGenerate({\n        audio: audioData,\n        abortSignal,\n        headers,\n        providerOptions,\n        mediaType: (_a17 = detectMediaType({\n          data: audioData,\n          signatures: audioMediaTypeSignatures\n        })) != null ? _a17 : \"audio/wav\"\n      });\n    }\n  );\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultTranscriptionResult = class {\n  constructor(options) {\n    var _a17;\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yc2Mvbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0NBQW9DO0FBQ3BFOztBQUVBO0FBTWdDOztBQUVoQztBQWEwQjs7QUFFMUI7QUFDOEM7QUFDOUM7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0EseUNBQXlDLHdEQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpREFBaUQsVUFBVSxJQUFJLFFBQVE7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBVztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDOEU7QUFDOUU7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0EsOENBQThDLHdEQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVMsSUFBSSxpRUFBZTtBQUN4RTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0gsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVc7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQzZEO0FBQzdEO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBLG1DQUFtQyx3REFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVc7QUFDdEQ7QUFDQSxnQkFBZ0IsbUNBQW1DLElBQUk7QUFDdkQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBVztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDNkQ7QUFDN0Q7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0Esb0NBQW9DLHdEQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTLEtBQUssNEVBQTRFLDBCQUEwQixHQUFHO0FBQzlLLEdBQUc7QUFDSCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBVztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDa0c7QUFDbEc7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0Esd0NBQXdDLHdEQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpRUFBZ0IsUUFBUTtBQUNwRSxHQUFHO0FBQ0gsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRztBQUNuRztBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSx1Q0FBdUMsd0RBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTLElBQUksaUVBQWdCLFFBQVE7QUFDM0UsR0FBRztBQUNILFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVk7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQzhEO0FBQzlEO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBLDRDQUE0Qyx3REFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsZUFBZTtBQUM1SCxHQUFHO0FBQ0gsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSw0Q0FBNEMsd0RBQVk7QUFDeEQ7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDLEdBQUc7QUFDSCxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVk7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQzhEO0FBQzlEO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBLDJDQUEyQyx3REFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSxrQ0FBa0Msd0RBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJLElBQUksWUFBWSxFQUFFLFdBQVcsMEJBQTBCLElBQUksSUFBSSxNQUFNO0FBQzdILEdBQUc7QUFDSCxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBWTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdnQzs7QUFFaEM7QUFDd0I7QUFDeEIsZ0NBQWdDLHNDQUFPO0FBQ3ZDLEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLFVBQVUsdUNBQVE7QUFDbEIsR0FBRztBQUNILEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLGVBQWUsdUNBQVE7QUFDdkIsR0FBRztBQUNILEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLGdCQUFnQix1Q0FBUTtBQUN4QixjQUFjLHVDQUFRO0FBQ3RCLEdBQUc7QUFDSCxFQUFFLHVDQUFRO0FBQ1YsVUFBVSx3Q0FBUztBQUNuQixnQkFBZ0IsdUNBQVE7QUFDeEIsbUJBQW1CLHVDQUFRO0FBQzNCLEdBQUc7QUFDSCxFQUFFLHVDQUFRO0FBQ1YsVUFBVSx3Q0FBUztBQUNuQixnQkFBZ0IsdUNBQVE7QUFDeEIsY0FBYyx1Q0FBUTtBQUN0QixVQUFVLHdDQUFTO0FBQ25CLEdBQUc7QUFDSCxFQUFFLHVDQUFRO0FBQ1YsVUFBVSx3Q0FBUztBQUNuQixnQkFBZ0IsdUNBQVE7QUFDeEIsWUFBWSx3Q0FBUztBQUNyQixzQkFBc0Isb0NBQUs7QUFDM0IsR0FBRztBQUNILEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLFVBQVUsdUNBQVE7QUFDbEIsc0JBQXNCLHVDQUFRLENBQUMsb0NBQUs7QUFDcEMsR0FBRztBQUNILEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLGdCQUFnQix3Q0FBUztBQUN6QixRQUFRLHVDQUFRO0FBQ2hCLFNBQVMsdUNBQVE7QUFDakIsV0FBVyx1Q0FBUTtBQUNuQixzQkFBc0Isb0NBQUs7QUFDM0I7QUFDQSxHQUFHO0FBQ0gsRUFBRSx1Q0FBUTtBQUNWLFVBQVUsd0NBQVM7QUFDbkIsU0FBUyx1Q0FBUTtBQUNqQixlQUFlLHVDQUFRO0FBQ3ZCLEdBQUc7QUFDSCxFQUFFLHVDQUFRO0FBQ1YsVUFBVSx1Q0FBUTtBQUNsQixRQUFRLHVDQUFRO0FBQ2hCLFVBQVUsd0NBQVM7QUFDbkIsR0FBRztBQUNILEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLFdBQVcsdUNBQVEsR0FBRyxVQUFVLHdDQUFTLElBQUk7QUFDN0MsR0FBRztBQUNILEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLGNBQWMsd0NBQVM7QUFDdkIsR0FBRztBQUNILEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLGNBQWMsd0NBQVM7QUFDdkIsR0FBRztBQUNILEVBQUUsdUNBQVE7QUFDVixVQUFVLHdDQUFTO0FBQ25CLGVBQWUsdUNBQVE7QUFDdkIsY0FBYyx3Q0FBUztBQUN2QixHQUFHO0FBQ0gsRUFBRSx1Q0FBUTtBQUNWLFVBQVUsd0NBQVM7QUFDbkIsY0FBYyx3Q0FBUztBQUN2QixHQUFHO0FBQ0gsRUFBRSx1Q0FBUTtBQUNWLFVBQVUsd0NBQVM7QUFDbkIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ3VEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsOERBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUEwQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDaUY7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDOEQ7QUFDOUQsK0NBQStDLHdEQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSxRQUFRLG1CQUFtQiwyQkFBMkI7QUFDaEUsNkRBQTZELFlBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEyRkU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsaWtob1xcT25lRHJpdmVcXEdpdEh1YlxcQXBleFxcbm9kZV9tb2R1bGVzXFxAYWktc2RrXFxyc2NcXG5vZGVfbW9kdWxlc1xcYWlcXGRpc3RcXGluZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUxNyBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZTE3LCB7IGdldDogYWxsW25hbWUxN10sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGFzU2NoZW1hIGFzIGFzU2NoZW1hNSxcbiAgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3I1LFxuICBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWQyLFxuICBqc29uU2NoZW1hIGFzIGpzb25TY2hlbWEyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9lcnJvci9pbmRleC50c1xuaW1wb3J0IHtcbiAgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTYsXG4gIEFQSUNhbGxFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC1hcmd1bWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZSA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZSxcbiAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGFyZ3VtZW50IGZvciBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJ9OiAke21lc3NhZ2V9YFxuICAgIH0pO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcblxuLy8gc3JjL2Vycm9yL2ludmFsaWQtc3RyZWFtLXBhcnQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9JbnZhbGlkU3RyZWFtUGFydEVycm9yXCI7XG52YXIgbWFya2VyMiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMn1gO1xudmFyIHN5bWJvbDIgPSBTeW1ib2wuZm9yKG1hcmtlcjIpO1xudmFyIF9hMjtcbnZhciBJbnZhbGlkU3RyZWFtUGFydEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaHVuayxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC10b29sLWFyZ3VtZW50cy1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMywgZ2V0RXJyb3JNZXNzYWdlIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTN9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbEFyZ3MsXG4gICAgdG9vbE5hbWUsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UoXG4gICAgICBjYXVzZVxuICAgICl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xBcmdzID0gdG9vbEFyZ3M7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbn07XG5fYTMgPSBzeW1ib2wzO1xuXG4vLyBzcmMvZXJyb3IvbWNwLWNsaWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTQgPSBcIkFJX01DUENsaWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBNQ1BDbGllbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZTogbmFtZTE3ID0gXCJNQ1BDbGllbnRFcnJvclwiLFxuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE3LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3Ivbm8taW1hZ2UtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I1IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNSA9IFwiQUlfTm9JbWFnZUdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBOb0ltYWdlR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I1IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIGltYWdlIGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICByZXNwb25zZXNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E1XSA9IHRydWU7XG4gICAgdGhpcy5yZXNwb25zZXMgPSByZXNwb25zZXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvci9uby1vYmplY3QtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I2IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNiA9IFwiQUlfTm9PYmplY3RHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjYge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gb2JqZWN0IGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICB0ZXh0OiB0ZXh0MixcbiAgICByZXNwb25zZSxcbiAgICB1c2FnZSxcbiAgICBmaW5pc2hSZWFzb25cbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTYsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E2XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDI7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvbjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNi5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjYpO1xuICB9XG59O1xuX2E2ID0gc3ltYm9sNjtcblxuLy8gc3JjL2Vycm9yL25vLW91dHB1dC1zcGVjaWZpZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU3ID0gXCJBSV9Ob091dHB1dFNwZWNpZmllZEVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBOb091dHB1dFNwZWNpZmllZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNyB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSBcIk5vIG91dHB1dCBzcGVjaWZpZWQuXCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I3Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3Ivbm8tc3VjaC10b29sLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I4IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lOCA9IFwiQUlfTm9TdWNoVG9vbEVycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDggPSBTeW1ib2wuZm9yKG1hcmtlcjgpO1xudmFyIF9hODtcbnZhciBOb1N1Y2hUb29sRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I4IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xOYW1lLFxuICAgIGF2YWlsYWJsZVRvb2xzID0gdm9pZCAwLFxuICAgIG1lc3NhZ2UgPSBgTW9kZWwgdHJpZWQgdG8gY2FsbCB1bmF2YWlsYWJsZSB0b29sICcke3Rvb2xOYW1lfScuICR7YXZhaWxhYmxlVG9vbHMgPT09IHZvaWQgMCA/IFwiTm8gdG9vbHMgYXJlIGF2YWlsYWJsZS5cIiA6IGBBdmFpbGFibGUgdG9vbHM6ICR7YXZhaWxhYmxlVG9vbHMuam9pbihcIiwgXCIpfS5gfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTgsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGVUb29scyA9IGF2YWlsYWJsZVRvb2xzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I4Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3IvdG9vbC1jYWxsLXJlcGFpci1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOSwgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU5ID0gXCJBSV9Ub29sQ2FsbFJlcGFpckVycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBUb29sQ2FsbFJlcGFpckVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYXVzZSxcbiAgICBvcmlnaW5hbEVycm9yLFxuICAgIG1lc3NhZ2UgPSBgRXJyb3IgcmVwYWlyaW5nIHRvb2wgY2FsbDogJHtnZXRFcnJvck1lc3NhZ2UyKGNhdXNlKX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvci90b29sLWV4ZWN1dGlvbi1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAsIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTAgPSBcIkFJX1Rvb2xFeGVjdXRpb25FcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBUb29sRXhlY3V0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sQXJncyxcbiAgICB0b29sTmFtZSxcbiAgICB0b29sQ2FsbElkLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlMyhjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTAsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy50b29sQ2FsbElkID0gdG9vbENhbGxJZDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTAuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIGNvcmUvcHJvbXB0L2ludmFsaWQtZGF0YS1jb250ZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTExID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMX1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjExIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTExLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1tZXNzYWdlLXJvbGUtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjEyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTIgPSBcIkFJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIEludmFsaWRNZXNzYWdlUm9sZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm9sZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbWVzc2FnZSByb2xlOiAnJHtyb2xlfScuIE11c3QgYmUgb25lIG9mOiBcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCIuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTEyXSA9IHRydWU7XG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIGNvcmUvcHJvbXB0L21lc3NhZ2UtY29udmVyc2lvbi1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMyA9IFwiQUlfTWVzc2FnZUNvbnZlcnNpb25FcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxM31gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBNZXNzYWdlQ29udmVyc2lvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3JpZ2luYWxNZXNzYWdlLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTEzLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEzKTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcblxuLy8gc3JjL3V0aWwvZG93bmxvYWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTQgPSBcIkFJX0Rvd25sb2FkRXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTR9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgRG93bmxvYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGNhdXNlID09IG51bGwgPyBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtzdGF0dXNDb2RlfSAke3N0YXR1c1RleHR9YCA6IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke2NhdXNlfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE0LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTRdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjE0Lmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvdXRpbC9yZXRyeS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNSA9IFwiQUlfUmV0cnlFcnJvclwiO1xudmFyIG1hcmtlcjE1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNX1gO1xudmFyIHN5bWJvbDE1ID0gU3ltYm9sLmZvcihtYXJrZXIxNSk7XG52YXIgX2ExNTtcbnZhciBSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yMTUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICByZWFzb24sXG4gICAgZXJyb3JzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTVdID0gdHJ1ZTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjE1Lmhhc01hcmtlcihlcnJvciwgbWFya2VyMTUpO1xuICB9XG59O1xuX2ExNSA9IHN5bWJvbDE1O1xuXG4vLyBzcmMvdXRpbC9wcmVwYXJlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIGRlZmF1bHRIZWFkZXJzKSB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlZmF1bHRIZWFkZXJzKSkge1xuICAgIGlmICghcmVzcG9uc2VIZWFkZXJzLmhhcyhrZXkpKSB7XG4gICAgICByZXNwb25zZUhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzcG9uc2VIZWFkZXJzO1xufVxuXG4vLyBzcmMvdGV4dC1zdHJlYW0vY3JlYXRlLXRleHQtc3RyZWFtLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHRleHRTdHJlYW1cbn0pIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgIHN0YXR1czogc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICBcImNvbnRlbnQtdHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgIH0pXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbC93cml0ZS10by1zZXJ2ZXItcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbVxufSkge1xuICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDAsIHN0YXR1c1RleHQsIGhlYWRlcnMpO1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNwb25zZS5lbmQoKTtcbiAgICB9XG4gIH07XG4gIHJlYWQoKTtcbn1cblxuLy8gc3JjL3RleHQtc3RyZWFtL3BpcGUtdGV4dC1zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHRleHRTdHJlYW1cbn0pIHtcbiAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICByZXNwb25zZSxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICAgIFwiY29udGVudC10eXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KS5lbnRyaWVzKClcbiAgICApLFxuICAgIHN0cmVhbTogdGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSlcbiAgfSk7XG59XG5cbi8vIHNyYy91aS9hcHBlbmQtY2xpZW50LW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGFwcGVuZENsaWVudE1lc3NhZ2Uoe1xuICBtZXNzYWdlcyxcbiAgbWVzc2FnZVxufSkge1xuICByZXR1cm4gW1xuICAgIC4uLm1lc3NhZ2VzLmxlbmd0aCA+IDAgJiYgbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0uaWQgPT09IG1lc3NhZ2UuaWQgPyBtZXNzYWdlcy5zbGljZSgwLCAtMSkgOiBtZXNzYWdlcyxcbiAgICBtZXNzYWdlXG4gIF07XG59XG5cbi8vIHNyYy91aS9jYWxsLWNoYXQtYXBpLnRzXG5pbXBvcnQge1xuICBwYXJzZUpzb25FdmVudFN0cmVhbVxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vdWktbWVzc2FnZS1zdHJlYW0tcGFydHMudHNcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG52YXIgdWlNZXNzYWdlU3RyZWFtUGFydFNjaGVtYSA9IHoudW5pb24oW1xuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5saXRlcmFsKFwidGV4dFwiKSxcbiAgICB0ZXh0OiB6LnN0cmluZygpXG4gIH0pLFxuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5saXRlcmFsKFwiZXJyb3JcIiksXG4gICAgZXJyb3JUZXh0OiB6LnN0cmluZygpXG4gIH0pLFxuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5saXRlcmFsKFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiKSxcbiAgICB0b29sQ2FsbElkOiB6LnN0cmluZygpLFxuICAgIHRvb2xOYW1lOiB6LnN0cmluZygpXG4gIH0pLFxuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5saXRlcmFsKFwidG9vbC1jYWxsLWRlbHRhXCIpLFxuICAgIHRvb2xDYWxsSWQ6IHouc3RyaW5nKCksXG4gICAgYXJnc1RleHREZWx0YTogei5zdHJpbmcoKVxuICB9KSxcbiAgei5vYmplY3Qoe1xuICAgIHR5cGU6IHoubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgICB0b29sQ2FsbElkOiB6LnN0cmluZygpLFxuICAgIHRvb2xOYW1lOiB6LnN0cmluZygpLFxuICAgIGFyZ3M6IHoudW5rbm93bigpXG4gIH0pLFxuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5saXRlcmFsKFwidG9vbC1yZXN1bHRcIiksXG4gICAgdG9vbENhbGxJZDogei5zdHJpbmcoKSxcbiAgICByZXN1bHQ6IHoudW5rbm93bigpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHouYW55KCkub3B0aW9uYWwoKVxuICB9KSxcbiAgei5vYmplY3Qoe1xuICAgIHR5cGU6IHoubGl0ZXJhbChcInJlYXNvbmluZ1wiKSxcbiAgICB0ZXh0OiB6LnN0cmluZygpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHoucmVjb3JkKHouYW55KCkpLm9wdGlvbmFsKClcbiAgfSksXG4gIHoub2JqZWN0KHtcbiAgICB0eXBlOiB6LmxpdGVyYWwoXCJzb3VyY2VcIiksXG4gICAgc291cmNlVHlwZTogei5saXRlcmFsKFwidXJsXCIpLFxuICAgIGlkOiB6LnN0cmluZygpLFxuICAgIHVybDogei5zdHJpbmcoKSxcbiAgICB0aXRsZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHouYW55KCkub3B0aW9uYWwoKVxuICAgIC8vIFVzZSB6LmFueSgpIGZvciBnZW5lcmljIG1ldGFkYXRhXG4gIH0pLFxuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5saXRlcmFsKFwiZmlsZVwiKSxcbiAgICB1cmw6IHouc3RyaW5nKCksXG4gICAgbWVkaWFUeXBlOiB6LnN0cmluZygpXG4gIH0pLFxuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5zdHJpbmcoKS5zdGFydHNXaXRoKFwiZGF0YS1cIiksXG4gICAgaWQ6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBkYXRhOiB6LnVua25vd24oKVxuICB9KSxcbiAgei5vYmplY3Qoe1xuICAgIHR5cGU6IHoubGl0ZXJhbChcIm1ldGFkYXRhXCIpLFxuICAgIHZhbHVlOiB6Lm9iamVjdCh7IG1ldGFkYXRhOiB6LnVua25vd24oKSB9KVxuICB9KSxcbiAgei5vYmplY3Qoe1xuICAgIHR5cGU6IHoubGl0ZXJhbChcInN0YXJ0LXN0ZXBcIiksXG4gICAgbWV0YWRhdGE6IHoudW5rbm93bigpLm9wdGlvbmFsKClcbiAgfSksXG4gIHoub2JqZWN0KHtcbiAgICB0eXBlOiB6LmxpdGVyYWwoXCJmaW5pc2gtc3RlcFwiKSxcbiAgICBtZXRhZGF0YTogei51bmtub3duKCkub3B0aW9uYWwoKVxuICB9KSxcbiAgei5vYmplY3Qoe1xuICAgIHR5cGU6IHoubGl0ZXJhbChcInN0YXJ0XCIpLFxuICAgIG1lc3NhZ2VJZDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIG1ldGFkYXRhOiB6LnVua25vd24oKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5saXRlcmFsKFwiZmluaXNoXCIpLFxuICAgIG1ldGFkYXRhOiB6LnVua25vd24oKS5vcHRpb25hbCgpXG4gIH0pLFxuICB6Lm9iamVjdCh7XG4gICAgdHlwZTogei5saXRlcmFsKFwicmVhc29uaW5nLXBhcnQtZmluaXNoXCIpXG4gIH0pXG5dKTtcblxuLy8gc3JjL3V0aWwvY29uc3VtZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uRXJyb3Jcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbi8vIHNyYy91aS9wcm9jZXNzLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5pbXBvcnQgeyB2YWxpZGF0ZVR5cGVzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvbWVyZ2Utb2JqZWN0cy50c1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKGJhc2UsIG92ZXJyaWRlcykge1xuICBpZiAoYmFzZSA9PT0gdm9pZCAwICYmIG92ZXJyaWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlcztcbiAgfVxuICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB7IC4uLmJhc2UgfTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3ZlcnJpZGVzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdmVycmlkZXMsIGtleSkpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlc1ZhbHVlID0gb3ZlcnJpZGVzW2tleV07XG4gICAgICBpZiAob3ZlcnJpZGVzVmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBrZXkgaW4gYmFzZSA/IGJhc2Vba2V5XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGlzU291cmNlT2JqZWN0ID0gb3ZlcnJpZGVzVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIG92ZXJyaWRlc1ZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KG92ZXJyaWRlc1ZhbHVlKSAmJiAhKG92ZXJyaWRlc1ZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgIShvdmVycmlkZXNWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICBjb25zdCBpc1RhcmdldE9iamVjdCA9IGJhc2VWYWx1ZSAhPT0gbnVsbCAmJiBiYXNlVmFsdWUgIT09IHZvaWQgMCAmJiB0eXBlb2YgYmFzZVZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGJhc2VWYWx1ZSkgJiYgIShiYXNlVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKGJhc2VWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICBpZiAoaXNTb3VyY2VPYmplY3QgJiYgaXNUYXJnZXRPYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9iamVjdHMoXG4gICAgICAgICAgYmFzZVZhbHVlLFxuICAgICAgICAgIG92ZXJyaWRlc1ZhbHVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IG92ZXJyaWRlc1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXRpbC9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9maXgtanNvbi50c1xuZnVuY3Rpb24gZml4SnNvbihpbnB1dCkge1xuICBjb25zdCBzdGFjayA9IFtcIlJPT1RcIl07XG4gIGxldCBsYXN0VmFsaWRJbmRleCA9IC0xO1xuICBsZXQgbGl0ZXJhbFN0YXJ0ID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgc3dhcFN0YXRlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9TVFJJTkdcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgY2FzZSBcIm5cIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBsaXRlcmFsU3RhcnQgPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0xJVEVSQUxcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX05VTUJFUlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX05VTUJFUlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwie1wiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiW1wiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGlucHV0W2ldO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHN3aXRjaCAoY3VycmVudFN0YXRlKSB7XG4gICAgICBjYXNlIFwiUk9PVFwiOlxuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIkZJTklTSFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIjpcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjoge1xuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR1wiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjoge1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9TVFJJTkdfRVNDQVBFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR19FU0NBUEVcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTlVNQkVSXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgIGNhc2UgXCIuXCI6IHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaSArIDEpO1xuICAgICAgICBpZiAoIVwiZmFsc2VcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgcmVzdWx0ID0gaW5wdXQuc2xpY2UoMCwgbGFzdFZhbGlkSW5kZXggKyAxKTtcbiAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdGFja1tpXTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR1wiOiB7XG4gICAgICAgIHJlc3VsdCArPSAnXCInO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJ9XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIGlmIChcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcInRydWVcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZmFsc2VcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcImZhbHNlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcIm51bGxcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihqc29uVGV4dCkge1xuICBpZiAoanNvblRleHQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcInVuZGVmaW5lZC1pbnB1dFwiIH07XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiBqc29uVGV4dCB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwic3VjY2Vzc2Z1bC1wYXJzZVwiIH07XG4gIH1cbiAgcmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTih7IHRleHQ6IGZpeEpzb24oanNvblRleHQpIH0pO1xuICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBzdGF0ZTogXCJyZXBhaXJlZC1wYXJzZVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwiZmFpbGVkLXBhcnNlXCIgfTtcbn1cblxuLy8gc3JjL3VpL2V4dHJhY3QtbWF4LXRvb2wtaW52b2NhdGlvbi1zdGVwLnRzXG5mdW5jdGlvbiBleHRyYWN0TWF4VG9vbEludm9jYXRpb25TdGVwKHRvb2xJbnZvY2F0aW9ucykge1xuICByZXR1cm4gdG9vbEludm9jYXRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0b29sSW52b2NhdGlvbnMucmVkdWNlKChtYXgsIHRvb2xJbnZvY2F0aW9uKSA9PiB7XG4gICAgdmFyIF9hMTc7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgKF9hMTcgPSB0b29sSW52b2NhdGlvbi5zdGVwKSAhPSBudWxsID8gX2ExNyA6IDApO1xuICB9LCAwKTtcbn1cblxuLy8gc3JjL3VpL2dldC10b29sLWludm9jYXRpb25zLnRzXG5mdW5jdGlvbiBnZXRUb29sSW52b2NhdGlvbnMobWVzc2FnZSkge1xuICByZXR1cm4gbWVzc2FnZS5wYXJ0cy5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIlxuICApLm1hcCgocGFydCkgPT4gcGFydC50b29sSW52b2NhdGlvbik7XG59XG5cbi8vIHNyYy91aS9wcm9jZXNzLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gIGxhc3RNZXNzYWdlLFxuICBuZXdNZXNzYWdlSWQgPSBcIm5vLWlkXCJcbn0gPSB7fSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgaXNDb250aW51YXRpb24gPSAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpID09PSBcImFzc2lzdGFudFwiO1xuICBjb25zdCBzdGVwID0gaXNDb250aW51YXRpb24gPyAxICsgKChfYTE3ID0gZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcChnZXRUb29sSW52b2NhdGlvbnMobGFzdE1lc3NhZ2UpKSkgIT0gbnVsbCA/IF9hMTcgOiAwKSA6IDA7XG4gIGNvbnN0IG1lc3NhZ2UgPSBpc0NvbnRpbnVhdGlvbiA/IHN0cnVjdHVyZWRDbG9uZShsYXN0TWVzc2FnZSkgOiB7XG4gICAgaWQ6IG5ld01lc3NhZ2VJZCxcbiAgICBtZXRhZGF0YToge30sXG4gICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICBwYXJ0czogW11cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlLFxuICAgIGFjdGl2ZVRleHRQYXJ0OiB2b2lkIDAsXG4gICAgYWN0aXZlUmVhc29uaW5nUGFydDogdm9pZCAwLFxuICAgIHBhcnRpYWxUb29sQ2FsbHM6IHt9LFxuICAgIHN0ZXBcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uVG9vbENhbGwsXG4gIG1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgcnVuVXBkYXRlTWVzc2FnZUpvYlxufSkge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKHBhcnQsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgYXdhaXQgcnVuVXBkYXRlTWVzc2FnZUpvYihhc3luYyAoeyBzdGF0ZSwgd3JpdGUgfSkgPT4ge1xuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydCh0b29sQ2FsbElkLCBpbnZvY2F0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0MiA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgKHBhcnQzKSA9PiBwYXJ0My50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiICYmIHBhcnQzLnRvb2xJbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocGFydDIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJ0Mi50b29sSW52b2NhdGlvbiA9IGludm9jYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgICAgICAgICAgICAgdG9vbEludm9jYXRpb246IGludm9jYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkTWV0YWRhdGEgPSBzdGF0ZS5tZXNzYWdlLm1ldGFkYXRhICE9IG51bGwgPyBtZXJnZU9iamVjdHMoc3RhdGUubWVzc2FnZS5tZXRhZGF0YSwgbWV0YWRhdGEpIDogbWV0YWRhdGE7XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlTWV0YWRhdGFTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lcmdlZE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hOiBtZXNzYWdlTWV0YWRhdGFTY2hlbWFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLm1ldGFkYXRhID0gbWVyZ2VkTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5hY3RpdmVUZXh0UGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlVGV4dFBhcnQgPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHN0YXRlLmFjdGl2ZVRleHRQYXJ0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0UGFydC50ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydCA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaChzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0LnRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YSA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctcGFydC1maW5pc2hcIjoge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHVybDogcGFydC51cmxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNvdXJjZVwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAgIHVybDogcGFydC51cmwsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogcGFydC50aXRsZSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbnMgPSBnZXRUb29sSW52b2NhdGlvbnMoc3RhdGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgIHN0YXRlLnBhcnRpYWxUb29sQ2FsbHNbcGFydC50b29sQ2FsbElkXSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRvb2xJbnZvY2F0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHBhcnQudG9vbENhbGxJZCwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBcInBhcnRpYWwtY2FsbFwiLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHZvaWQgMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFRvb2xDYWxsID0gc3RhdGUucGFydGlhbFRvb2xDYWxsc1twYXJ0LnRvb2xDYWxsSWRdO1xuICAgICAgICAgICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dCArPSBwYXJ0LmFyZ3NUZXh0RGVsdGE7XG4gICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IHBhcnRpYWxBcmdzIH0gPSBhd2FpdCBwYXJzZVBhcnRpYWxKc29uKFxuICAgICAgICAgICAgICAgIHBhcnRpYWxUb29sQ2FsbC50ZXh0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydChwYXJ0LnRvb2xDYWxsSWQsIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwYXJ0aWFsLWNhbGxcIixcbiAgICAgICAgICAgICAgICBzdGVwOiBwYXJ0aWFsVG9vbENhbGwuc3RlcCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnRpYWxUb29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJ0aWFsQXJnc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHBhcnQudG9vbENhbGxJZCwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICBzdGVwOiBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJ0LmFyZ3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGlmIChvblRvb2xDYWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb25Ub29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbDogcGFydFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHBhcnQudG9vbENhbGxJZCwge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJyZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogcGFydC5hcmdzLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbnMgPSBnZXRUb29sSW52b2NhdGlvbnMoc3RhdGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgIGlmICh0b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvb2xfcmVzdWx0IG11c3QgYmUgcHJlY2VkZWQgYnkgYSB0b29sX2NhbGxcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb25JbmRleCA9IHRvb2xJbnZvY2F0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgKGludm9jYXRpb24pID0+IGludm9jYXRpb24udG9vbENhbGxJZCA9PT0gcGFydC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh0b29sSW52b2NhdGlvbkluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwidG9vbF9yZXN1bHQgbXVzdCBiZSBwcmVjZWRlZCBieSBhIHRvb2xfY2FsbCB3aXRoIHRoZSBzYW1lIHRvb2xDYWxsSWRcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHBhcnQudG9vbENhbGxJZCwge1xuICAgICAgICAgICAgICAgIC4uLnRvb2xJbnZvY2F0aW9uc1t0b29sSW52b2NhdGlvbkluZGV4XSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJyZXN1bHRcIixcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHBhcnQucmVzdWx0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHsgdHlwZTogXCJzdGVwLXN0YXJ0XCIgfSk7XG4gICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShwYXJ0Lm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoLXN0ZXBcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5zdGVwICs9IDE7XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHRQYXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEocGFydC5tZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0Lm1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgaWYgKHBhcnQubWVzc2FnZUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLmlkID0gcGFydC5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlTWVzc2FnZU1ldGFkYXRhKHBhcnQubWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAocGFydC5tZXNzYWdlSWQgIT0gbnVsbCB8fCBwYXJ0Lm1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShwYXJ0Lm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnQubWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEocGFydC5tZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0Lm1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnQuZXJyb3JUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgaWYgKHBhcnQudHlwZS5zdGFydHNXaXRoKFwiZGF0YS1cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1BhcnQgPSBwYXJ0LmlkICE9IG51bGwgPyBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAgICAgICAgICAgICAocGFydEFyZykgPT4gcGFydC50eXBlID09PSBwYXJ0QXJnLnR5cGUgJiYgcGFydC5pZCA9PT0gcGFydEFyZy5pZFxuICAgICAgICAgICAgICAgICkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBleGlzdGluZ1BhcnQudmFsdWUgPSBtZXJnZU9iamVjdHMoXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUGFydC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0LmRhdGFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJ0LmRhdGFcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpL3RyYW5zZm9ybS10ZXh0LXRvLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW1cbn0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydFwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInN0YXJ0LXN0ZXBcIiB9KTtcbiAgICAgIH0sXG4gICAgICBhc3luYyB0cmFuc2Zvcm0ocGFydCwgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHRcIiwgdGV4dDogcGFydCB9KTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZmluaXNoLXN0ZXBcIiB9KTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJmaW5pc2hcIiB9KTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWkvY2FsbC1jaGF0LWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBmZXRjaDtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVUlNZXNzYWdlU3RyZWFtKHtcbiAgYXBpLFxuICBib2R5LFxuICBzdHJlYW1Qcm90b2NvbCA9IFwidWktbWVzc2FnZVwiLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYWJvcnRDb250cm9sbGVyLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaCgpLFxuICByZXF1ZXN0VHlwZSA9IFwiZ2VuZXJhdGVcIlxufSkge1xuICB2YXIgX2ExNywgX2IsIF9jO1xuICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3RUeXBlID09PSBcInJlc3VtZVwiID8gYXdhaXQgZmV0Y2gyKGAke2FwaX0/Y2hhdElkPSR7Ym9keS5pZH1gLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH0sXG4gICAgc2lnbmFsOiAoX2ExNyA9IGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnNpZ25hbCxcbiAgICBjcmVkZW50aWFsc1xuICB9KSA6IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH0sXG4gICAgc2lnbmFsOiAoX2IgPSBhYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzXG4gIH0pO1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKF9jID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2MgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIHJldHVybiBzdHJlYW1Qcm90b2NvbCA9PT0gXCJ0ZXh0XCIgPyB0cmFuc2Zvcm1UZXh0VG9VaU1lc3NhZ2VTdHJlYW0oe1xuICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSlcbiAgfSkgOiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgIHNjaGVtYTogdWlNZXNzYWdlU3RyZWFtUGFydFNjaGVtYVxuICB9KS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShwYXJ0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICghcGFydC5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgcGFydC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVVSU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uVXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgb25Ub29sQ2FsbCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gIGxhc3RNZXNzYWdlLFxuICBtZXNzYWdlTWV0YWRhdGFTY2hlbWFcbn0pIHtcbiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gICAgbGFzdE1lc3NhZ2UsXG4gICAgbmV3TWVzc2FnZUlkOiBnZW5lcmF0ZUlkMygpXG4gIH0pO1xuICBjb25zdCBydW5VcGRhdGVNZXNzYWdlSm9iID0gYXN5bmMgKGpvYikgPT4ge1xuICAgIGF3YWl0IGpvYih7XG4gICAgICBzdGF0ZSxcbiAgICAgIHdyaXRlOiAoKSA9PiB7XG4gICAgICAgIG9uVXBkYXRlKHsgbWVzc2FnZTogc3RhdGUubWVzc2FnZSB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgc3RyZWFtOiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgICAgIHN0cmVhbSxcbiAgICAgIG9uVG9vbENhbGwsXG4gICAgICBtZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gICAgICBydW5VcGRhdGVNZXNzYWdlSm9iXG4gICAgfSksXG4gICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xuICBvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goeyBtZXNzYWdlOiBzdGF0ZS5tZXNzYWdlIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbENoYXRBcGkoe1xuICBhcGksXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJ1aS1tZXNzYWdlXCIsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIG9uVXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgb25Ub29sQ2FsbCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoKCksXG4gIGxhc3RNZXNzYWdlLFxuICByZXF1ZXN0VHlwZSA9IFwiZ2VuZXJhdGVcIixcbiAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hXG59KSB7XG4gIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGZldGNoVUlNZXNzYWdlU3RyZWFtKHtcbiAgICBhcGksXG4gICAgYm9keSxcbiAgICBzdHJlYW1Qcm90b2NvbCxcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGFib3J0Q29udHJvbGxlcixcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHJlcXVlc3RUeXBlXG4gIH0pO1xuICBhd2FpdCBjb25zdW1lVUlNZXNzYWdlU3RyZWFtKHtcbiAgICBzdHJlYW0sXG4gICAgb25VcGRhdGUsXG4gICAgb25GaW5pc2gsXG4gICAgb25Ub29sQ2FsbCxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBsYXN0TWVzc2FnZSxcbiAgICBtZXNzYWdlTWV0YWRhdGFTY2hlbWFcbiAgfSk7XG59XG5cbi8vIHNyYy91aS9jYWxsLWNvbXBsZXRpb24tYXBpLnRzXG5pbXBvcnQgeyBwYXJzZUpzb25FdmVudFN0cmVhbSBhcyBwYXJzZUpzb25FdmVudFN0cmVhbTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvcHJvY2Vzcy10ZXh0LXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1RleHRTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uVGV4dFBhcnRcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYXdhaXQgb25UZXh0UGFydCh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gc3JjL3VpL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoMiA9ICgpID0+IGZldGNoO1xuYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaDIoKVxufSkge1xuICB2YXIgX2ExNztcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuICAgIHNldENvbXBsZXRpb24oXCJcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgKF9hMTcgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfYTE3IDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBzd2l0Y2ggKHN0cmVhbVByb3RvY29sKSB7XG4gICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3NUZXh0U3RyZWFtKHtcbiAgICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgb25UZXh0UGFydDogKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2h1bms7XG4gICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGF0YVwiOiB7XG4gICAgICAgIGF3YWl0IGNvbnN1bWVTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcGFyc2VKc29uRXZlbnRTdHJlYW0yKHtcbiAgICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICAgIHNjaGVtYTogdWlNZXNzYWdlU3RyZWFtUGFydFNjaGVtYVxuICAgICAgICAgIH0pLnBpcGVUaHJvdWdoKFxuICAgICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICAgIGFzeW5jIHRyYW5zZm9ybShwYXJ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IHBhcnQuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbVBhcnQgPSBwYXJ0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW1QYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyZWFtUGFydC50ZXh0O1xuICAgICAgICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtUGFydC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJlYW1QYXJ0LmVycm9yVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvdWkvY2hhdC1zdG9yZS50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuY1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9zZXJpYWwtam9iLWV4ZWN1dG9yLnRzXG52YXIgU2VyaWFsSm9iRXhlY3V0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMucXVldWVbMF0oKTtcbiAgICAgIHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICB9XG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBydW4oam9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgam9iKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdm9pZCB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdWkvc2hvdWxkLXJlc3VibWl0LW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBzaG91bGRSZXN1Ym1pdE1lc3NhZ2VzKHtcbiAgb3JpZ2luYWxNYXhUb29sSW52b2NhdGlvblN0ZXAsXG4gIG9yaWdpbmFsTWVzc2FnZUNvdW50LFxuICBtYXhTdGVwczogbWF4U3RlcHMyLFxuICBtZXNzYWdlc1xufSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIChcbiAgICAvLyBjaGVjayBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkOlxuICAgIG1heFN0ZXBzMiA+IDEgJiYgLy8gZW5zdXJlIHRoZXJlIGlzIGEgbGFzdCBtZXNzYWdlOlxuICAgIGxhc3RNZXNzYWdlICE9IG51bGwgJiYgLy8gZW5zdXJlIHdlIGFjdHVhbGx5IGhhdmUgbmV3IHN0ZXBzICh0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIGluIGNhc2Ugb2YgZXJyb3JzKTpcbiAgICAobWVzc2FnZXMubGVuZ3RoID4gb3JpZ2luYWxNZXNzYWdlQ291bnQgfHwgZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcChnZXRUb29sSW52b2NhdGlvbnMobGFzdE1lc3NhZ2UpKSAhPT0gb3JpZ2luYWxNYXhUb29sSW52b2NhdGlvblN0ZXApICYmIC8vIGNoZWNrIHRoYXQgbmV4dCBzdGVwIGlzIHBvc3NpYmxlOlxuICAgIGlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMobGFzdE1lc3NhZ2UpICYmIC8vIGxpbWl0IHRoZSBudW1iZXIgb2YgYXV0b21hdGljIHN0ZXBzOlxuICAgICgoX2ExNyA9IGV4dHJhY3RNYXhUb29sSW52b2NhdGlvblN0ZXAoZ2V0VG9vbEludm9jYXRpb25zKGxhc3RNZXNzYWdlKSkpICE9IG51bGwgPyBfYTE3IDogMCkgPCBtYXhTdGVwczJcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMobWVzc2FnZSkge1xuICBpZiAobWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxhc3RTdGVwU3RhcnRJbmRleCA9IG1lc3NhZ2UucGFydHMucmVkdWNlKChsYXN0SW5kZXgsIHBhcnQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJzdGVwLXN0YXJ0XCIgPyBpbmRleCA6IGxhc3RJbmRleDtcbiAgfSwgLTEpO1xuICBjb25zdCBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucyA9IG1lc3NhZ2UucGFydHMuc2xpY2UobGFzdFN0ZXBTdGFydEluZGV4ICsgMSkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIpO1xuICByZXR1cm4gbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMubGVuZ3RoID4gMCAmJiBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucy5ldmVyeSgocGFydCkgPT4gXCJyZXN1bHRcIiBpbiBwYXJ0LnRvb2xJbnZvY2F0aW9uKTtcbn1cblxuLy8gc3JjL3VpL3VwZGF0ZS10b29sLWNhbGwtcmVzdWx0LnRzXG5mdW5jdGlvbiB1cGRhdGVUb29sQ2FsbFJlc3VsdCh7XG4gIG1lc3NhZ2VzLFxuICB0b29sQ2FsbElkLFxuICB0b29sUmVzdWx0OiByZXN1bHRcbn0pIHtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgaW52b2NhdGlvblBhcnQgPSBsYXN0TWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIgJiYgcGFydC50b29sSW52b2NhdGlvbi50b29sQ2FsbElkID09PSB0b29sQ2FsbElkXG4gICk7XG4gIGlmIChpbnZvY2F0aW9uUGFydCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGludm9jYXRpb25QYXJ0LnRvb2xJbnZvY2F0aW9uID0ge1xuICAgIC4uLmludm9jYXRpb25QYXJ0LnRvb2xJbnZvY2F0aW9uLFxuICAgIHN0YXRlOiBcInJlc3VsdFwiLFxuICAgIHJlc3VsdFxuICB9O1xufVxuXG4vLyBzcmMvdWkvY2hhdC1zdG9yZS50c1xudmFyIENoYXRTdG9yZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNoYXRzID0ge30sXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgbWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICAgIHRyYW5zcG9ydCxcbiAgICBtYXhTdGVwczogbWF4U3RlcHMyID0gMVxuICB9KSB7XG4gICAgdGhpcy5jaGF0cyA9IG5ldyBNYXAoXG4gICAgICBPYmplY3QuZW50cmllcyhjaGF0cykubWFwKChbaWQsIHN0YXRlXSkgPT4gW1xuICAgICAgICBpZCxcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2VzOiBbLi4uc3RhdGUubWVzc2FnZXNdLFxuICAgICAgICAgIHN0YXR1czogXCJyZWFkeVwiLFxuICAgICAgICAgIGFjdGl2ZVJlc3BvbnNlOiB2b2lkIDAsXG4gICAgICAgICAgZXJyb3I6IHZvaWQgMCxcbiAgICAgICAgICBqb2JFeGVjdXRvcjogbmV3IFNlcmlhbEpvYkV4ZWN1dG9yKClcbiAgICAgICAgfVxuICAgICAgXSlcbiAgICApO1xuICAgIHRoaXMubWF4U3RlcHMgPSBtYXhTdGVwczI7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5nZW5lcmF0ZUlkID0gZ2VuZXJhdGVJZDMgIT0gbnVsbCA/IGdlbmVyYXRlSWQzIDogZ2VuZXJhdGVJZEZ1bmM7XG4gICAgdGhpcy5tZXNzYWdlTWV0YWRhdGFTY2hlbWEgPSBtZXNzYWdlTWV0YWRhdGFTY2hlbWE7XG4gIH1cbiAgaGFzQ2hhdChpZCkge1xuICAgIHJldHVybiB0aGlzLmNoYXRzLmhhcyhpZCk7XG4gIH1cbiAgYWRkQ2hhdChpZCwgbWVzc2FnZXMpIHtcbiAgICB0aGlzLmNoYXRzLnNldChpZCwge1xuICAgICAgbWVzc2FnZXMsXG4gICAgICBzdGF0dXM6IFwicmVhZHlcIixcbiAgICAgIGpvYkV4ZWN1dG9yOiBuZXcgU2VyaWFsSm9iRXhlY3V0b3IoKVxuICAgIH0pO1xuICB9XG4gIGdldENoYXRzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hhdHMuZW50cmllcygpKTtcbiAgfVxuICBnZXQgY2hhdENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXRzLnNpemU7XG4gIH1cbiAgZ2V0U3RhdHVzKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhdChpZCkuc3RhdHVzO1xuICB9XG4gIHNldFN0YXR1cyh7XG4gICAgaWQsXG4gICAgc3RhdHVzLFxuICAgIGVycm9yXG4gIH0pIHtcbiAgICBjb25zdCBjaGF0ID0gdGhpcy5nZXRDaGF0KGlkKTtcbiAgICBpZiAoY2hhdC5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIHJldHVybjtcbiAgICBjaGF0LnN0YXR1cyA9IHN0YXR1cztcbiAgICBjaGF0LmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5lbWl0KHsgdHlwZTogXCJjaGF0LXN0YXR1cy1jaGFuZ2VkXCIsIGNoYXRJZDogaWQsIGVycm9yIH0pO1xuICB9XG4gIGdldEVycm9yKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhdChpZCkuZXJyb3I7XG4gIH1cbiAgZ2V0TWVzc2FnZXMoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGF0KGlkKS5tZXNzYWdlcztcbiAgfVxuICBnZXRMYXN0TWVzc2FnZShpZCkge1xuICAgIGNvbnN0IGNoYXQgPSB0aGlzLmdldENoYXQoaWQpO1xuICAgIHJldHVybiBjaGF0Lm1lc3NhZ2VzW2NoYXQubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG4gIH1cbiAgc2V0TWVzc2FnZXMoe1xuICAgIGlkLFxuICAgIG1lc3NhZ2VzXG4gIH0pIHtcbiAgICB0aGlzLmdldENoYXQoaWQpLm1lc3NhZ2VzID0gWy4uLm1lc3NhZ2VzXTtcbiAgICB0aGlzLmVtaXQoeyB0eXBlOiBcImNoYXQtbWVzc2FnZXMtY2hhbmdlZFwiLCBjaGF0SWQ6IGlkIH0pO1xuICB9XG4gIHJlbW92ZUFzc2lzdGFudFJlc3BvbnNlKGlkKSB7XG4gICAgY29uc3QgY2hhdCA9IHRoaXMuZ2V0Q2hhdChpZCk7XG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBjaGF0Lm1lc3NhZ2VzW2NoYXQubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RNZXNzYWdlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgYXNzaXN0YW50IHJlc3BvbnNlIGZyb20gZW1wdHkgY2hhdFwiKTtcbiAgICB9XG4gICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhc3QgbWVzc2FnZSBpcyBub3QgYW4gYXNzaXN0YW50IG1lc3NhZ2VcIik7XG4gICAgfVxuICAgIHRoaXMuc2V0TWVzc2FnZXMoeyBpZCwgbWVzc2FnZXM6IGNoYXQubWVzc2FnZXMuc2xpY2UoMCwgLTEpIH0pO1xuICB9XG4gIGFzeW5jIHN1Ym1pdE1lc3NhZ2Uoe1xuICAgIGNoYXRJZCxcbiAgICBtZXNzYWdlLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBvbkVycm9yLFxuICAgIG9uVG9vbENhbGwsXG4gICAgb25GaW5pc2hcbiAgfSkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IGNoYXQgPSB0aGlzLmdldENoYXQoY2hhdElkKTtcbiAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBjaGF0Lm1lc3NhZ2VzO1xuICAgIGF3YWl0IHRoaXMudHJpZ2dlclJlcXVlc3Qoe1xuICAgICAgY2hhdElkLFxuICAgICAgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcy5jb25jYXQoe1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBpZDogKF9hMTcgPSBtZXNzYWdlLmlkKSAhPSBudWxsID8gX2ExNyA6IHRoaXMuZ2VuZXJhdGVJZCgpXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgICAgcmVxdWVzdFR5cGU6IFwiZ2VuZXJhdGVcIixcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvblRvb2xDYWxsLFxuICAgICAgb25GaW5pc2hcbiAgICB9KTtcbiAgfVxuICBhc3luYyByZXN1Ym1pdExhc3RVc2VyTWVzc2FnZSh7XG4gICAgY2hhdElkLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBvbkVycm9yLFxuICAgIG9uVG9vbENhbGwsXG4gICAgb25GaW5pc2hcbiAgfSkge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5nZXRDaGF0KGNoYXRJZCkubWVzc2FnZXM7XG4gICAgY29uc3QgbWVzc2FnZXNUb1N1Ym1pdCA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgPyBtZXNzYWdlcy5zbGljZSgwLCAtMSkgOiBtZXNzYWdlcztcbiAgICBpZiAobWVzc2FnZXNUb1N1Ym1pdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlclJlcXVlc3Qoe1xuICAgICAgY2hhdElkLFxuICAgICAgcmVxdWVzdFR5cGU6IFwiZ2VuZXJhdGVcIixcbiAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1RvU3VibWl0LFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgICBvbkVycm9yLFxuICAgICAgb25Ub29sQ2FsbCxcbiAgICAgIG9uRmluaXNoXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcmVzdW1lU3RyZWFtKHtcbiAgICBjaGF0SWQsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICAgIG9uRXJyb3IsXG4gICAgb25Ub29sQ2FsbCxcbiAgICBvbkZpbmlzaFxuICB9KSB7XG4gICAgY29uc3QgY2hhdCA9IHRoaXMuZ2V0Q2hhdChjaGF0SWQpO1xuICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlcyA9IGNoYXQubWVzc2FnZXM7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlclJlcXVlc3Qoe1xuICAgICAgY2hhdElkLFxuICAgICAgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyxcbiAgICAgIHJlcXVlc3RUeXBlOiBcInJlc3VtZVwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgICBvbkVycm9yLFxuICAgICAgb25Ub29sQ2FsbCxcbiAgICAgIG9uRmluaXNoXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYWRkVG9vbFJlc3VsdCh7XG4gICAgY2hhdElkLFxuICAgIHRvb2xDYWxsSWQsXG4gICAgcmVzdWx0XG4gIH0pIHtcbiAgICBjb25zdCBjaGF0ID0gdGhpcy5nZXRDaGF0KGNoYXRJZCk7XG4gICAgY2hhdC5qb2JFeGVjdXRvci5ydW4oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudE1lc3NhZ2VzID0gY2hhdC5tZXNzYWdlcztcbiAgICAgIHVwZGF0ZVRvb2xDYWxsUmVzdWx0KHtcbiAgICAgICAgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyxcbiAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgdG9vbFJlc3VsdDogcmVzdWx0XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0TWVzc2FnZXMoeyBpZDogY2hhdElkLCBtZXNzYWdlczogY3VycmVudE1lc3NhZ2VzIH0pO1xuICAgICAgaWYgKGNoYXQuc3RhdHVzID09PSBcInN1Ym1pdHRlZFwiIHx8IGNoYXQuc3RhdHVzID09PSBcInN0cmVhbWluZ1wiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gY3VycmVudE1lc3NhZ2VzW2N1cnJlbnRNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzKGxhc3RNZXNzYWdlKSkge1xuICAgICAgICBhd2FpdCB0aGlzLnRyaWdnZXJSZXF1ZXN0KHtcbiAgICAgICAgICBtZXNzYWdlczogY3VycmVudE1lc3NhZ2VzLFxuICAgICAgICAgIHJlcXVlc3RUeXBlOiBcImdlbmVyYXRlXCIsXG4gICAgICAgICAgY2hhdElkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHN0b3BTdHJlYW0oeyBjaGF0SWQgfSkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IGNoYXQgPSB0aGlzLmdldENoYXQoY2hhdElkKTtcbiAgICBpZiAoY2hhdC5zdGF0dXMgIT09IFwic3RyZWFtaW5nXCIgJiYgY2hhdC5zdGF0dXMgIT09IFwic3VibWl0dGVkXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKChfYTE3ID0gY2hhdC5hY3RpdmVSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBjaGF0LmFjdGl2ZVJlc3BvbnNlLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgY2hhdC5hY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IHN1YnNjcmliZXIgb2YgdGhpcy5zdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlci5vbkNoYXRDaGFuZ2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2hhdChpZCkge1xuICAgIGlmICghdGhpcy5oYXNDaGF0KGlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjaGF0ICcke2lkfScgbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoYXRzLmdldChpZCk7XG4gIH1cbiAgYXN5bmMgdHJpZ2dlclJlcXVlc3Qoe1xuICAgIGNoYXRJZCxcbiAgICBtZXNzYWdlczogY2hhdE1lc3NhZ2VzLFxuICAgIHJlcXVlc3RUeXBlLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBvbkVycm9yLFxuICAgIG9uVG9vbENhbGwsXG4gICAgb25GaW5pc2hcbiAgfSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGNoYXQgPSB0aGlzLmdldENoYXQoY2hhdElkKTtcbiAgICB0aGlzLnNldE1lc3NhZ2VzKHsgaWQ6IGNoYXRJZCwgbWVzc2FnZXM6IGNoYXRNZXNzYWdlcyB9KTtcbiAgICB0aGlzLnNldFN0YXR1cyh7IGlkOiBjaGF0SWQsIHN0YXR1czogXCJzdWJtaXR0ZWRcIiwgZXJyb3I6IHZvaWQgMCB9KTtcbiAgICBjb25zdCBtZXNzYWdlQ291bnQgPSBjaGF0TWVzc2FnZXMubGVuZ3RoO1xuICAgIGNvbnN0IG1heFN0ZXAgPSBleHRyYWN0TWF4VG9vbEludm9jYXRpb25TdGVwKFxuICAgICAgZ2V0VG9vbEludm9jYXRpb25zKGNoYXRNZXNzYWdlc1tjaGF0TWVzc2FnZXMubGVuZ3RoIC0gMV0pXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWN0aXZlUmVzcG9uc2UgPSB7XG4gICAgICAgIHN0YXRlOiBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gICAgICAgICAgbGFzdE1lc3NhZ2U6IGNoYXRNZXNzYWdlc1tjaGF0TWVzc2FnZXMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgbmV3TWVzc2FnZUlkOiBzZWxmLmdlbmVyYXRlSWQoKVxuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnRDb250cm9sbGVyOiBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgIH07XG4gICAgICBjaGF0LmFjdGl2ZVJlc3BvbnNlID0gYWN0aXZlUmVzcG9uc2U7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBzZWxmLnRyYW5zcG9ydC5zdWJtaXRNZXNzYWdlcyh7XG4gICAgICAgIGNoYXRJZCxcbiAgICAgICAgbWVzc2FnZXM6IGNoYXRNZXNzYWdlcyxcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYWJvcnRDb250cm9sbGVyOiBhY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIHJlcXVlc3RUeXBlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJ1blVwZGF0ZU1lc3NhZ2VKb2IgPSAoam9iKSA9PiAoXG4gICAgICAgIC8vIHNlcmlhbGl6ZSB0aGUgam9iIGV4ZWN1dGlvbiB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnM6XG4gICAgICAgIGNoYXQuam9iRXhlY3V0b3IucnVuKFxuICAgICAgICAgICgpID0+IGpvYih7XG4gICAgICAgICAgICBzdGF0ZTogYWN0aXZlUmVzcG9uc2Uuc3RhdGUsXG4gICAgICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICBzZWxmLnNldFN0YXR1cyh7IGlkOiBjaGF0SWQsIHN0YXR1czogXCJzdHJlYW1pbmdcIiB9KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUxhc3RNZXNzYWdlID0gYWN0aXZlUmVzcG9uc2Uuc3RhdGUubWVzc2FnZS5pZCA9PT0gY2hhdE1lc3NhZ2VzW2NoYXRNZXNzYWdlcy5sZW5ndGggLSAxXS5pZDtcbiAgICAgICAgICAgICAgY29uc3QgbmV3TWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgLi4ucmVwbGFjZUxhc3RNZXNzYWdlID8gY2hhdE1lc3NhZ2VzLnNsaWNlKDAsIGNoYXRNZXNzYWdlcy5sZW5ndGggLSAxKSA6IGNoYXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIHNlbGYuc2V0TWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgIGlkOiBjaGF0SWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IG5ld01lc3NhZ2VzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiBwcm9jZXNzVUlNZXNzYWdlU3RyZWFtKHtcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgb25Ub29sQ2FsbCxcbiAgICAgICAgICBtZXNzYWdlTWV0YWRhdGFTY2hlbWE6IHNlbGYubWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICAgICAgICAgIHJ1blVwZGF0ZU1lc3NhZ2VKb2JcbiAgICAgICAgfSksXG4gICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7IG1lc3NhZ2U6IGFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UgfSk7XG4gICAgICB0aGlzLnNldFN0YXR1cyh7IGlkOiBjaGF0SWQsIHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh7IGlkOiBjaGF0SWQsIHN0YXR1czogXCJyZWFkeVwiIH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChvbkVycm9yICYmIGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdHVzKHsgaWQ6IGNoYXRJZCwgc3RhdHVzOiBcImVycm9yXCIsIGVycm9yOiBlcnIgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNoYXQuYWN0aXZlUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRNZXNzYWdlcyA9IHNlbGYuZ2V0TWVzc2FnZXMoY2hhdElkKTtcbiAgICBpZiAoc2hvdWxkUmVzdWJtaXRNZXNzYWdlcyh7XG4gICAgICBvcmlnaW5hbE1heFRvb2xJbnZvY2F0aW9uU3RlcDogbWF4U3RlcCxcbiAgICAgIG9yaWdpbmFsTWVzc2FnZUNvdW50OiBtZXNzYWdlQ291bnQsXG4gICAgICBtYXhTdGVwczogc2VsZi5tYXhTdGVwcyxcbiAgICAgIG1lc3NhZ2VzOiBjdXJyZW50TWVzc2FnZXNcbiAgICB9KSkge1xuICAgICAgYXdhaXQgc2VsZi50cmlnZ2VyUmVxdWVzdCh7XG4gICAgICAgIGNoYXRJZCxcbiAgICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uVG9vbENhbGwsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5LFxuICAgICAgICBtZXNzYWdlczogY3VycmVudE1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91aS9jaGF0LXRyYW5zcG9ydC50c1xudmFyIERlZmF1bHRDaGF0VHJhbnNwb3J0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYXBpLFxuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBzdHJlYW1Qcm90b2NvbCxcbiAgICBmZXRjaDogZmV0Y2gyLFxuICAgIHByZXBhcmVSZXF1ZXN0Qm9keVxuICB9KSB7XG4gICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnN0cmVhbVByb3RvY29sID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgdGhpcy5mZXRjaCA9IGZldGNoMjtcbiAgICB0aGlzLnByZXBhcmVSZXF1ZXN0Qm9keSA9IHByZXBhcmVSZXF1ZXN0Qm9keTtcbiAgfVxuICBzdWJtaXRNZXNzYWdlcyh7XG4gICAgY2hhdElkLFxuICAgIG1lc3NhZ2VzLFxuICAgIGFib3J0Q29udHJvbGxlcixcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcmVxdWVzdFR5cGVcbiAgfSkge1xuICAgIHZhciBfYTE3LCBfYjtcbiAgICByZXR1cm4gZmV0Y2hVSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgYm9keTogKF9iID0gKF9hMTcgPSB0aGlzLnByZXBhcmVSZXF1ZXN0Qm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2FsbCh0aGlzLCB7XG4gICAgICAgIGlkOiBjaGF0SWQsXG4gICAgICAgIC8vIFRPRE8gY2hhbmdlIHRvIGNoYXRJZFxuICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgLi4udGhpcy5ib2R5LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9KSkgIT0gbnVsbCA/IF9iIDoge1xuICAgICAgICBpZDogY2hhdElkLFxuICAgICAgICAvLyBUT0RPIGNoYW5nZSB0byBjaGF0SWRcbiAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgIC4uLnRoaXMuYm9keSxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSxcbiAgICAgIHN0cmVhbVByb3RvY29sOiB0aGlzLnN0cmVhbVByb3RvY29sLFxuICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHMsXG4gICAgICBhYm9ydENvbnRyb2xsZXI6ICgpID0+IGFib3J0Q29udHJvbGxlcixcbiAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgcmVxdWVzdFR5cGVcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3VpL2NvbnZlcnQtZmlsZS1saXN0LXRvLWZpbGUtdWktcGFydHMudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRGaWxlTGlzdFRvRmlsZVVJUGFydHMoZmlsZXMpIHtcbiAgaWYgKGZpbGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFnbG9iYWxUaGlzLkZpbGVMaXN0IHx8ICEoZmlsZXMgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbGVMaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGVMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIEFycmF5LmZyb20oZmlsZXMpLm1hcChhc3luYyAoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgeyBuYW1lOiBuYW1lMTcsIHR5cGUgfSA9IGZpbGU7XG4gICAgICBjb25zdCBkYXRhVXJsID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKHJlYWRlckV2ZW50KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTc7XG4gICAgICAgICAgcmVzb2x2ZSgoX2ExNyA9IHJlYWRlckV2ZW50LnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHJlamVjdChlcnJvcik7XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgbWVkaWFUeXBlOiB0eXBlLFxuICAgICAgICBmaWxlbmFtZTogbmFtZTE3LFxuICAgICAgICB1cmw6IGRhdGFVcmxcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpL2NvbnZlcnQtdG8tbW9kZWwtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb01vZGVsTWVzc2FnZXMobWVzc2FnZXMsIG9wdGlvbnMpIHtcbiAgdmFyIF9hMTcsIF9iO1xuICBjb25zdCB0b29scyA9IChfYTE3ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50b29scykgIT0gbnVsbCA/IF9hMTcgOiB7fTtcbiAgY29uc3QgbW9kZWxNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLnBhcnRzLm1hcCgocGFydCkgPT4gcGFydC50eXBlID09PSBcInRleHRcIiA/IHBhcnQudGV4dCA6IFwiXCIpLmpvaW4oXCJcIilcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICAgICAgICAgICkubWFwKFxuICAgICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJmaWxlXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgZGF0YTogcGFydC51cmxcbiAgICAgICAgICAgIH0gOiBwYXJ0XG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydHMgIT0gbnVsbCkge1xuICAgICAgICAgIGxldCBwcm9jZXNzQmxvY2syID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQudXJsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWludm9jYXRpb25cIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbEludm9jYXRpb24udG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbEludm9jYXRpb24udG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnQudG9vbEludm9jYXRpb24uYXJnc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcGFydDtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGVwSW52b2NhdGlvbnMgPSBibG9jay5maWx0ZXIoXG4gICAgICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCJcbiAgICAgICAgICAgICkubWFwKChwYXJ0KSA9PiBwYXJ0LnRvb2xJbnZvY2F0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdGVwSW52b2NhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBtb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0ZXBJbnZvY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICAgICAodG9vbEludm9jYXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoXCJyZXN1bHRcIiBpbiB0b29sSW52b2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRvb2xJbnZvY2F0aW9uIG11c3QgaGF2ZSBhIHJlc3VsdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0b29sSW52b2NhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCByZXN1bHQgfSA9IHRvb2xJbnZvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZW50OiB0b29sMi5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrID0gW107XG4gICAgICAgICAgICBibG9ja0hhc1Rvb2xJbnZvY2F0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgY3VycmVudFN0ZXArKztcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBwcm9jZXNzQmxvY2sgPSBwcm9jZXNzQmxvY2syO1xuICAgICAgICAgIGxldCBjdXJyZW50U3RlcCA9IDA7XG4gICAgICAgICAgbGV0IGJsb2NrSGFzVG9vbEludm9jYXRpb25zID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGJsb2NrID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UucGFydHMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tIYXNUb29sSW52b2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NCbG9jazIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICBibG9jay5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWludm9jYXRpb25cIjoge1xuICAgICAgICAgICAgICAgIGlmICgoKF9iID0gcGFydC50b29sSW52b2NhdGlvbi5zdGVwKSAhPSBudWxsID8gX2IgOiAwKSAhPT0gY3VycmVudFN0ZXApIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NCbG9jazIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2sucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBibG9ja0hhc1Rvb2xJbnZvY2F0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0Jsb2NrMigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbWVzc2FnZS5yb2xlO1xuICAgICAgICB0aHJvdyBuZXcgTWVzc2FnZUNvbnZlcnNpb25FcnJvcih7XG4gICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCByb2xlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGVsTWVzc2FnZXM7XG59XG52YXIgY29udmVydFRvQ29yZU1lc3NhZ2VzID0gY29udmVydFRvTW9kZWxNZXNzYWdlcztcblxuLy8gc3JjL3VpL2RlZmF1bHQtY2hhdC1zdG9yZS50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYzJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIGRlZmF1bHRDaGF0U3RvcmUoe1xuICBhcGksXG4gIGZldGNoOiBmZXRjaDIsXG4gIHN0cmVhbVByb3RvY29sID0gXCJ1aS1tZXNzYWdlXCIsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBwcmVwYXJlUmVxdWVzdEJvZHksXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gZ2VuZXJhdGVJZEZ1bmMyLFxuICBtZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gIG1heFN0ZXBzOiBtYXhTdGVwczIgPSAxLFxuICBjaGF0c1xufSkge1xuICByZXR1cm4gbmV3IENoYXRTdG9yZSh7XG4gICAgdHJhbnNwb3J0OiBuZXcgRGVmYXVsdENoYXRUcmFuc3BvcnQoe1xuICAgICAgYXBpLFxuICAgICAgZmV0Y2g6IGZldGNoMixcbiAgICAgIHN0cmVhbVByb3RvY29sLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICAgIHByZXBhcmVSZXF1ZXN0Qm9keVxuICAgIH0pLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzLFxuICAgIG1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgICBtYXhTdGVwczogbWF4U3RlcHMyLFxuICAgIGNoYXRzXG4gIH0pO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vY3JlYXRlLXVpLW1lc3NhZ2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW0oe1xuICBleGVjdXRlLFxuICBvbkVycm9yID0gKCkgPT4gXCJBbiBlcnJvciBvY2N1cnJlZC5cIlxuICAvLyBtYXNrIGVycm9yIG1lc3NhZ2VzIGZvciBzYWZldHkgYnkgZGVmYXVsdFxufSkge1xuICBsZXQgY29udHJvbGxlcjtcbiAgY29uc3Qgb25nb2luZ1N0cmVhbVByb21pc2VzID0gW107XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlckFyZykge1xuICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJBcmc7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gc2FmZUVucXVldWUoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlKHtcbiAgICAgIHdyaXRlKHBhcnQpIHtcbiAgICAgICAgc2FmZUVucXVldWUocGFydCk7XG4gICAgICB9LFxuICAgICAgbWVyZ2Uoc3RyZWFtQXJnKSB7XG4gICAgICAgIG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5wdXNoKFxuICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW1BcmcuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgc2FmZUVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBzYWZlRW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3JUZXh0OiBvbkVycm9yKGVycm9yKSB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3JcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBvbmdvaW5nU3RyZWFtUHJvbWlzZXMucHVzaChcbiAgICAgICAgcmVzdWx0LmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIHNhZmVFbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvclRleHQ6IG9uRXJyb3IoZXJyb3IpIH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgc2FmZUVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yVGV4dDogb25FcnJvcihlcnJvcikgfSk7XG4gIH1cbiAgY29uc3Qgd2FpdEZvclN0cmVhbXMgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgIHdoaWxlIChvbmdvaW5nU3RyZWFtUHJvbWlzZXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgb25nb2luZ1N0cmVhbVByb21pc2VzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHJlc29sdmUoKTtcbiAgfSk7XG4gIHdhaXRGb3JTdHJlYW1zLmZpbmFsbHkoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vdWktbWVzc2FnZS1zdHJlYW0taGVhZGVycy50c1xudmFyIHVpTWVzc2FnZVN0cmVhbUhlYWRlcnMgPSB7XG4gIFwiY29udGVudC10eXBlXCI6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgXCJjYWNoZS1jb250cm9sXCI6IFwibm8tY2FjaGVcIixcbiAgY29ubmVjdGlvbjogXCJrZWVwLWFsaXZlXCIsXG4gIFwieC12ZXJjZWwtYWktdWktbWVzc2FnZS1zdHJlYW1cIjogXCJ2MVwiLFxuICBcIngtYWNjZWwtYnVmZmVyaW5nXCI6IFwibm9cIlxuICAvLyBkaXNhYmxlIG5naW54IGJ1ZmZlcmluZ1xufTtcblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2pzb24tdG8tc3NlLXRyYW5zZm9ybS1zdHJlYW0udHNcbnZhciBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0gPSBjbGFzcyBleHRlbmRzIFRyYW5zZm9ybVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHRyYW5zZm9ybShwYXJ0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShgZGF0YTogJHtKU09OLnN0cmluZ2lmeShwYXJ0KX1cblxuYCk7XG4gICAgICB9LFxuICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXCJkYXRhOiBbRE9ORV1cXG5cXG5cIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9jcmVhdGUtdWktbWVzc2FnZS1zdHJlYW0tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKHtcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW1cbn0pIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICBzdHJlYW0ucGlwZVRocm91Z2gobmV3IEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSgpKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksXG4gICAge1xuICAgICAgc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHVpTWVzc2FnZVN0cmVhbUhlYWRlcnMpXG4gICAgfVxuICApO1xufVxuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vcGlwZS11aS1tZXNzYWdlLXN0cmVhbS10by1yZXNwb25zZS50c1xuZnVuY3Rpb24gcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICByZXNwb25zZSxcbiAgc3RhdHVzLFxuICBzdGF0dXNUZXh0LFxuICBoZWFkZXJzLFxuICBzdHJlYW1cbn0pIHtcbiAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICByZXNwb25zZSxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB1aU1lc3NhZ2VTdHJlYW1IZWFkZXJzKS5lbnRyaWVzKClcbiAgICApLFxuICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0oKSkucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbC9kYXRhLXVybC50c1xuZnVuY3Rpb24gZ2V0VGV4dEZyb21EYXRhVXJsKGRhdGFVcmwpIHtcbiAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgbWVkaWFUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtZWRpYVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihiYXNlNjRDb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY29kaW5nIGRhdGEgVVJMYCk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy91dGlsL2Nvc2luZS1zaW1pbGFyaXR5LnRzXG5mdW5jdGlvbiBjb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwidmVjdG9yMSx2ZWN0b3IyXCIsXG4gICAgICB2YWx1ZTogeyB2ZWN0b3IxTGVuZ3RoOiB2ZWN0b3IxLmxlbmd0aCwgdmVjdG9yMkxlbmd0aDogdmVjdG9yMi5sZW5ndGggfSxcbiAgICAgIG1lc3NhZ2U6IGBWZWN0b3JzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhgXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbiA9IHZlY3RvcjEubGVuZ3RoO1xuICBpZiAobiA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBtYWduaXR1ZGVTcXVhcmVkMSA9IDA7XG4gIGxldCBtYWduaXR1ZGVTcXVhcmVkMiA9IDA7XG4gIGxldCBkb3RQcm9kdWN0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZTEgPSB2ZWN0b3IxW2ldO1xuICAgIGNvbnN0IHZhbHVlMiA9IHZlY3RvcjJbaV07XG4gICAgbWFnbml0dWRlU3F1YXJlZDEgKz0gdmFsdWUxICogdmFsdWUxO1xuICAgIG1hZ25pdHVkZVNxdWFyZWQyICs9IHZhbHVlMiAqIHZhbHVlMjtcbiAgICBkb3RQcm9kdWN0ICs9IHZhbHVlMSAqIHZhbHVlMjtcbiAgfVxuICByZXR1cm4gbWFnbml0dWRlU3F1YXJlZDEgPT09IDAgfHwgbWFnbml0dWRlU3F1YXJlZDIgPT09IDAgPyAwIDogZG90UHJvZHVjdCAvIChNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZDEpICogTWF0aC5zcXJ0KG1hZ25pdHVkZVNxdWFyZWQyKSk7XG59XG5cbi8vIHNyYy91dGlsL3NpbXVsYXRlLXJlYWRhYmxlLXN0cmVhbS50c1xuaW1wb3J0IHsgZGVsYXkgYXMgZGVsYXlGdW5jdGlvbiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBzaW11bGF0ZVJlYWRhYmxlU3RyZWFtKHtcbiAgY2h1bmtzLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMCxcbiAgY2h1bmtEZWxheUluTXMgPSAwLFxuICBfaW50ZXJuYWxcbn0pIHtcbiAgdmFyIF9hMTc7XG4gIGNvbnN0IGRlbGF5MiA9IChfYTE3ID0gX2ludGVybmFsID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJuYWwuZGVsYXkpICE9IG51bGwgPyBfYTE3IDogZGVsYXlGdW5jdGlvbjtcbiAgbGV0IGluZGV4ID0gMDtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoaW5kZXggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IGRlbGF5MihpbmRleCA9PT0gMCA/IGluaXRpYWxEZWxheUluTXMgOiBjaHVua0RlbGF5SW5Ncyk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVua3NbaW5kZXgrK10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZGVsYXksIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U0LCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMlxufSA9IHt9KSA9PiBhc3luYyAoZikgPT4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSk7XG5hc3luYyBmdW5jdGlvbiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTQoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbC9wcmVwYXJlLXJldHJpZXMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXRyaWVzKHtcbiAgbWF4UmV0cmllc1xufSkge1xuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgPj0gMFwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF4UmV0cmllc1Jlc3VsdCA9IG1heFJldHJpZXMgIT0gbnVsbCA/IG1heFJldHJpZXMgOiAyO1xuICByZXR1cm4ge1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQsXG4gICAgcmV0cnk6IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQgfSlcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvYXNzZW1ibGUtb3BlcmF0aW9uLW5hbWUudHNcbmZ1bmN0aW9uIGFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gIG9wZXJhdGlvbklkLFxuICB0ZWxlbWV0cnlcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBzdGFuZGFyZGl6ZWQgb3BlcmF0aW9uIGFuZCByZXNvdXJjZSBuYW1lOlxuICAgIFwib3BlcmF0aW9uLm5hbWVcIjogYCR7b3BlcmF0aW9uSWR9JHsodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZCkgIT0gbnVsbCA/IGAgJHt0ZWxlbWV0cnkuZnVuY3Rpb25JZH1gIDogXCJcIn1gLFxuICAgIFwicmVzb3VyY2UubmFtZVwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkLFxuICAgIC8vIGRldGFpbGVkLCBBSSBTREsgc3BlY2lmaWMgZGF0YTpcbiAgICBcImFpLm9wZXJhdGlvbklkXCI6IG9wZXJhdGlvbklkLFxuICAgIFwiYWkudGVsZW1ldHJ5LmZ1bmN0aW9uSWRcIjogdGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuZnVuY3Rpb25JZFxuICB9O1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtYmFzZS10ZWxlbWV0cnktYXR0cmlidXRlcy50c1xuZnVuY3Rpb24gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICBtb2RlbCxcbiAgc2V0dGluZ3MsXG4gIHRlbGVtZXRyeSxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2ExNztcbiAgcmV0dXJuIHtcbiAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAvLyBzZXR0aW5nczpcbiAgICAuLi5PYmplY3QuZW50cmllcyhzZXR0aW5ncykucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGF0dHJpYnV0ZXNbYGFpLnNldHRpbmdzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSksXG4gICAgLy8gYWRkIG1ldGFkYXRhIGFzIGF0dHJpYnV0ZXM6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoKF9hMTcgPSB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5tZXRhZGF0YSkgIT0gbnVsbCA/IF9hMTcgOiB7fSkucmVkdWNlKFxuICAgICAgKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBhdHRyaWJ1dGVzW2BhaS50ZWxlbWV0cnkubWV0YWRhdGEuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LFxuICAgICAge31cbiAgICApLFxuICAgIC8vIHJlcXVlc3QgaGVhZGVyc1xuICAgIC4uLk9iamVjdC5lbnRyaWVzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSkucmVkdWNlKChhdHRyaWJ1dGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnJlcXVlc3QuaGVhZGVycy4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSwge30pXG4gIH07XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC10cmFjZXIudHNcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuXG4vLyBjb3JlL3RlbGVtZXRyeS9ub29wLXRyYWNlci50c1xudmFyIG5vb3BUcmFjZXIgPSB7XG4gIHN0YXJ0U3BhbigpIHtcbiAgICByZXR1cm4gbm9vcFNwYW47XG4gIH0sXG4gIHN0YXJ0QWN0aXZlU3BhbihuYW1lMTcsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzEobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzIobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzMobm9vcFNwYW4pO1xuICAgIH1cbiAgfVxufTtcbnZhciBub29wU3BhbiA9IHtcbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuQ29udGV4dDtcbiAgfSxcbiAgc2V0QXR0cmlidXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGluaygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGlua3MoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXBkYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlY29yZEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub29wU3BhbkNvbnRleHQgPSB7XG4gIHRyYWNlSWQ6IFwiXCIsXG4gIHNwYW5JZDogXCJcIixcbiAgdHJhY2VGbGFnczogMFxufTtcblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xuZnVuY3Rpb24gZ2V0VHJhY2VyKHtcbiAgaXNFbmFibGVkID0gZmFsc2UsXG4gIHRyYWNlclxufSA9IHt9KSB7XG4gIGlmICghaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG5vb3BUcmFjZXI7XG4gIH1cbiAgaWYgKHRyYWNlcikge1xuICAgIHJldHVybiB0cmFjZXI7XG4gIH1cbiAgcmV0dXJuIHRyYWNlLmdldFRyYWNlcihcImFpXCIpO1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9yZWNvcmQtc3Bhbi50c1xuaW1wb3J0IHsgU3BhblN0YXR1c0NvZGUgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5mdW5jdGlvbiByZWNvcmRTcGFuKHtcbiAgbmFtZTogbmFtZTE3LFxuICB0cmFjZXIsXG4gIGF0dHJpYnV0ZXMsXG4gIGZuLFxuICBlbmRXaGVuRG9uZSA9IHRydWVcbn0pIHtcbiAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZTE3LCB7IGF0dHJpYnV0ZXMgfSwgYXN5bmMgKHNwYW4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oc3Bhbik7XG4gICAgICBpZiAoZW5kV2hlbkRvbmUpIHtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oe1xuICAgICAgICAgICAgbmFtZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBTcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvc2VsZWN0LXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgdGVsZW1ldHJ5LFxuICBhdHRyaWJ1dGVzXG59KSB7XG4gIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkuaXNFbmFibGVkKSAhPT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykucmVkdWNlKChhdHRyaWJ1dGVzMiwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcImlucHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlucHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkSW5wdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUuaW5wdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwib3V0cHV0XCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm91dHB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZE91dHB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5vdXRwdXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMyIDogeyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5hdHRyaWJ1dGVzMiwgW2tleV06IHZhbHVlIH07XG4gIH0sIHt9KTtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWQoe1xuICBtb2RlbCxcbiAgdmFsdWUsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkXCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLmVtYmVkXCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIFwiYWkudmFsdWVcIjogeyBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCB7IGVtYmVkZGluZywgdXNhZ2UsIHJlc3BvbnNlIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gKFxuICAgICAgICAgIC8vIG5lc3RlZCBzcGFucyB0byBhbGlnbiB3aXRoIHRoZSBlbWJlZE1hbnkgdGVsZW1ldHJ5IGRhdGE6XG4gICAgICAgICAgcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWQuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHsgaW5wdXQ6ICgpID0+IFtKU09OLnN0cmluZ2lmeSh2YWx1ZSldIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTE3O1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbdmFsdWVdLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmcyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzWzBdO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExNyA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTE3IDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmczKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmczKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiBlbWJlZGRpbmcyLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB1c2FnZTIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZFJlc3VsdCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBlbWJlZGRpbmcsXG4gICAgICAgIHVzYWdlLFxuICAgICAgICByZXNwb25zZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0RW1iZWRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmVtYmVkZGluZyA9IG9wdGlvbnMuZW1iZWRkaW5nO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC1tYW55LnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZE1hbnkoe1xuICBtb2RlbCxcbiAgdmFsdWVzLFxuICBtYXhQYXJhbGxlbENhbGxzID0gSW5maW5pdHksXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkTWFueVwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnlcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCBbbWF4RW1iZWRkaW5nc1BlckNhbGwsIHN1cHBvcnRzUGFyYWxsZWxDYWxsc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsLFxuICAgICAgICBtb2RlbC5zdXBwb3J0c1BhcmFsbGVsQ2FsbHNcbiAgICAgIF0pO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwgfHwgbWF4RW1iZWRkaW5nc1BlckNhbGwgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGNvbnN0IHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlLCByZXNwb25zZSB9ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55LmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczMgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTE3ID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTcgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczMsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHVzYWdlMixcbiAgICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCh7XG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHJlc3BvbnNlczogW3Jlc3BvbnNlXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlQ2h1bmtzID0gc3BsaXRBcnJheSh2YWx1ZXMsIG1heEVtYmVkZGluZ3NQZXJDYWxsKTtcbiAgICAgIGNvbnN0IGVtYmVkZGluZ3MgPSBbXTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgbGV0IHRva2VucyA9IDA7XG4gICAgICBjb25zdCBwYXJhbGxlbENodW5rcyA9IHNwbGl0QXJyYXkoXG4gICAgICAgIHZhbHVlQ2h1bmtzLFxuICAgICAgICBzdXBwb3J0c1BhcmFsbGVsQ2FsbHMgPyBtYXhQYXJhbGxlbENhbGxzIDogMVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgcGFyYWxsZWxDaHVuayBvZiBwYXJhbGxlbENodW5rcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgcGFyYWxsZWxDaHVuay5tYXAoKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnkoKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNodW5rLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2ExNztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVzYWdlID0gKF9hMTcgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2ExNyA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MyLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB1c2FnZS50b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgIGVtYmVkZGluZ3MucHVzaCguLi5yZXN1bHQuZW1iZWRkaW5ncyk7XG4gICAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVzdWx0LnJlc3BvbnNlKTtcbiAgICAgICAgICB0b2tlbnMgKz0gcmVzdWx0LnVzYWdlLnRva2VucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzLm1hcCgoZW1iZWRkaW5nKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmcpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoe1xuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIGVtYmVkZGluZ3MsXG4gICAgICAgIHVzYWdlOiB7IHRva2VucyB9LFxuICAgICAgICByZXNwb25zZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gb3B0aW9ucy5lbWJlZGRpbmdzO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsL2RldGVjdC1tZWRpYS10eXBlLnRzXG5pbXBvcnQgeyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvZ2lmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3MSwgNzMsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUjBsR1wiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMzcsIDgwLCA3OCwgNzFdLFxuICAgIGJhc2U2NFByZWZpeDogXCJpVkJPUndcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2pwZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjE2XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiLzlqL1wiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2Uvd2VicFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbODIsIDczLCA3MCwgNzBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJVa2xHUmdcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2JtcFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNjYsIDc3XSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUWtcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzczLCA3MywgNDIsIDBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJTVWtxQUFcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3RpZmZcIixcbiAgICBieXRlc1ByZWZpeDogWzc3LCA3NywgMCwgNDJdLFxuICAgIGJhc2U2NFByZWZpeDogXCJUVTBBS2dcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2F2aWZcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICA5NyxcbiAgICAgIDExOCxcbiAgICAgIDEwNSxcbiAgICAgIDEwMlxuICAgIF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIkFBQUFJR1owZVhCaGRtbG1cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2hlaWNcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICAxMDQsXG4gICAgICAxMDEsXG4gICAgICAxMDUsXG4gICAgICA5OVxuICAgIF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIkFBQUFJR1owZVhCb1pXbGpcIlxuICB9XG5dO1xudmFyIGF1ZGlvTWVkaWFUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9tcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDI1MV0sXG4gICAgYmFzZTY0UHJlZml4OiBcIi8vcz1cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL3dhdlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbODIsIDczLCA3MCwgNzBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJVa2xHUlwiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vb2dnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3OSwgMTAzLCAxMDMsIDgzXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVDJkblV3XCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9mbGFjXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMDIsIDc2LCA5NywgNjddLFxuICAgIGJhc2U2NFByZWZpeDogXCJaa3hoUXdcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL2FhY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbNjQsIDIxLCAwLCAwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiUUJVQVwiXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vbXA0XCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMDIsIDExNiwgMTIxLCAxMTJdLFxuICAgIGJhc2U2NFByZWZpeDogXCJablI1Y0FcIlxuICB9XG5dO1xudmFyIHN0cmlwSUQzID0gKGRhdGEpID0+IHtcbiAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoZGF0YSkgOiBkYXRhO1xuICBjb25zdCBpZDNTaXplID0gKGJ5dGVzWzZdICYgMTI3KSA8PCAyMSB8IChieXRlc1s3XSAmIDEyNykgPDwgMTQgfCAoYnl0ZXNbOF0gJiAxMjcpIDw8IDcgfCBieXRlc1s5XSAmIDEyNztcbiAgcmV0dXJuIGJ5dGVzLnNsaWNlKGlkM1NpemUgKyAxMCk7XG59O1xuZnVuY3Rpb24gc3RyaXBJRDNUYWdzSWZQcmVzZW50KGRhdGEpIHtcbiAgY29uc3QgaGFzSWQzID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgJiYgZGF0YS5zdGFydHNXaXRoKFwiU1VRelwiKSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiAmJiBkYXRhLmxlbmd0aCA+IDEwICYmIGRhdGFbMF0gPT09IDczICYmIC8vICdJJ1xuICBkYXRhWzFdID09PSA2OCAmJiAvLyAnRCdcbiAgZGF0YVsyXSA9PT0gNTE7XG4gIHJldHVybiBoYXNJZDMgPyBzdHJpcElEMyhkYXRhKSA6IGRhdGE7XG59XG5mdW5jdGlvbiBkZXRlY3RNZWRpYVR5cGUoe1xuICBkYXRhLFxuICBzaWduYXR1cmVzXG59KSB7XG4gIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBzdHJpcElEM1RhZ3NJZlByZXNlbnQoZGF0YSk7XG4gIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHNpZ25hdHVyZXMpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3NlZERhdGEgPT09IFwic3RyaW5nXCIgPyBwcm9jZXNzZWREYXRhLnN0YXJ0c1dpdGgoc2lnbmF0dXJlLmJhc2U2NFByZWZpeCkgOiBwcm9jZXNzZWREYXRhLmxlbmd0aCA+PSBzaWduYXR1cmUuYnl0ZXNQcmVmaXgubGVuZ3RoICYmIHNpZ25hdHVyZS5ieXRlc1ByZWZpeC5ldmVyeShcbiAgICAgIChieXRlLCBpbmRleCkgPT4gcHJvY2Vzc2VkRGF0YVtpbmRleF0gPT09IGJ5dGVcbiAgICApKSB7XG4gICAgICByZXR1cm4gc2lnbmF0dXJlLm1lZGlhVHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlZC1maWxlLnRzXG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IGFzIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyLFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgRGVmYXVsdEdlbmVyYXRlZEZpbGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lZGlhVHlwZVxuICB9KSB7XG4gICAgY29uc3QgaXNVaW50OEFycmF5ID0gZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgdGhpcy5iYXNlNjREYXRhID0gaXNVaW50OEFycmF5ID8gdm9pZCAwIDogZGF0YTtcbiAgICB0aGlzLnVpbnQ4QXJyYXlEYXRhID0gaXNVaW50OEFycmF5ID8gZGF0YSA6IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhVHlwZSA9IG1lZGlhVHlwZTtcbiAgfVxuICAvLyBsYXp5IGNvbnZlcnNpb24gd2l0aCBjYWNoaW5nIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnZlcnNpb24gb3ZlcmhlYWQ6XG4gIGdldCBiYXNlNjQoKSB7XG4gICAgaWYgKHRoaXMuYmFzZTY0RGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJhc2U2NERhdGEgPSBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KHRoaXMudWludDhBcnJheURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5iYXNlNjREYXRhO1xuICB9XG4gIC8vIGxhenkgY29udmVyc2lvbiB3aXRoIGNhY2hpbmcgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29udmVyc2lvbiBvdmVyaGVhZDpcbiAgZ2V0IHVpbnQ4QXJyYXkoKSB7XG4gICAgaWYgKHRoaXMudWludDhBcnJheURhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy51aW50OEFycmF5RGF0YSA9IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyKHRoaXMuYmFzZTY0RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQ4QXJyYXlEYXRhO1xuICB9XG59O1xudmFyIERlZmF1bHRHZW5lcmF0ZWRGaWxlV2l0aFR5cGUgPSBjbGFzcyBleHRlbmRzIERlZmF1bHRHZW5lcmF0ZWRGaWxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMudHlwZSA9IFwiZmlsZVwiO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLWltYWdlL2dlbmVyYXRlLWltYWdlLnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlKHtcbiAgbW9kZWwsXG4gIHByb21wdCxcbiAgbiA9IDEsXG4gIG1heEltYWdlc1BlckNhbGwsXG4gIHNpemUsXG4gIGFzcGVjdFJhdGlvLFxuICBzZWVkLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3LCBfYjtcbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnIH0pO1xuICBjb25zdCBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQgPSAoX2ExNyA9IG1heEltYWdlc1BlckNhbGwgIT0gbnVsbCA/IG1heEltYWdlc1BlckNhbGwgOiBtb2RlbC5tYXhJbWFnZXNQZXJDYWxsKSAhPSBudWxsID8gX2ExNyA6IDE7XG4gIGNvbnN0IGNhbGxDb3VudCA9IE1hdGguY2VpbChuIC8gbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0KTtcbiAgY29uc3QgY2FsbEltYWdlQ291bnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogY2FsbENvdW50IH0sIChfLCBpKSA9PiB7XG4gICAgaWYgKGkgPCBjYWxsQ291bnQgLSAxKSB7XG4gICAgICByZXR1cm4gbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCByZW1haW5kZXIgPSBuICUgbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0O1xuICAgIHJldHVybiByZW1haW5kZXIgPT09IDAgPyBtYXhJbWFnZXNQZXJDYWxsV2l0aERlZmF1bHQgOiByZW1haW5kZXI7XG4gIH0pO1xuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgY2FsbEltYWdlQ291bnRzLm1hcChcbiAgICAgIGFzeW5jIChjYWxsSW1hZ2VDb3VudCkgPT4gcmV0cnkoXG4gICAgICAgICgpID0+IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBuOiBjYWxsSW1hZ2VDb3VudCxcbiAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgYXNwZWN0UmF0aW8sXG4gICAgICAgICAgc2VlZCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyT3B0aW9ucyAhPSBudWxsID8gcHJvdmlkZXJPcHRpb25zIDoge31cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG4gICk7XG4gIGNvbnN0IGltYWdlcyA9IFtdO1xuICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgY29uc3QgcHJvdmlkZXJNZXRhZGF0YSA9IHt9O1xuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaW1hZ2VzLnB1c2goXG4gICAgICAuLi5yZXN1bHQuaW1hZ2VzLm1hcChcbiAgICAgICAgKGltYWdlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMTg7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVkRmlsZSh7XG4gICAgICAgICAgICBkYXRhOiBpbWFnZSxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogKF9hMTggPSBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICAgICAgICBkYXRhOiBpbWFnZSxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICAgICAgICB9KSkgIT0gbnVsbCA/IF9hMTggOiBcImltYWdlL3BuZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICAgIHdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzKTtcbiAgICBpZiAocmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgW3Byb3ZpZGVyTmFtZSwgbWV0YWRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3VsdC5wcm92aWRlck1ldGFkYXRhKSkge1xuICAgICAgICAoX2IgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0pICE9IG51bGwgPyBfYiA6IHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IHsgaW1hZ2VzOiBbXSB9O1xuICAgICAgICBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0uaW1hZ2VzLnB1c2goXG4gICAgICAgICAgLi4ucmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS5pbWFnZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzcG9uc2VzLnB1c2gocmVzdWx0LnJlc3BvbnNlKTtcbiAgfVxuICBpZiAoIWltYWdlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgTm9JbWFnZUdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzIH0pO1xuICB9XG4gIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQoe1xuICAgIGltYWdlcyxcbiAgICB3YXJuaW5ncyxcbiAgICByZXNwb25zZXMsXG4gICAgcHJvdmlkZXJNZXRhZGF0YVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVJbWFnZVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuaW1hZ2VzID0gb3B0aW9ucy5pbWFnZXM7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlc1swXTtcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5pbXBvcnQge1xuICBKU09OUGFyc2VFcnJvciBhcyBKU09OUGFyc2VFcnJvcjIsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9leHRyYWN0LWNvbnRlbnQtdGV4dC50c1xuZnVuY3Rpb24gZXh0cmFjdENvbnRlbnRUZXh0KGNvbnRlbnQpIHtcbiAgY29uc3QgcGFydHMgPSBjb250ZW50LmZpbHRlcihcbiAgICAoY29udGVudDIpID0+IGNvbnRlbnQyLnR5cGUgPT09IFwidGV4dFwiXG4gICk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBwYXJ0cy5tYXAoKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50ZXh0KS5qb2luKFwiXCIpO1xufVxuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuaW1wb3J0IHsgaXNVcmxTdXBwb3J0ZWQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9kb3dubG9hZC50c1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoeyB1cmwgfSkge1xuICB2YXIgX2ExNztcbiAgY29uc3QgdXJsVGV4dCA9IHVybC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsVGV4dCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1lZGlhVHlwZTogKF9hMTcgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgIT0gbnVsbCA/IF9hMTcgOiB2b2lkIDBcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChEb3dubG9hZEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3IoeyB1cmw6IHVybFRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE3IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTMsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQgYXMgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L3NwbGl0LWRhdGEtdXJsLnRzXG5mdW5jdGlvbiBzcGxpdERhdGFVcmwoZGF0YVVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lZGlhVHlwZTogaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV0sXG4gICAgICBiYXNlNjRDb250ZW50XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWFUeXBlOiB2b2lkIDAsXG4gICAgICBiYXNlNjRDb250ZW50OiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xudmFyIGRhdGFDb250ZW50U2NoZW1hID0gejIudW5pb24oW1xuICB6Mi5zdHJpbmcoKSxcbiAgejIuaW5zdGFuY2VvZihVaW50OEFycmF5KSxcbiAgejIuaW5zdGFuY2VvZihBcnJheUJ1ZmZlciksXG4gIHoyLmN1c3RvbShcbiAgICAvLyBCdWZmZXIgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiBzb21lIGVudmlyb25tZW50cyBzdWNoIGFzIENsb3VkRmxhcmU6XG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hMTcgPSBnbG9iYWxUaGlzLkJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuaXNCdWZmZXIodmFsdWUpKSAhPSBudWxsID8gX2IgOiBmYWxzZTtcbiAgICB9LFxuICAgIHsgbWVzc2FnZTogXCJNdXN0IGJlIGEgQnVmZmVyXCIgfVxuICApXG5dKTtcbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWMkRhdGFDb250ZW50KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHsgZGF0YTogY29udGVudCwgbWVkaWFUeXBlOiB2b2lkIDAgfTtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgZGF0YTogbmV3IFVpbnQ4QXJyYXkoY29udGVudCksIG1lZGlhVHlwZTogdm9pZCAwIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnQgPSBuZXcgVVJMKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVVJMICYmIGNvbnRlbnQucHJvdG9jb2wgPT09IFwiZGF0YTpcIikge1xuICAgIGNvbnN0IHsgbWVkaWFUeXBlOiBkYXRhVXJsTWVkaWFUeXBlLCBiYXNlNjRDb250ZW50IH0gPSBzcGxpdERhdGFVcmwoXG4gICAgICBjb250ZW50LnRvU3RyaW5nKClcbiAgICApO1xuICAgIGlmIChkYXRhVXJsTWVkaWFUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQUlTREtFcnJvcjE3KHtcbiAgICAgICAgbmFtZTogXCJJbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQgaW4gY29udGVudCAke2NvbnRlbnQudG9TdHJpbmcoKX1gXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YTogYmFzZTY0Q29udGVudCwgbWVkaWFUeXBlOiBkYXRhVXJsTWVkaWFUeXBlIH07XG4gIH1cbiAgcmV0dXJuIHsgZGF0YTogY29udGVudCwgbWVkaWFUeXBlOiB2b2lkIDAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheTMoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBkYXRhIGNvbnRlbnQuIENvbnRlbnQgc3RyaW5nIGlzIG5vdCBhIGJhc2U2NC1lbmNvZGVkIG1lZGlhLlwiLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgcHJvbXB0LFxuICBzdXBwb3J0ZWRVcmxzLFxuICBkb3dubG9hZEltcGxlbWVudGF0aW9uID0gZG93bmxvYWRcbn0pIHtcbiAgY29uc3QgZG93bmxvYWRlZEFzc2V0cyA9IGF3YWl0IGRvd25sb2FkQXNzZXRzKFxuICAgIHByb21wdC5tZXNzYWdlcyxcbiAgICBkb3dubG9hZEltcGxlbWVudGF0aW9uLFxuICAgIHN1cHBvcnRlZFVybHNcbiAgKTtcbiAgcmV0dXJuIFtcbiAgICAuLi5wcm9tcHQuc3lzdGVtICE9IG51bGwgPyBbeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH1dIDogW10sXG4gICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcChcbiAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkQXNzZXRzKVxuICAgIClcbiAgXTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKG1lc3NhZ2UsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgY29uc3Qgcm9sZSA9IG1lc3NhZ2Uucm9sZTtcbiAgc3dpdGNoIChyb2xlKSB7XG4gICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiKSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIlxuICAgICAgICApLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVyT3B0aW9ucyA9IHBhcnQucHJvdmlkZXJPcHRpb25zO1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbWVkaWFUeXBlIH0gPSBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsVjJEYXRhQ29udGVudChcbiAgICAgICAgICAgICAgICBwYXJ0LmRhdGFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogbWVkaWFUeXBlICE9IG51bGwgPyBtZWRpYVR5cGUgOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnQuYXJncyxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogcGFydC5yZXN1bHQsXG4gICAgICAgICAgY29udGVudDogcGFydC5leHBlcmltZW50YWxfY29udGVudCxcbiAgICAgICAgICBpc0Vycm9yOiBwYXJ0LmlzRXJyb3IsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgICAgICB9KSksXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlUm9sZUVycm9yKHsgcm9sZTogX2V4aGF1c3RpdmVDaGVjayB9KTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkQXNzZXRzKG1lc3NhZ2VzLCBkb3dubG9hZEltcGxlbWVudGF0aW9uLCBzdXBwb3J0ZWRVcmxzKSB7XG4gIGNvbnN0IHVybHMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIpLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KS5maWx0ZXIoXG4gICAgKGNvbnRlbnQpID0+IEFycmF5LmlzQXJyYXkoY29udGVudClcbiAgKS5mbGF0KCkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiXG4gICkubWFwKChwYXJ0KSA9PiB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgbWVkaWFUeXBlID0gKF9hMTcgPSBwYXJ0Lm1lZGlhVHlwZSkgIT0gbnVsbCA/IF9hMTcgOiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiA/IFwiaW1hZ2UvKlwiIDogdm9pZCAwO1xuICAgIGxldCBkYXRhID0gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IG5ldyBVUkwoZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1lZGlhVHlwZSwgZGF0YSB9O1xuICB9KS5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTCAmJiBwYXJ0Lm1lZGlhVHlwZSAhPSBudWxsICYmICFpc1VybFN1cHBvcnRlZCh7XG4gICAgICB1cmw6IHBhcnQuZGF0YS50b1N0cmluZygpLFxuICAgICAgbWVkaWFUeXBlOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgIHN1cHBvcnRlZFVybHNcbiAgICB9KVxuICApLm1hcCgocGFydCkgPT4gcGFydC5kYXRhKTtcbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVybHMubWFwKGFzeW5jICh1cmwpID0+ICh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiBhd2FpdCBkb3dubG9hZEltcGxlbWVudGF0aW9uKHsgdXJsIH0pXG4gICAgfSkpXG4gICk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEltYWdlcy5tYXAoKHsgdXJsLCBkYXRhIH0pID0+IFt1cmwudG9TdHJpbmcoKSwgZGF0YV0pXG4gICk7XG59XG5mdW5jdGlvbiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykge1xuICB2YXIgX2ExNywgX2I7XG4gIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgIH07XG4gIH1cbiAgbGV0IG9yaWdpbmFsRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBvcmlnaW5hbERhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIG9yaWdpbmFsRGF0YSA9IHBhcnQuZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIGNvbnN0IHsgZGF0YTogY29udmVydGVkRGF0YSwgbWVkaWFUeXBlOiBjb252ZXJ0ZWRNZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWMkRhdGFDb250ZW50KG9yaWdpbmFsRGF0YSk7XG4gIGxldCBtZWRpYVR5cGUgPSBjb252ZXJ0ZWRNZWRpYVR5cGUgIT0gbnVsbCA/IGNvbnZlcnRlZE1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlO1xuICBsZXQgZGF0YSA9IGNvbnZlcnRlZERhdGE7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgZG93bmxvYWRlZEZpbGUgPSBkb3dubG9hZGVkQXNzZXRzW2RhdGEudG9TdHJpbmcoKV07XG4gICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICBkYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgIG1lZGlhVHlwZSA9IChfYTE3ID0gZG93bmxvYWRlZEZpbGUubWVkaWFUeXBlKSAhPSBudWxsID8gX2ExNyA6IG1lZGlhVHlwZTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZWRpYVR5cGUgPSAoX2IgPSBkZXRlY3RNZWRpYVR5cGUoeyBkYXRhLCBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXMgfSkpICE9IG51bGwgPyBfYiA6IG1lZGlhVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogXCJpbWFnZS8qXCIsXG4gICAgICAgIC8vIGFueSBpbWFnZVxuICAgICAgICBmaWxlbmFtZTogdm9pZCAwLFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICBpZiAobWVkaWFUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZWRpYSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50c1xuZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heE91dHB1dFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHRvcEssXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc2VlZCxcbiAgc3RvcFNlcXVlbmNlc1xufSkge1xuICBpZiAobWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4T3V0cHV0VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heE91dHB1dFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heE91dHB1dFRva2VucyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhPdXRwdXRUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4T3V0cHV0VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4T3V0cHV0VG9rZW5zIG11c3QgYmUgPj0gMVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidGVtcGVyYXR1cmVcIixcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiBcInRlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BQXCIsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiBcInRvcFAgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcEsgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wSyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcEtcIixcbiAgICAgICAgdmFsdWU6IHRvcEssXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wSyBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlUGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInByZXNlbmNlUGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcInByZXNlbmNlUGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3lQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZnJlcXVlbmN5UGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJmcmVxdWVuY3lQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VlZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzZWVkXCIsXG4gICAgICAgIHZhbHVlOiBzZWVkLFxuICAgICAgICBtZXNzYWdlOiBcInNlZWQgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heE91dHB1dFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZSxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlcyxcbiAgICBzZWVkXG4gIH07XG59XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuaW1wb3J0IHsgSW52YWxpZFByb21wdEVycm9yIGFzIEludmFsaWRQcm9tcHRFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVZhbGlkYXRlVHlwZXMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgeiBhcyB6OCB9IGZyb20gXCJ6b2RcIjtcblxuLy8gY29yZS9wcm9tcHQvbWVzc2FnZS50c1xuaW1wb3J0IHsgeiBhcyB6NyB9IGZyb20gXCJ6b2RcIjtcblxuLy8gY29yZS90eXBlcy9wcm92aWRlci1tZXRhZGF0YS50c1xuaW1wb3J0IHsgeiBhcyB6NCB9IGZyb20gXCJ6b2RcIjtcblxuLy8gY29yZS90eXBlcy9qc29uLXZhbHVlLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZFwiO1xudmFyIGpzb25WYWx1ZVNjaGVtYSA9IHozLmxhenkoXG4gICgpID0+IHozLnVuaW9uKFtcbiAgICB6My5udWxsKCksXG4gICAgejMuc3RyaW5nKCksXG4gICAgejMubnVtYmVyKCksXG4gICAgejMuYm9vbGVhbigpLFxuICAgIHozLnJlY29yZCh6My5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hKSxcbiAgICB6My5hcnJheShqc29uVmFsdWVTY2hlbWEpXG4gIF0pXG4pO1xuXG4vLyBjb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG52YXIgcHJvdmlkZXJNZXRhZGF0YVNjaGVtYSA9IHo0LnJlY29yZChcbiAgejQuc3RyaW5nKCksXG4gIHo0LnJlY29yZCh6NC5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hKVxuKTtcblxuLy8gY29yZS9wcm9tcHQvY29udGVudC1wYXJ0LnRzXG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3Byb21wdC90b29sLXJlc3VsdC1jb250ZW50LnRzXG5pbXBvcnQgeyB6IGFzIHo1IH0gZnJvbSBcInpvZFwiO1xudmFyIHRvb2xSZXN1bHRDb250ZW50U2NoZW1hID0gejUuYXJyYXkoXG4gIHo1LnVuaW9uKFtcbiAgICB6NS5vYmplY3QoeyB0eXBlOiB6NS5saXRlcmFsKFwidGV4dFwiKSwgdGV4dDogejUuc3RyaW5nKCkgfSksXG4gICAgejUub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo1LmxpdGVyYWwoXCJpbWFnZVwiKSxcbiAgICAgIGRhdGE6IHo1LnN0cmluZygpLFxuICAgICAgbWVkaWFUeXBlOiB6NS5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgfSlcbiAgXSlcbik7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnRlbnQtcGFydC50c1xudmFyIHRleHRQYXJ0U2NoZW1hID0gejYub2JqZWN0KHtcbiAgdHlwZTogejYubGl0ZXJhbChcInRleHRcIiksXG4gIHRleHQ6IHo2LnN0cmluZygpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgaW1hZ2VQYXJ0U2NoZW1hID0gejYub2JqZWN0KHtcbiAgdHlwZTogejYubGl0ZXJhbChcImltYWdlXCIpLFxuICBpbWFnZTogejYudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6Ni5pbnN0YW5jZW9mKFVSTCldKSxcbiAgbWVkaWFUeXBlOiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgZmlsZVBhcnRTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICB0eXBlOiB6Ni5saXRlcmFsKFwiZmlsZVwiKSxcbiAgZGF0YTogejYudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6Ni5pbnN0YW5jZW9mKFVSTCldKSxcbiAgZmlsZW5hbWU6IHo2LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIG1lZGlhVHlwZTogejYuc3RyaW5nKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciByZWFzb25pbmdQYXJ0U2NoZW1hID0gejYub2JqZWN0KHtcbiAgdHlwZTogejYubGl0ZXJhbChcInJlYXNvbmluZ1wiKSxcbiAgdGV4dDogejYuc3RyaW5nKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciB0b29sQ2FsbFBhcnRTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICB0eXBlOiB6Ni5saXRlcmFsKFwidG9vbC1jYWxsXCIpLFxuICB0b29sQ2FsbElkOiB6Ni5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHo2LnN0cmluZygpLFxuICBhcmdzOiB6Ni51bmtub3duKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciB0b29sUmVzdWx0UGFydFNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHR5cGU6IHo2LmxpdGVyYWwoXCJ0b29sLXJlc3VsdFwiKSxcbiAgdG9vbENhbGxJZDogejYuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6Ni5zdHJpbmcoKSxcbiAgcmVzdWx0OiB6Ni51bmtub3duKCksXG4gIGNvbnRlbnQ6IHRvb2xSZXN1bHRDb250ZW50U2NoZW1hLm9wdGlvbmFsKCksXG4gIGlzRXJyb3I6IHo2LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG5cbi8vIGNvcmUvcHJvbXB0L21lc3NhZ2UudHNcbnZhciBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEgPSB6Ny5vYmplY3QoXG4gIHtcbiAgICByb2xlOiB6Ny5saXRlcmFsKFwic3lzdGVtXCIpLFxuICAgIGNvbnRlbnQ6IHo3LnN0cmluZygpLFxuICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gIH1cbik7XG52YXIgY29yZVN5c3RlbU1lc3NhZ2VTY2hlbWEgPSBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWE7XG52YXIgdXNlck1vZGVsTWVzc2FnZVNjaGVtYSA9IHo3Lm9iamVjdCh7XG4gIHJvbGU6IHo3LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6Ny51bmlvbihbXG4gICAgejcuc3RyaW5nKCksXG4gICAgejcuYXJyYXkoejcudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVVzZXJNZXNzYWdlU2NoZW1hID0gdXNlck1vZGVsTWVzc2FnZVNjaGVtYTtcbnZhciBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6Ny5vYmplY3Qoe1xuICByb2xlOiB6Ny5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICBjb250ZW50OiB6Ny51bmlvbihbXG4gICAgejcuc3RyaW5nKCksXG4gICAgejcuYXJyYXkoXG4gICAgICB6Ny51bmlvbihbXG4gICAgICAgIHRleHRQYXJ0U2NoZW1hLFxuICAgICAgICBmaWxlUGFydFNjaGVtYSxcbiAgICAgICAgcmVhc29uaW5nUGFydFNjaGVtYSxcbiAgICAgICAgdG9vbENhbGxQYXJ0U2NoZW1hXG4gICAgICBdKVxuICAgIClcbiAgXSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlQXNzaXN0YW50TWVzc2FnZVNjaGVtYSA9IGFzc2lzdGFudE1vZGVsTWVzc2FnZVNjaGVtYTtcbnZhciB0b29sTW9kZWxNZXNzYWdlU2NoZW1hID0gejcub2JqZWN0KHtcbiAgcm9sZTogejcubGl0ZXJhbChcInRvb2xcIiksXG4gIGNvbnRlbnQ6IHo3LmFycmF5KHRvb2xSZXN1bHRQYXJ0U2NoZW1hKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVUb29sTWVzc2FnZVNjaGVtYSA9IHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWE7XG52YXIgbW9kZWxNZXNzYWdlU2NoZW1hID0gejcudW5pb24oW1xuICBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIGFzc2lzdGFudE1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYVxuXSk7XG52YXIgY29yZU1lc3NhZ2VTY2hlbWEgPSBtb2RlbE1lc3NhZ2VTY2hlbWE7XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQocHJvbXB0KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZVwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnN5c3RlbSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGxldCBtZXNzYWdlcztcbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnByb21wdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1lc3NhZ2VzID0gW3sgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IHByb21wdC5wcm9tcHQgfV07XG4gIH0gZWxzZSBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkocHJvbXB0LnByb21wdCkpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5wcm9tcHQ7XG4gIH0gZWxzZSBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5tZXNzYWdlcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChtZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIG11c3Qgbm90IGJlIGVtcHR5XCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICBzY2hlbWE6IHo4LmFycmF5KG1vZGVsTWVzc2FnZVNjaGVtYSlcbiAgfSk7XG4gIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcjIoe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJUaGUgbWVzc2FnZXMgbXVzdCBiZSBhIE1vZGVsTWVzc2FnZVtdLiBJZiB5b3UgaGF2ZSBwYXNzZWQgYSBVSU1lc3NhZ2VbXSwgeW91IGNhbiB1c2UgY29udmVydFRvTW9kZWxNZXNzYWdlcyB0byBjb252ZXJ0IHRoZW0uXCIsXG4gICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBhc1NjaGVtYSxcbiAgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXMyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2FzeW5jLWl0ZXJhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShzb3VyY2UpIHtcbiAgY29uc3Qgc3RyZWFtID0gc291cmNlLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oKSk7XG4gIHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9IDogeyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9vdXRwdXQtc3RyYXRlZ3kudHNcbnZhciBub1NjaGVtYU91dHB1dFN0cmF0ZWd5ID0ge1xuICB0eXBlOiBcIm5vLXNjaGVtYVwiLFxuICBqc29uU2NoZW1hOiB2b2lkIDAsXG4gIGFzeW5jIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiB7IHBhcnRpYWw6IHZhbHVlLCB0ZXh0RGVsdGEgfSB9O1xuICB9LFxuICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgIHRleHQ6IGNvbnRleHQudGV4dCxcbiAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQucmVzcG9uc2UsXG4gICAgICAgIHVzYWdlOiBjb250ZXh0LnVzYWdlLFxuICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQuZmluaXNoUmVhc29uXG4gICAgICB9KVxuICAgIH0gOiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBuby1zY2hlbWEgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn07XG52YXIgb2JqZWN0T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiAoe1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBqc29uU2NoZW1hOiBzY2hlbWEuanNvblNjaGVtYSxcbiAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgIHBhcnRpYWw6IHZhbHVlLFxuICAgICAgICB0ZXh0RGVsdGFcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBvYmplY3QgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn0pO1xudmFyIGFycmF5T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiB7XG4gIGNvbnN0IHsgJHNjaGVtYSwgLi4uaXRlbVNjaGVtYSB9ID0gc2NoZW1hLmpzb25TY2hlbWE7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgLy8gd3JhcCBpbiBvYmplY3QgdGhhdCBjb250YWlucyBhcnJheSBvZiBlbGVtZW50cywgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBhcnJheSBkaXJlY3RseTpcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiB1c2UgYXJyYXlzIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgZ3JhbW1hci1ndWlkZWQgZ2VuZXJhdGlvblxuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBlbGVtZW50czogeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiBpdGVtU2NoZW1hIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wiZWxlbWVudHNcIl0sXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICB9LFxuICAgIGFzeW5jIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgIGlzRmluYWxEZWx0YVxuICAgIH0pIHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IyKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBlbGVtZW50c1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlucHV0QXJyYXkgPSB2YWx1ZS5lbGVtZW50cztcbiAgICAgIGNvbnN0IHJlc3VsdEFycmF5ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGlucHV0QXJyYXlbaV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlOiBlbGVtZW50LCBzY2hlbWEgfSk7XG4gICAgICAgIGlmIChpID09PSBpbnB1dEFycmF5Lmxlbmd0aCAtIDEgJiYgIWlzRmluYWxEZWx0YSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdEFycmF5LnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1Ymxpc2hlZEVsZW1lbnRDb3VudCA9IChfYTE3ID0gbGF0ZXN0T2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBsYXRlc3RPYmplY3QubGVuZ3RoKSAhPSBudWxsID8gX2ExNyA6IDA7XG4gICAgICBsZXQgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgIGlmIChpc0ZpcnN0RGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiW1wiO1xuICAgICAgfVxuICAgICAgaWYgKHB1Ymxpc2hlZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiLFwiO1xuICAgICAgfVxuICAgICAgdGV4dERlbHRhICs9IHJlc3VsdEFycmF5LnNsaWNlKHB1Ymxpc2hlZEVsZW1lbnRDb3VudCkubWFwKChlbGVtZW50KSA9PiBKU09OLnN0cmluZ2lmeShlbGVtZW50KSkuam9pbihcIixcIik7XG4gICAgICBpZiAoaXNGaW5hbERlbHRhKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIl1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgcGFydGlhbDogcmVzdWx0QXJyYXksXG4gICAgICAgICAgdGV4dERlbHRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luYyB2YWxpZGF0ZUZpbmFsUmVzdWx0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgIWlzSlNPTkFycmF5KHZhbHVlLmVsZW1lbnRzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGlucHV0QXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiBpbnB1dEFycmF5IH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKG9yaWdpbmFsU3RyZWFtKSB7XG4gICAgICBsZXQgcHVibGlzaGVkRWxlbWVudHMgPSAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICAgIG9yaWdpbmFsU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBjaHVuay5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheS5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGFycmF5W3B1Ymxpc2hlZEVsZW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZW51bU91dHB1dFN0cmF0ZWd5ID0gKGVudW1WYWx1ZXMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJlc3VsdCwgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBlbnVtIHZhbHVlIGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBlbnVtcyBkaXJlY3RseSB3aGVuIG1vZGVsIHN1cHBvcnRzIHRvcC1sZXZlbCBlbnVtc1xuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogZW51bVZhbHVlcyB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgYXN5bmMgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IyKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6ICd2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgc3RyaW5nIGluIHRoZSBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUucmVzdWx0O1xuICAgICAgcmV0dXJuIGVudW1WYWx1ZXMuaW5jbHVkZXMocmVzdWx0KSA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdCB9IDoge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMih7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZW51bVwiXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sXG4gICAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjIoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICBjb25zdCBwb3NzaWJsZUVudW1WYWx1ZXMgPSBlbnVtVmFsdWVzLmZpbHRlcihcbiAgICAgICAgKGVudW1WYWx1ZSkgPT4gZW51bVZhbHVlLnN0YXJ0c1dpdGgocmVzdWx0KVxuICAgICAgKTtcbiAgICAgIGlmICh2YWx1ZS5yZXN1bHQubGVuZ3RoID09PSAwIHx8IHBvc3NpYmxlRW51bVZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IyKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZW51bVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgcGFydGlhbDogcG9zc2libGVFbnVtVmFsdWVzLmxlbmd0aCA+IDEgPyByZXN1bHQgOiBwb3NzaWJsZUVudW1WYWx1ZXNbMF0sXG4gICAgICAgICAgdGV4dERlbHRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0T3V0cHV0U3RyYXRlZ3koe1xuICBvdXRwdXQsXG4gIHNjaGVtYSxcbiAgZW51bVZhbHVlc1xufSkge1xuICBzd2l0Y2ggKG91dHB1dCkge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBvYmplY3RPdXRwdXRTdHJhdGVneShhc1NjaGVtYShzY2hlbWEpKTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiBhcnJheU91dHB1dFN0cmF0ZWd5KGFzU2NoZW1hKHNjaGVtYSkpO1xuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICByZXR1cm4gZW51bU91dHB1dFN0cmF0ZWd5KGVudW1WYWx1ZXMpO1xuICAgIGNhc2UgXCJuby1zY2hlbWFcIjpcbiAgICAgIHJldHVybiBub1NjaGVtYU91dHB1dFN0cmF0ZWd5O1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBvdXRwdXQ7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dDogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC92YWxpZGF0ZS1vYmplY3QtZ2VuZXJhdGlvbi1pbnB1dC50c1xuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICBvdXRwdXQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgaWYgKG91dHB1dCAhPSBudWxsICYmIG91dHB1dCAhPT0gXCJvYmplY3RcIiAmJiBvdXRwdXQgIT09IFwiYXJyYXlcIiAmJiBvdXRwdXQgIT09IFwiZW51bVwiICYmIG91dHB1dCAhPT0gXCJuby1zY2hlbWFcIikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBwYXJhbWV0ZXI6IFwib3V0cHV0XCIsXG4gICAgICB2YWx1ZTogb3V0cHV0LFxuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIG91dHB1dCB0eXBlLlwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJuby1zY2hlbWFcIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hTmFtZVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hTmFtZSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgbmFtZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG5vLXNjaGVtYSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIHJlcXVpcmVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIG9iamVjdCBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJFbGVtZW50IHNjaGVtYSBpcyByZXF1aXJlZCBmb3IgYXJyYXkgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChvdXRwdXQgPT09IFwiZW51bVwiKSB7XG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFEZXNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIGRlc2NyaXB0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgZW51bSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW51bVZhbHVlcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZW51bVZhbHVlc1wiLFxuICAgICAgICB2YWx1ZTogZW51bVZhbHVlcyxcbiAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBhcmUgcmVxdWlyZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBlbnVtVmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIG11c3QgYmUgc3RyaW5ncy5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3IoeyBwcmVmaXg6IFwiYWlvYmpcIiwgc2l6ZTogMjQgfSk7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU9iamVjdChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlbCxcbiAgICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBoZWFkZXJzLFxuICAgIGV4cGVyaW1lbnRhbF9yZXBhaXJUZXh0OiByZXBhaXJUZXh0LFxuICAgIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgX2ludGVybmFsOiB7XG4gICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZCxcbiAgICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICB9ID0ge30sXG4gICAgLi4uc2V0dGluZ3NcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGVudW1WYWx1ZXMgPSBcImVudW1cIiBpbiBvcHRpb25zID8gb3B0aW9ucy5lbnVtIDogdm9pZCAwO1xuICBjb25zdCB7XG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBzY2hlbWFOYW1lXG4gIH0gPSBcInNjaGVtYVwiIGluIG9wdGlvbnMgPyBvcHRpb25zIDoge307XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIGVudW1WYWx1ZXNcbiAgfSk7XG4gIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHsgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3RcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICB9LFxuICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgIFwiYWkuc2NoZW1hLmRlc2NyaXB0aW9uXCI6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTc7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICAgIGxldCB1c2FnZTtcbiAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgIGxldCByZXNwb25zZTtcbiAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgbGV0IHJlc3VsdFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgbW9kZWwuc3VwcG9ydGVkVXJsc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IGNhbGxTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBjYWxsU2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2ExOCwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgaWQ6IChfYiA9IChfYTE4ID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTguaWQpICE9IG51bGwgPyBfYiA6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9kID0gKF9jID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IChfZyA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZy5oZWFkZXJzLFxuICAgICAgICAgICAgICBib2R5OiAoX2ggPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2guYm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQyID0gZXh0cmFjdENvbnRlbnRUZXh0KHJlc3VsdDIuY29udGVudCk7XG4gICAgICAgICAgICBpZiAodGV4dDIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYSByZXNwb25zZS5cIixcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgICAgICAgIHVzYWdlOiByZXN1bHQyLnVzYWdlLFxuICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gdGV4dDIgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVuYW1lIHRlbGVtZXRyeSBhdHRyaWJ1dGVzIHRvIGlucHV0VG9rZW5zIGFuZCBvdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0Mi51c2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0Mi5maW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dDogdGV4dDIsIHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC5vYmplY3RUZXh0O1xuICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhID0gZ2VuZXJhdGVSZXN1bHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIHJlcXVlc3QgPSAoX2ExNyA9IGdlbmVyYXRlUmVzdWx0LnJlcXVlc3QpICE9IG51bGwgPyBfYTE3IDoge307XG4gICAgICByZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJlc3BvbnNlRGF0YTtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHQocmVzdWx0Mikge1xuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04yKHsgdGV4dDogcmVzdWx0MiB9KTtcbiAgICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgdGV4dDogcmVzdWx0MixcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVGaW5hbFJlc3VsdChcbiAgICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0OiByZXN1bHQyLFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB1c2FnZVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICB0ZXh0OiByZXN1bHQyLFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgICAgfVxuICAgICAgbGV0IG9iamVjdDI7XG4gICAgICB0cnkge1xuICAgICAgICBvYmplY3QyID0gYXdhaXQgcHJvY2Vzc1Jlc3VsdChyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHJlcGFpclRleHQgIT0gbnVsbCAmJiBOb09iamVjdEdlbmVyYXRlZEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpICYmIChKU09OUGFyc2VFcnJvcjIuaXNJbnN0YW5jZShlcnJvci5jYXVzZSkgfHwgVHlwZVZhbGlkYXRpb25FcnJvcjMuaXNJbnN0YW5jZShlcnJvci5jYXVzZSkpKSB7XG4gICAgICAgICAgY29uc3QgcmVwYWlyZWRUZXh0ID0gYXdhaXQgcmVwYWlyVGV4dCh7XG4gICAgICAgICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IuY2F1c2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVwYWlyZWRUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0MiA9IGF3YWl0IHByb2Nlc3NSZXN1bHQocmVwYWlyZWRUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogdXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QyLFxuICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdFByb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vYmplY3QgPSBvcHRpb25zLm9iamVjdDtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTE3O1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTE3ID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTE3IDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZUhlYWRlcnMoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzLCB7XG4gICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlLnRzXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdFxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9jcmVhdGUtc3RpdGNoYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKSB7XG4gIGxldCBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuICBsZXQgaXNDbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHdhaXRGb3JOZXdTdHJlYW0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICBjb25zdCBwcm9jZXNzUHVsbCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDbG9zZWQgJiYgaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBhd2FpdCB3YWl0Rm9yTmV3U3RyZWFtLnByb21pc2U7XG4gICAgICByZXR1cm4gcHJvY2Vzc1B1bGwoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGlubmVyU3RyZWFtUmVhZGVyc1swXS5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXdhaXQgcHJvY2Vzc1B1bGwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlclBhcmFtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyUGFyYW07XG4gICAgICB9LFxuICAgICAgcHVsbDogcHJvY2Vzc1B1bGwsXG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIGlubmVyU3RyZWFtUmVhZGVycykge1xuICAgICAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGFkZFN0cmVhbTogKGlubmVyU3RyZWFtKSA9PiB7XG4gICAgICBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBpbm5lciBzdHJlYW06IG91dGVyIHN0cmVhbSBpcyBjbG9zZWRcIik7XG4gICAgICB9XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMucHVzaChpbm5lclN0cmVhbS5nZXRSZWFkZXIoKSk7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdyYWNlZnVsbHkgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS4gVGhpcyB3aWxsIGxldCB0aGUgaW5uZXIgc3RyZWFtc1xuICAgICAqIGZpbmlzaCBwcm9jZXNzaW5nIGFuZCB0aGVuIGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uXG4gICAgICovXG4gICAgY2xvc2U6ICgpID0+IHtcbiAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIHdhaXRGb3JOZXdTdHJlYW0ucmVzb2x2ZSgpO1xuICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS4gVGhpcyB3aWxsIGNhbmNlbCBhbGwgaW5uZXIgc3RyZWFtc1xuICAgICAqIGFuZCBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIHRlcm1pbmF0ZTogKCkgPT4ge1xuICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuZm9yRWFjaCgocmVhZGVyKSA9PiByZWFkZXIuY2FuY2VsKCkpO1xuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9kZWxheWVkLXByb21pc2UudHNcbnZhciBEZWxheWVkUHJvbWlzZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicGVuZGluZ1wiIH07XG4gICAgdGhpcy5fcmVzb2x2ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9yZWplY3QgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlc29sdmVkXCIpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLnN0YXR1cy52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzLnR5cGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICByZWplY3QodGhpcy5zdGF0dXMuZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcbiAgfVxuICByZXNvbHZlKHZhbHVlKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicmVzb2x2ZWRcIiwgdmFsdWUgfTtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICAoX2ExNyA9IHRoaXMuX3Jlc29sdmUpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZWplY3QoZXJyb3IpIHtcbiAgICB2YXIgX2ExNztcbiAgICB0aGlzLnN0YXR1cyA9IHsgdHlwZTogXCJyZWplY3RlZFwiLCBlcnJvciB9O1xuICAgIGlmICh0aGlzLnByb21pc2UpIHtcbiAgICAgIChfYTE3ID0gdGhpcy5fcmVqZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsL25vdy50c1xuZnVuY3Rpb24gbm93KCkge1xuICB2YXIgX2ExNywgX2I7XG4gIHJldHVybiAoX2IgPSAoX2ExNyA9IGdsb2JhbFRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3Lm5vdygpKSAhPSBudWxsID8gX2IgOiBEYXRlLm5vdygpO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9zdHJlYW0tb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMiA9IGNyZWF0ZUlkR2VuZXJhdG9yMih7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmZ1bmN0aW9uIHN0cmVhbU9iamVjdChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtb2RlbCxcbiAgICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBoZWFkZXJzLFxuICAgIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgb25FcnJvcixcbiAgICBvbkZpbmlzaCxcbiAgICBfaW50ZXJuYWw6IHtcbiAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMixcbiAgICAgIGN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICBub3c6IG5vdzIgPSBub3dcbiAgICB9ID0ge30sXG4gICAgLi4uc2V0dGluZ3NcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGVudW1WYWx1ZXMgPSBcImVudW1cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuZW51bSA/IG9wdGlvbnMuZW51bSA6IHZvaWQgMDtcbiAgY29uc3Qge1xuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgc2NoZW1hTmFtZVxuICB9ID0gXCJzY2hlbWFcIiBpbiBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgc2NoZW1hTmFtZSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBlbnVtVmFsdWVzXG4gIH0pO1xuICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1PYmplY3RSZXN1bHQoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXMsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWwsXG4gICAgaGVhZGVycyxcbiAgICB0ZWxlbWV0cnksXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBvdXRwdXRTdHJhdGVneSxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgY3VycmVudERhdGUsXG4gICAgbm93OiBub3cyXG4gIH0pIHtcbiAgICB0aGlzLm9iamVjdFByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YVByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLndhcm5pbmdzUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIHRoaXMucmVxdWVzdFByb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlUHJvbWlzZSA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmdcbiAgICB9KTtcbiAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIG1vZGVsLFxuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKHsgZXJyb3I6IGNodW5rLmVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbS5zdHJlYW0ucGlwZVRocm91Z2goZXZlbnRQcm9jZXNzb3IpO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYVwiOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hICE9IG51bGwgPyB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKSB9IDogdm9pZCAwLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgZm46IGFzeW5jIChyb290U3BhbikgPT4ge1xuICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgICAgcmVzcG9uc2VGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgbW9kZWwuc3VwcG9ydGVkVXJsc1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbSwgcmVzcG9uc2UsIHJlcXVlc3QgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgICB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjYWxsT3B0aW9ucy5wcm9tcHQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBjYWxsU2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogY2FsbFNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogY2FsbFNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBjYWxsU2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9TdHJlYW1TcGFuMikgPT4gKHtcbiAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgbW9kZWwuZG9TdHJlYW0oY2FsbE9wdGlvbnMpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHNlbGYucmVxdWVzdFByb21pc2UucmVzb2x2ZShyZXF1ZXN0ICE9IG51bGwgPyByZXF1ZXN0IDoge30pO1xuICAgICAgICBsZXQgd2FybmluZ3M7XG4gICAgICAgIGxldCB1c2FnZSA9IHtcbiAgICAgICAgICBpbnB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgIHRvdGFsVG9rZW5zOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGZpbmlzaFJlYXNvbjtcbiAgICAgICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIGxldCBvYmplY3QyO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgICAgICBsZXQgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgbGV0IGZ1bGxSZXNwb25zZSA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbGF0ZXN0T2JqZWN0SnNvbiA9IHZvaWQgMDtcbiAgICAgICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICAgICAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICAgIGxldCBpc0ZpcnN0RGVsdGEgPSB0cnVlO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKSkucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF9hMTcsIF9iLCBfYztcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJvYmplY3RcIiAmJiBjaHVuay50eXBlID09PSBcInN0cmVhbS1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgd2FybmluZ3MgPSBjaHVuay53YXJuaW5ncztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaXJzdENodW5rID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXBNcztcbiAgICAgICAgICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiLCB7XG4gICAgICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGEgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogY3VycmVudE9iamVjdEpzb24sIHN0YXRlOiBwYXJzZVN0YXRlIH0gPSBhd2FpdCBwYXJzZVBhcnRpYWxKc29uKGFjY3VtdWxhdGVkVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRPYmplY3RKc29uICE9PSB2b2lkIDAgJiYgIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3RKc29uLCBjdXJyZW50T2JqZWN0SnNvbikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZVBhcnRpYWxSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3VycmVudE9iamVjdEpzb24sXG4gICAgICAgICAgICAgICAgICAgIHRleHREZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0RGVsdGEsXG4gICAgICAgICAgICAgICAgICAgIGlzRmluYWxEZWx0YTogcGFyc2VTdGF0ZSA9PT0gXCJzdWNjZXNzZnVsLXBhcnNlXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2VzcyAmJiAhaXNEZWVwRXF1YWxEYXRhKFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbFxuICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3RKc29uID0gY3VycmVudE9iamVjdEpzb247XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbDtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogbGF0ZXN0T2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHREZWx0YTogdmFsaWRhdGlvblJlc3VsdC52YWx1ZS50ZXh0RGVsdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRleHREZWx0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIGZ1bGxSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IChfYTE3ID0gY2h1bmsuaWQpICE9IG51bGwgPyBfYTE3IDogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYiA9IGNodW5rLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9iIDogZnVsbFJlc3BvbnNlLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jIDogZnVsbFJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICBpZiAodGV4dERlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGEgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgICB1c2FnZSA9IGNodW5rLnVzYWdlO1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBmdWxsUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgc2VsZi51c2FnZVByb21pc2UucmVzb2x2ZSh1c2FnZSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlLnJlc29sdmUocHJvdmlkZXJNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLnJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVGaW5hbFJlc3VsdChcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGFjY3VtdWxhdGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgIHVzYWdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDIgPSB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdFByb21pc2UucmVzb2x2ZShvYmplY3QyKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogYWNjdW11bGF0ZWRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBmdWxsUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IGZ1bGxSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IGZ1bGxSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IGZ1bGxSZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBmaW5hbFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IGZpbmFsVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW2ZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogZnVsbFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IGZ1bGxSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBmaW5hbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IGZpbmFsVXNhZ2UudG90YWxUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogZmluYWxVc2FnZS5yZWFzb25pbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0MilcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBmaW5hbFVzYWdlLFxuICAgICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QyLFxuICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5mdWxsUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBlcnJvcjIgfSk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcm9vdFNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBzdGl0Y2hhYmxlU3RyZWFtLmFkZFN0cmVhbSh0cmFuc2Zvcm1lZFN0cmVhbSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBzdGl0Y2hhYmxlU3RyZWFtLmFkZFN0cmVhbShcbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBzdGl0Y2hhYmxlU3RyZWFtLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5vdXRwdXRTdHJhdGVneSA9IG91dHB1dFN0cmF0ZWd5O1xuICB9XG4gIGdldCBvYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0UHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNhZ2VQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyTWV0YWRhdGFQcm9taXNlLnZhbHVlO1xuICB9XG4gIGdldCB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy53YXJuaW5nc1Byb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHJlc3BvbnNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMuYmFzZVN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5vYmplY3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZ2V0IGVsZW1lbnRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0U3RyYXRlZ3kuY3JlYXRlRWxlbWVudFN0cmVhbSh0aGlzLmJhc2VTdHJlYW0pO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy5iYXNlU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLmJhc2VTdHJlYW0pO1xuICB9XG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSh7XG4gICAgICByZXNwb25zZSxcbiAgICAgIHRleHRTdHJlYW06IHRoaXMudGV4dFN0cmVhbSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSh7XG4gICAgICB0ZXh0U3RyZWFtOiB0aGlzLnRleHRTdHJlYW0sXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9lcnJvci9uby1zcGVlY2gtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgTm9TcGVlY2hHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE4IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQUlfTm9TcGVlY2hHZW5lcmF0ZWRFcnJvclwiLFxuICAgICAgbWVzc2FnZTogXCJObyBzcGVlY2ggYXVkaW8gZ2VuZXJhdGVkLlwiXG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGVkLWF1ZGlvLWZpbGUudHNcbnZhciBEZWZhdWx0R2VuZXJhdGVkQXVkaW9GaWxlID0gY2xhc3MgZXh0ZW5kcyBEZWZhdWx0R2VuZXJhdGVkRmlsZSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXRhLFxuICAgIG1lZGlhVHlwZVxuICB9KSB7XG4gICAgc3VwZXIoeyBkYXRhLCBtZWRpYVR5cGUgfSk7XG4gICAgbGV0IGZvcm1hdCA9IFwibXAzXCI7XG4gICAgaWYgKG1lZGlhVHlwZSkge1xuICAgICAgY29uc3QgbWVkaWFUeXBlUGFydHMgPSBtZWRpYVR5cGUuc3BsaXQoXCIvXCIpO1xuICAgICAgaWYgKG1lZGlhVHlwZVBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAobWVkaWFUeXBlICE9PSBcImF1ZGlvL21wZWdcIikge1xuICAgICAgICAgIGZvcm1hdCA9IG1lZGlhVHlwZVBhcnRzWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQXVkaW8gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgb3IgZGV0ZXJtaW5hYmxlIGZyb20gbWVkaWEgdHlwZVwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgfVxufTtcblxuLy8gY29yZS9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGUtc3BlZWNoLnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVNwZWVjaCh7XG4gIG1vZGVsLFxuICB0ZXh0OiB0ZXh0MixcbiAgdm9pY2UsXG4gIG91dHB1dEZvcm1hdCxcbiAgaW5zdHJ1Y3Rpb25zLFxuICBzcGVlZCxcbiAgcHJvdmlkZXJPcHRpb25zID0ge30sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTE3O1xuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgdGV4dDogdGV4dDIsXG4gICAgICB2b2ljZSxcbiAgICAgIG91dHB1dEZvcm1hdCxcbiAgICAgIGluc3RydWN0aW9ucyxcbiAgICAgIHNwZWVkLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgfSlcbiAgKTtcbiAgaWYgKCFyZXN1bHQuYXVkaW8gfHwgcmVzdWx0LmF1ZGlvLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBOb1NwZWVjaEdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSB9KTtcbiAgfVxuICByZXR1cm4gbmV3IERlZmF1bHRTcGVlY2hSZXN1bHQoe1xuICAgIGF1ZGlvOiBuZXcgRGVmYXVsdEdlbmVyYXRlZEF1ZGlvRmlsZSh7XG4gICAgICBkYXRhOiByZXN1bHQuYXVkaW8sXG4gICAgICBtZWRpYVR5cGU6IChfYTE3ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgZGF0YTogcmVzdWx0LmF1ZGlvLFxuICAgICAgICBzaWduYXR1cmVzOiBhdWRpb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgIH0pKSAhPSBudWxsID8gX2ExNyA6IFwiYXVkaW8vbXAzXCJcbiAgICB9KSxcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0sXG4gICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgfSk7XG59XG52YXIgRGVmYXVsdFNwZWVjaFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTE3O1xuICAgIHRoaXMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge307XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5pbXBvcnQgeyBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuaW1wb3J0IHsgYXNTY2hlbWEgYXMgYXNTY2hlbWEyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50c1xuZnVuY3Rpb24gaXNOb25FbXB0eU9iamVjdChvYmplY3QyKSB7XG4gIHJldHVybiBvYmplY3QyICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0MikubGVuZ3RoID4gMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmZ1bmN0aW9uIHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgYWN0aXZlVG9vbHNcbn0pIHtcbiAgaWYgKCFpc05vbkVtcHR5T2JqZWN0KHRvb2xzKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sczogdm9pZCAwLFxuICAgICAgdG9vbENob2ljZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCBmaWx0ZXJlZFRvb2xzID0gYWN0aXZlVG9vbHMgIT0gbnVsbCA/IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5maWx0ZXIoXG4gICAgKFtuYW1lMTddKSA9PiBhY3RpdmVUb29scy5pbmNsdWRlcyhuYW1lMTcpXG4gICkgOiBPYmplY3QuZW50cmllcyh0b29scyk7XG4gIHJldHVybiB7XG4gICAgdG9vbHM6IGZpbHRlcmVkVG9vbHMubWFwKChbbmFtZTE3LCB0b29sMl0pID0+IHtcbiAgICAgIGNvbnN0IHRvb2xUeXBlID0gdG9vbDIudHlwZTtcbiAgICAgIHN3aXRjaCAodG9vbFR5cGUpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lMTcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBhc1NjaGVtYTIodG9vbDIucGFyYW1ldGVycykuanNvblNjaGVtYVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJwcm92aWRlci1kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvdmlkZXItZGVmaW5lZFwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgYXJnczogdG9vbDIuYXJnc1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0b29sVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRvb2wgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0b29sQ2hvaWNlOiB0b29sQ2hvaWNlID09IG51bGwgPyB7IHR5cGU6IFwiYXV0b1wiIH0gOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogdG9vbENob2ljZSB9IDogeyB0eXBlOiBcInRvb2xcIiwgdG9vbE5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWUgfVxuICB9O1xufVxuXG4vLyBjb3JlL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBhZGRMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UxLCB1c2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLmlucHV0VG9rZW5zLCB1c2FnZTIuaW5wdXRUb2tlbnMpLFxuICAgIG91dHB1dFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLm91dHB1dFRva2VucywgdXNhZ2UyLm91dHB1dFRva2VucyksXG4gICAgdG90YWxUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS50b3RhbFRva2VucywgdXNhZ2UyLnRvdGFsVG9rZW5zKSxcbiAgICByZWFzb25pbmdUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgdXNhZ2UxLnJlYXNvbmluZ1Rva2VucyxcbiAgICAgIHVzYWdlMi5yZWFzb25pbmdUb2tlbnNcbiAgICApLFxuICAgIGNhY2hlZElucHV0VG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgIHVzYWdlMS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgIHVzYWdlMi5jYWNoZWRJbnB1dFRva2Vuc1xuICAgIClcbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZFRva2VuQ291bnRzKHRva2VuQ291bnQxLCB0b2tlbkNvdW50Mikge1xuICByZXR1cm4gdG9rZW5Db3VudDEgPT0gbnVsbCAmJiB0b2tlbkNvdW50MiA9PSBudWxsID8gdm9pZCAwIDogKHRva2VuQ291bnQxICE9IG51bGwgPyB0b2tlbkNvdW50MSA6IDApICsgKHRva2VuQ291bnQyICE9IG51bGwgPyB0b2tlbkNvdW50MiA6IDApO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvYXMtY29udGVudC50c1xuZnVuY3Rpb24gYXNDb250ZW50KHtcbiAgY29udGVudCxcbiAgdG9vbENhbGxzLFxuICB0b29sUmVzdWx0c1xufSkge1xuICByZXR1cm4gW1xuICAgIC4uLmNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGZpbGU6IG5ldyBEZWZhdWx0R2VuZXJhdGVkRmlsZShwYXJ0KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgcmV0dXJuIHRvb2xDYWxscy5maW5kKFxuICAgICAgICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgLi4udG9vbFJlc3VsdHNcbiAgXTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3BhcnNlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWEzLFxuICBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04zLFxuICBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHMsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBzeXN0ZW0sXG4gIG1lc3NhZ2VzXG59KSB7XG4gIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSB9KTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBkb1BhcnNlVG9vbENhbGwoeyB0b29sQ2FsbCwgdG9vbHMgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHJlcGFpclRvb2xDYWxsID09IG51bGwgfHwgIShOb1N1Y2hUb29sRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgfHwgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvci5pc0luc3RhbmNlKGVycm9yKSkpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBsZXQgcmVwYWlyZWRUb29sQ2FsbCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHJlcGFpcmVkVG9vbENhbGwgPSBhd2FpdCByZXBhaXJUb29sQ2FsbCh7XG4gICAgICAgIHRvb2xDYWxsLFxuICAgICAgICB0b29scyxcbiAgICAgICAgcGFyYW1ldGVyU2NoZW1hOiAoeyB0b29sTmFtZSB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwYXJhbWV0ZXJzIH0gPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgcmV0dXJuIGFzU2NoZW1hMyhwYXJhbWV0ZXJzKS5qc29uU2NoZW1hO1xuICAgICAgICB9LFxuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAocmVwYWlyRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBUb29sQ2FsbFJlcGFpckVycm9yKHtcbiAgICAgICAgY2F1c2U6IHJlcGFpckVycm9yLFxuICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyZXBhaXJlZFRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IHJlcGFpcmVkVG9vbENhbGwsIHRvb2xzIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb1BhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEzKHRvb2wyLnBhcmFtZXRlcnMpO1xuICBjb25zdCBwYXJzZVJlc3VsdCA9IHRvb2xDYWxsLmFyZ3MudHJpbSgpID09PSBcIlwiID8gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMzKHsgdmFsdWU6IHt9LCBzY2hlbWEgfSkgOiBhd2FpdCBzYWZlUGFyc2VKU09OMyh7IHRleHQ6IHRvb2xDYWxsLmFyZ3MsIHNjaGVtYSB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGFyZ3M6IHBhcnNlUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwYXJzZVJlc3VsdC52YWx1ZVxuICB9O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RlcC1yZXN1bHQudHNcbnZhciBEZWZhdWx0U3RlcFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgZmluaXNoUmVhc29uLFxuICAgIHVzYWdlLFxuICAgIHdhcm5pbmdzLFxuICAgIHJlcXVlc3QsXG4gICAgcmVzcG9uc2UsXG4gICAgcHJvdmlkZXJNZXRhZGF0YVxuICB9KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IHByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpO1xuICB9XG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIik7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZ1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhc29uaW5nLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHRoaXMucmVhc29uaW5nLm1hcCgocGFydCkgPT4gcGFydC50ZXh0KS5qb2luKFwiXCIpO1xuICB9XG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcImZpbGVcIikubWFwKChwYXJ0KSA9PiBwYXJ0LmZpbGUpO1xuICB9XG4gIGdldCBzb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwic291cmNlXCIpO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIik7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIik7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9zdG9wLWNvbmRpdGlvbi50c1xuZnVuY3Rpb24gbWF4U3RlcHMobWF4U3RlcHMyKSB7XG4gIHJldHVybiAoeyBzdGVwcyB9KSA9PiBzdGVwcy5sZW5ndGggPj0gbWF4U3RlcHMyO1xufVxuZnVuY3Rpb24gaGFzVG9vbENhbGwodG9vbE5hbWUpIHtcbiAgcmV0dXJuICh7IHN0ZXBzIH0pID0+IHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2ExNyA9IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zb21lKFxuICAgICAgKHRvb2xDYWxsKSA9PiB0b29sQ2FsbC50b29sTmFtZSA9PT0gdG9vbE5hbWVcbiAgICApKSAhPSBudWxsID8gX2MgOiBmYWxzZTtcbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3RvLXJlc3BvbnNlLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICBjb250ZW50OiBpbnB1dENvbnRlbnQsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgY29uc3QgY29udGVudCA9IGlucHV0Q29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0b29sLXJlc3VsdFwiICYmIHBhcnQudHlwZSAhPT0gXCJzb3VyY2VcIikuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dC5sZW5ndGggPiAwKS5tYXAoKHBhcnQpID0+IHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgZGF0YTogcGFydC5maWxlLmJhc2U2NCxcbiAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQuZmlsZS5tZWRpYVR5cGVcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjpcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHRvb2xSZXN1bHRDb250ZW50ID0gaW5wdXRDb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpLm1hcCgodG9vbFJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbFJlc3VsdC50b29sTmFtZV07XG4gICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICB0b29sQ2FsbElkOiB0b29sUmVzdWx0LnRvb2xDYWxsSWQsXG4gICAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICAgIHJlc3VsdDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQodG9vbFJlc3VsdC5yZXN1bHQpLFxuICAgICAgZXhwZXJpbWVudGFsX2NvbnRlbnQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KFxuICAgICAgICB0b29sUmVzdWx0LnJlc3VsdFxuICAgICAgKVxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICB0b29sQ2FsbElkOiB0b29sUmVzdWx0LnRvb2xDYWxsSWQsXG4gICAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICAgIHJlc3VsdDogdG9vbFJlc3VsdC5yZXN1bHRcbiAgICB9O1xuICB9KTtcbiAgaWYgKHRvb2xSZXN1bHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0Q29udGVudFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXNwb25zZU1lc3NhZ2VzO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDMgPSBjcmVhdGVJZEdlbmVyYXRvcjMoe1xuICBwcmVmaXg6IFwiYWl0eHRcIixcbiAgc2l6ZTogMjRcbn0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBjb250aW51ZVVudGlsID0gbWF4U3RlcHMoMSksXG4gIGV4cGVyaW1lbnRhbF9vdXRwdXQ6IG91dHB1dCxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9wcmVwYXJlU3RlcDogcHJlcGFyZVN0ZXAsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMyxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgb25TdGVwRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzXG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gbW9kZWw6XG4gICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgIFwiYWkubW9kZWwuaWRcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICB2YXIgX2ExNywgX2IsIF9jLCBfZDtcbiAgICAgIGNvbnN0IGNhbGxTZXR0aW5nczIgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgIGxldCBjdXJyZW50VG9vbENhbGxzID0gW107XG4gICAgICBsZXQgY3VycmVudFRvb2xSZXN1bHRzID0gW107XG4gICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gICAgICBjb25zdCBzdGVwcyA9IFtdO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBzdGVwSW5wdXRNZXNzYWdlcyA9IFtcbiAgICAgICAgICAuLi5pbml0aWFsUHJvbXB0Lm1lc3NhZ2VzLFxuICAgICAgICAgIC4uLnJlc3BvbnNlTWVzc2FnZXNcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcHJlcGFyZVN0ZXBSZXN1bHQgPSBhd2FpdCAocHJlcGFyZVN0ZXAgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwKHtcbiAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICBzdGVwcyxcbiAgICAgICAgICBzdGVwTnVtYmVyOiBzdGVwcy5sZW5ndGhcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgc3lzdGVtOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgbW9kZWwuc3VwcG9ydGVkVXJsc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3RlcE1vZGVsID0gKF9hMTcgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQubW9kZWwpICE9IG51bGwgPyBfYTE3IDogbW9kZWw7XG4gICAgICAgIGNvbnN0IHsgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsIHRvb2xzOiBzdGVwVG9vbHMgfSA9IHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIHRvb2xDaG9pY2U6IChfYiA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC50b29sQ2hvaWNlKSAhPSBudWxsID8gX2IgOiB0b29sQ2hvaWNlLFxuICAgICAgICAgIGFjdGl2ZVRvb2xzOiAoX2MgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuZXhwZXJpbWVudGFsX2FjdGl2ZVRvb2xzKSAhPSBudWxsID8gX2MgOiBhY3RpdmVUb29sc1xuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2ExODtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gbW9kZWw6XG4gICAgICAgICAgICAgICAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgIFwiYWkubW9kZWwuaWRcIjogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAvLyBwcm9tcHQ6XG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RlcFRvb2xzID09IG51bGwgPyB2b2lkIDAgOiBzdGVwVG9vbHMubWFwKCh0b29sMikgPT4gSlNPTi5zdHJpbmdpZnkodG9vbDIpKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RlcFRvb2xDaG9pY2UgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHN0ZXBUb29sQ2hvaWNlKSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IChfYTE4ID0gc2V0dGluZ3MudGVtcGVyYXR1cmUpICE9IG51bGwgPyBfYTE4IDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTksIF9iMiwgX2MyLCBfZDIsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0ZXBNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgIC4uLmNhbGxTZXR0aW5nczIsXG4gICAgICAgICAgICAgICAgICB0b29sczogc3RlcFRvb2xzLFxuICAgICAgICAgICAgICAgICAgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogb3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQsXG4gICAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgaWQ6IChfYjIgPSAoX2ExOSA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTkuaWQpICE9IG51bGwgPyBfYjIgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QyID0gKF9jMiA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi50aW1lc3RhbXApICE9IG51bGwgPyBfZDIgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UubW9kZWxJZCkgIT0gbnVsbCA/IF9mIDogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzOiAoX2cgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgYm9keTogKF9oID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2guYm9keVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGV4dHJhY3RDb250ZW50VGV4dChyZXN1bHQuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhyZXN1bHQuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b29sQ2FsbHMgPT0gbnVsbCA/IHZvaWQgMCA6IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQudXNhZ2Uub3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0LmZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2Uub3V0cHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHJlc3BvbnNlOiByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBjdXJyZW50VG9vbENhbGxzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiXG4gICAgICAgICAgKS5tYXAoXG4gICAgICAgICAgICAodG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIHJlcGFpclRvb2xDYWxsLFxuICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnRUb29sUmVzdWx0cyA9IHRvb2xzID09IG51bGwgPyBbXSA6IGF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdGVwQ29udGVudCA9IGFzQ29udGVudCh7XG4gICAgICAgICAgY29udGVudDogY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCxcbiAgICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbFJlc3VsdHM6IGN1cnJlbnRUb29sUmVzdWx0c1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgIC4uLnRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICAgIHRvb2xzOiB0b29scyAhPSBudWxsID8gdG9vbHMgOiB7fVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0gbmV3IERlZmF1bHRTdGVwUmVzdWx0KHtcbiAgICAgICAgICBjb250ZW50OiBzdGVwQ29udGVudCxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICB1c2FnZTogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UsXG4gICAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgcmVxdWVzdDogKF9kID0gY3VycmVudE1vZGVsUmVzcG9uc2UucmVxdWVzdCkgIT0gbnVsbCA/IF9kIDoge30sXG4gICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgICAgLy8gZGVlcCBjbG9uZSBtc2dzIHRvIGF2b2lkIG11dGF0aW5nIHBhc3QgbWVzc2FnZXMgaW4gbXVsdGktc3RlcDpcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBzdHJ1Y3R1cmVkQ2xvbmUocmVzcG9uc2VNZXNzYWdlcylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICB9IHdoaWxlIChcbiAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgIGN1cnJlbnRUb29sQ2FsbHMubGVuZ3RoID4gMCAmJiAvLyBhbGwgY3VycmVudCB0b29sIGNhbGxzIGhhdmUgcmVzdWx0czpcbiAgICAgICAgY3VycmVudFRvb2xSZXN1bHRzLmxlbmd0aCA9PT0gY3VycmVudFRvb2xDYWxscy5sZW5ndGggJiYgLy8gY29udGludWUgdW50aWwgdGhlIHN0b3AgY29uZGl0aW9uIGlzIG1ldDpcbiAgICAgICAgIWF3YWl0IGNvbnRpbnVlVW50aWwoeyBzdGVwcyB9KVxuICAgICAgKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZXh0cmFjdENvbnRlbnRUZXh0KGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbENhbGxzID09IG51bGwgPyB2b2lkIDAgOiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVE9ETyByZW5hbWUgdGVsZW1ldHJ5IGF0dHJpYnV0ZXMgdG8gaW5wdXRUb2tlbnMgYW5kIG91dHB1dFRva2Vuc1xuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGxhc3RTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQoe1xuICAgICAgICBzdGVwcyxcbiAgICAgICAgcmVzb2x2ZWRPdXRwdXQ6IGF3YWl0IChvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5wYXJzZU91dHB1dChcbiAgICAgICAgICB7IHRleHQ6IGxhc3RTdGVwLnRleHQgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXNwb25zZTogbGFzdFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICB1c2FnZTogbGFzdFN0ZXAudXNhZ2UsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGxhc3RTdGVwLmZpbmlzaFJlYXNvblxuICAgICAgICAgIH1cbiAgICAgICAgKSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlVG9vbHMoe1xuICB0b29sQ2FsbHMsXG4gIHRvb2xzLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgbWVzc2FnZXMsXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChhc3luYyAoeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgYXJncyB9KSA9PiB7XG4gICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgIGlmICgodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLmV4ZWN1dGUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlY29yZFNwYW4oe1xuICAgICAgICBuYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xOYW1lLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5pZFwiOiB0b29sQ2FsbElkLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShhcmdzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHRyYWNlcixcbiAgICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0b29sMi5leGVjdXRlKGFyZ3MsIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0MilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvb2xFeGVjdXRpb25FcnJvcih7XG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICB0b29sQXJnczogYXJncyxcbiAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgcmVzdWx0XG4gICAgICB9O1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgKHJlc3VsdCkgPT4gcmVzdWx0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5zdGVwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5yZXNvbHZlZE91dHB1dCA9IG9wdGlvbnMucmVzb2x2ZWRPdXRwdXQ7XG4gIH1cbiAgZ2V0IGZpbmFsU3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwc1t0aGlzLnN0ZXBzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5jb250ZW50O1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50ZXh0O1xuICB9XG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZmlsZXM7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZ1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlYXNvbmluZ1RleHQ7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucmVhc29uaW5nO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRvb2xDYWxscztcbiAgfVxuICBnZXQgdG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRvb2xSZXN1bHRzO1xuICB9XG4gIGdldCBzb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5zb3VyY2VzO1xuICB9XG4gIGdldCBmaW5pc2hSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmZpbmlzaFJlYXNvbjtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLndhcm5pbmdzO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5wcm92aWRlck1ldGFkYXRhO1xuICB9XG4gIGdldCByZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucmVzcG9uc2U7XG4gIH1cbiAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlcXVlc3Q7XG4gIH1cbiAgZ2V0IHVzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC51c2FnZTtcbiAgfVxuICBnZXQgdG90YWxVc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcy5yZWR1Y2UoXG4gICAgICAodG90YWxVc2FnZSwgc3RlcCkgPT4ge1xuICAgICAgICByZXR1cm4gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHRvdGFsVXNhZ2UsIHN0ZXAudXNhZ2UpO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgb3V0cHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgICAgIHRvdGFsVG9rZW5zOiB2b2lkIDAsXG4gICAgICAgIHJlYXNvbmluZ1Rva2Vuczogdm9pZCAwLFxuICAgICAgICBjYWNoZWRJbnB1dFRva2Vuczogdm9pZCAwXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXQgZXhwZXJpbWVudGFsX291dHB1dCgpIHtcbiAgICBpZiAodGhpcy5yZXNvbHZlZE91dHB1dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9PdXRwdXRTcGVjaWZpZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlZE91dHB1dDtcbiAgfVxufTtcbmZ1bmN0aW9uIGFzVG9vbENhbGxzKGNvbnRlbnQpIHtcbiAgY29uc3QgcGFydHMgPSBjb250ZW50LmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiXG4gICk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBwYXJ0cy5tYXAoKHRvb2xDYWxsKSA9PiAoe1xuICAgIHRvb2xDYWxsVHlwZTogdG9vbENhbGwudG9vbENhbGxUeXBlLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgIGFyZ3M6IHRvb2xDYWxsLmFyZ3NcbiAgfSkpO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvb3V0cHV0LnRzXG52YXIgb3V0cHV0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG91dHB1dF9leHBvcnRzLCB7XG4gIG9iamVjdDogKCkgPT4gb2JqZWN0LFxuICB0ZXh0OiAoKSA9PiB0ZXh0XG59KTtcbmltcG9ydCB7XG4gIGFzU2NoZW1hIGFzIGFzU2NoZW1hNCxcbiAgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09ONCxcbiAgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXM0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgdGV4dCA9ICgpID0+ICh7XG4gIHR5cGU6IFwidGV4dFwiLFxuICByZXNwb25zZUZvcm1hdDogeyB0eXBlOiBcInRleHRcIiB9LFxuICBhc3luYyBwYXJzZVBhcnRpYWwoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgcmV0dXJuIHsgcGFydGlhbDogdGV4dDIgfTtcbiAgfSxcbiAgYXN5bmMgcGFyc2VPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgcmV0dXJuIHRleHQyO1xuICB9XG59KTtcbnZhciBvYmplY3QgPSAoe1xuICBzY2hlbWE6IGlucHV0U2NoZW1hXG59KSA9PiB7XG4gIGNvbnN0IHNjaGVtYSA9IGFzU2NoZW1hNChpbnB1dFNjaGVtYSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICByZXNwb25zZUZvcm1hdDoge1xuICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICBzY2hlbWE6IHNjaGVtYS5qc29uU2NoZW1hXG4gICAgfSxcbiAgICBhc3luYyBwYXJzZVBhcnRpYWwoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVBhcnRpYWxKc29uKHRleHQyKTtcbiAgICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZC1pbnB1dFwiOlxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIGNhc2UgXCJyZXBhaXJlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwic3VjY2Vzc2Z1bC1wYXJzZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgbm8gdmFsaWRhdGlvbiBvZiBwYXJ0aWFsIHJlc3VsdHM6XG4gICAgICAgICAgICBwYXJ0aWFsOiByZXN1bHQudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJlc3VsdC5zdGF0ZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnNlIHN0YXRlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSwgY29udGV4dCkge1xuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09ONCh7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0LnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0LnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dC5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXM0KHtcbiAgICAgICAgdmFsdWU6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICBzY2hlbWFcbiAgICAgIH0pO1xuICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IsXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0LmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9zbW9vdGgtc3RyZWFtLnRzXG5pbXBvcnQgeyBkZWxheSBhcyBvcmlnaW5hbERlbGF5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgQ0hVTktJTkdfUkVHRVhQUyA9IHtcbiAgd29yZDogL1xcUytcXHMrL20sXG4gIGxpbmU6IC9cXG4rL21cbn07XG5mdW5jdGlvbiBzbW9vdGhTdHJlYW0oe1xuICBkZWxheUluTXMgPSAxMCxcbiAgY2h1bmtpbmcgPSBcIndvcmRcIixcbiAgX2ludGVybmFsOiB7IGRlbGF5OiBkZWxheTIgPSBvcmlnaW5hbERlbGF5IH0gPSB7fVxufSA9IHt9KSB7XG4gIGxldCBkZXRlY3RDaHVuaztcbiAgaWYgKHR5cGVvZiBjaHVua2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZGV0ZWN0Q2h1bmsgPSAoYnVmZmVyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGNodW5raW5nKGJ1ZmZlcik7XG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2h1bmtpbmcgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBub24tZW1wdHkgc3RyaW5nLmApO1xuICAgICAgfVxuICAgICAgaWYgKCFidWZmZXIuc3RhcnRzV2l0aChtYXRjaCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDaHVua2luZyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIG1hdGNoIHRoYXQgaXMgYSBwcmVmaXggb2YgdGhlIGJ1ZmZlci4gUmVjZWl2ZWQ6IFwiJHttYXRjaH1cIiBleHBlY3RlZCB0byBzdGFydCB3aXRoIFwiJHtidWZmZXJ9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaHVua2luZ1JlZ2V4ID0gdHlwZW9mIGNodW5raW5nID09PSBcInN0cmluZ1wiID8gQ0hVTktJTkdfUkVHRVhQU1tjaHVua2luZ10gOiBjaHVua2luZztcbiAgICBpZiAoY2h1bmtpbmdSZWdleCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IyKHtcbiAgICAgICAgYXJndW1lbnQ6IFwiY2h1bmtpbmdcIixcbiAgICAgICAgbWVzc2FnZTogYENodW5raW5nIG11c3QgYmUgXCJ3b3JkXCIgb3IgXCJsaW5lXCIgb3IgYSBSZWdFeHAuIFJlY2VpdmVkOiAke2NodW5raW5nfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZXRlY3RDaHVuayA9IChidWZmZXIpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gY2h1bmtpbmdSZWdleC5leGVjKGJ1ZmZlcik7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAobWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoWzBdKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGJ1ZmZlciB9KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciArPSBjaHVuay50ZXh0O1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBkZXRlY3RDaHVuayhidWZmZXIpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1hdGNoIH0pO1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShtYXRjaC5sZW5ndGgpO1xuICAgICAgICAgIGF3YWl0IGRlbGF5MihkZWxheUluTXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvYXMtYXJyYXkudHNcbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBbXSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIHN5c3RlbSxcbiAgbWVzc2FnZXMsXG4gIGFib3J0U2lnbmFsLFxuICByZXBhaXJUb29sQ2FsbFxufSkge1xuICBsZXQgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgY29uc3QgdG9vbFJlc3VsdHNTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgYWN0aXZlVG9vbENhbGxzID0ge307XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbFJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgbGV0IGZpbmlzaENodW5rID0gdm9pZCAwO1xuICBmdW5jdGlvbiBhdHRlbXB0Q2xvc2UoKSB7XG4gICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKGZpbmlzaENodW5rICE9IG51bGwpIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoZmluaXNoQ2h1bmspO1xuICAgICAgfVxuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyZWFtLXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nLXBhcnQtZmluaXNoXCI6XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZmlsZTogbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlV2l0aFR5cGUoe1xuICAgICAgICAgICAgICBkYXRhOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IGNodW5rLm1lZGlhVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICBpZiAodG9vbENhbGxTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgIGlmICghYWN0aXZlVG9vbENhbGxzW2NodW5rLnRvb2xDYWxsSWRdKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFjdGl2ZVRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1kZWx0YVwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IGNodW5rLmFyZ3NUZXh0RGVsdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBhd2FpdCBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rLFxuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRvb2xDYWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKHRvb2wyLmV4ZWN1dGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB0b29sRXhlY3V0aW9uSWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbFJlc3VsdHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLmlkXCI6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwuYXJnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5hcmdzKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbikgPT4gdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzLCB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oXG4gICAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgVG9vbEV4ZWN1dGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQ0ID0gY3JlYXRlSWRHZW5lcmF0b3I0KHtcbiAgcHJlZml4OiBcImFpdHh0XCIsXG4gIHNpemU6IDI0XG59KTtcbmZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIG1heFN0ZXBzOiBtYXhTdGVwczIgPSAxLFxuICBleHBlcmltZW50YWxfb3V0cHV0OiBvdXRwdXQsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmcgPSBmYWxzZSxcbiAgdG9vbENhbGxTdHJlYW1pbmcgPSBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmcsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgb25DaHVuayxcbiAgb25FcnJvcixcbiAgb25GaW5pc2gsXG4gIG9uU3RlcEZpbmlzaCxcbiAgX2ludGVybmFsOiB7XG4gICAgbm93OiBub3cyID0gbm93LFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkNCxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgdHJhbnNmb3JtczogYXNBcnJheSh0cmFuc2Zvcm0pLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIG1heFN0ZXBzOiBtYXhTdGVwczIsXG4gICAgb3V0cHV0LFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkM1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbShvdXRwdXQpIHtcbiAgaWYgKCFvdXRwdXQpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgdGV4dDIgPSBcIlwiO1xuICBsZXQgdGV4dENodW5rID0gXCJcIjtcbiAgbGV0IGxhc3RQdWJsaXNoZWRKc29uID0gXCJcIjtcbiAgZnVuY3Rpb24gcHVibGlzaFRleHRDaHVuayh7XG4gICAgY29udHJvbGxlcixcbiAgICBwYXJ0aWFsT3V0cHV0ID0gdm9pZCAwXG4gIH0pIHtcbiAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgcGFydDogeyB0eXBlOiBcInRleHRcIiwgdGV4dDogdGV4dENodW5rIH0sXG4gICAgICBwYXJ0aWFsT3V0cHV0XG4gICAgfSk7XG4gICAgdGV4dENodW5rID0gXCJcIjtcbiAgfVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJmaW5pc2gtc3RlcFwiKSB7XG4gICAgICAgIHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rLnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRleHQyICs9IGNodW5rLnRleHQ7XG4gICAgICB0ZXh0Q2h1bmsgKz0gY2h1bmsudGV4dDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG91dHB1dC5wYXJzZVBhcnRpYWwoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50SnNvbiA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5wYXJ0aWFsKTtcbiAgICAgICAgaWYgKGN1cnJlbnRKc29uICE9PSBsYXN0UHVibGlzaGVkSnNvbikge1xuICAgICAgICAgIHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyLCBwYXJ0aWFsT3V0cHV0OiByZXN1bHQucGFydGlhbCB9KTtcbiAgICAgICAgICBsYXN0UHVibGlzaGVkSnNvbiA9IGN1cnJlbnRKc29uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICBpZiAodGV4dENodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlLFxuICAgIHRvb2xDYWxsU3RyZWFtaW5nLFxuICAgIHRyYW5zZm9ybXMsXG4gICAgYWN0aXZlVG9vbHMsXG4gICAgcmVwYWlyVG9vbENhbGwsXG4gICAgbWF4U3RlcHM6IG1heFN0ZXBzMixcbiAgICBvdXRwdXQsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIG5vdzogbm93MixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25TdGVwRmluaXNoXG4gIH0pIHtcbiAgICB0aGlzLnRvdGFsVXNhZ2VQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5maW5pc2hSZWFzb25Qcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5zdGVwc1Byb21pc2UgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICBpZiAobWF4U3RlcHMyIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFN0ZXBzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhTdGVwczIsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4U3RlcHMgbXVzdCBiZSBhdCBsZWFzdCAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB0aGlzLmdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkMztcbiAgICBsZXQgYWN0aXZlUmVhc29uaW5nUGFydCA9IHZvaWQgMDtcbiAgICBsZXQgcmVjb3JkZWRDb250ZW50ID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRSZXNwb25zZU1lc3NhZ2VzID0gW107XG4gICAgbGV0IHJlY29yZGVkRmluaXNoUmVhc29uID0gdm9pZCAwO1xuICAgIGxldCByZWNvcmRlZFRvdGFsVXNhZ2UgPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkUmVxdWVzdCA9IHt9O1xuICAgIGxldCByZWNvcmRlZFdhcm5pbmdzID0gW107XG4gICAgY29uc3QgcmVjb3JkZWRTdGVwcyA9IFtdO1xuICAgIGxldCByb290U3BhbjtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGNvbnN0IHsgcGFydCB9ID0gY2h1bms7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiIHx8IHBhcnQudHlwZSA9PT0gXCJyZWFzb25pbmdcIiB8fCBwYXJ0LnR5cGUgPT09IFwic291cmNlXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGwtc3RyZWFtaW5nLXN0YXJ0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtY2FsbC1kZWx0YVwiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuazogcGFydCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoeyBlcnJvcjogcGFydC5lcnJvciB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICBjb25zdCBsYXRlc3RDb250ZW50ID0gcmVjb3JkZWRDb250ZW50W3JlY29yZGVkQ29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoKGxhdGVzdENvbnRlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdENvbnRlbnQudHlwZSkgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBsYXRlc3RDb250ZW50LnRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBwYXJ0LnRleHQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nXCIpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlUmVhc29uaW5nUGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdQYXJ0ID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKGFjdGl2ZVJlYXNvbmluZ1BhcnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdQYXJ0LnRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgYWN0aXZlUmVhc29uaW5nUGFydC5wcm92aWRlck1ldGFkYXRhID0gcGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInJlYXNvbmluZy1wYXJ0LWZpbmlzaFwiICYmIGFjdGl2ZVJlYXNvbmluZ1BhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGFjdGl2ZVJlYXNvbmluZ1BhcnQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaCh7IHR5cGU6IFwiZmlsZVwiLCBmaWxlOiBwYXJ0LmZpbGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInN0YXJ0LXN0ZXBcIikge1xuICAgICAgICAgIHJlY29yZGVkUmVxdWVzdCA9IHBhcnQucmVxdWVzdDtcbiAgICAgICAgICByZWNvcmRlZFdhcm5pbmdzID0gcGFydC53YXJuaW5ncztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImZpbmlzaC1zdGVwXCIpIHtcbiAgICAgICAgICBjb25zdCBzdGVwTWVzc2FnZXMgPSB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgY29udGVudDogcmVjb3JkZWRDb250ZW50LFxuICAgICAgICAgICAgdG9vbHM6IHRvb2xzICE9IG51bGwgPyB0b29scyA6IHt9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSBuZXcgRGVmYXVsdFN0ZXBSZXN1bHQoe1xuICAgICAgICAgICAgY29udGVudDogcmVjb3JkZWRDb250ZW50LFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBwYXJ0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHVzYWdlOiBwYXJ0LnVzYWdlLFxuICAgICAgICAgICAgd2FybmluZ3M6IHJlY29yZGVkV2FybmluZ3MsXG4gICAgICAgICAgICByZXF1ZXN0OiByZWNvcmRlZFJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAuLi5wYXJ0LnJlc3BvbnNlLFxuICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLnJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcywgLi4uc3RlcE1lc3NhZ2VzXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF3YWl0IChvblN0ZXBGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcEZpbmlzaChjdXJyZW50U3RlcFJlc3VsdCkpO1xuICAgICAgICAgIHJlY29yZGVkU3RlcHMucHVzaChjdXJyZW50U3RlcFJlc3VsdCk7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50ID0gW107XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nUGFydCA9IHZvaWQgMDtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMucHVzaCguLi5zdGVwTWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFRvdGFsVXNhZ2UgPSBwYXJ0LnRvdGFsVXNhZ2U7XG4gICAgICAgICAgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSBwYXJ0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocmVjb3JkZWRTdGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmluaXNoUmVhc29uID0gcmVjb3JkZWRGaW5pc2hSZWFzb24gIT0gbnVsbCA/IHJlY29yZGVkRmluaXNoUmVhc29uIDogXCJ1bmtub3duXCI7XG4gICAgICAgICAgY29uc3QgdG90YWxVc2FnZSA9IHJlY29yZGVkVG90YWxVc2FnZSAhPSBudWxsID8gcmVjb3JkZWRUb3RhbFVzYWdlIDoge1xuICAgICAgICAgICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgc2VsZi5maW5pc2hSZWFzb25Qcm9taXNlLnJlc29sdmUoZmluaXNoUmVhc29uKTtcbiAgICAgICAgICBzZWxmLnRvdGFsVXNhZ2VQcm9taXNlLnJlc29sdmUodG90YWxVc2FnZSk7XG4gICAgICAgICAgc2VsZi5zdGVwc1Byb21pc2UucmVzb2x2ZShyZWNvcmRlZFN0ZXBzKTtcbiAgICAgICAgICBjb25zdCBmaW5hbFN0ZXAgPSByZWNvcmRlZFN0ZXBzW3JlY29yZGVkU3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICB0b3RhbFVzYWdlLFxuICAgICAgICAgICAgdXNhZ2U6IGZpbmFsU3RlcC51c2FnZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGZpbmFsU3RlcC5jb250ZW50LFxuICAgICAgICAgICAgdGV4dDogZmluYWxTdGVwLnRleHQsXG4gICAgICAgICAgICByZWFzb25pbmdUZXh0OiBmaW5hbFN0ZXAucmVhc29uaW5nVGV4dCxcbiAgICAgICAgICAgIHJlYXNvbmluZzogZmluYWxTdGVwLnJlYXNvbmluZyxcbiAgICAgICAgICAgIGZpbGVzOiBmaW5hbFN0ZXAuZmlsZXMsXG4gICAgICAgICAgICBzb3VyY2VzOiBmaW5hbFN0ZXAuc291cmNlcyxcbiAgICAgICAgICAgIHRvb2xDYWxsczogZmluYWxTdGVwLnRvb2xDYWxscyxcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBmaW5hbFN0ZXAudG9vbFJlc3VsdHMsXG4gICAgICAgICAgICByZXF1ZXN0OiBmaW5hbFN0ZXAucmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBmaW5hbFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICB3YXJuaW5nczogZmluYWxTdGVwLndhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZmluYWxTdGVwLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IGZpbmFsU3RlcC50ZXh0IH0sXG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTE3O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChfYTE3ID0gZmluYWxTdGVwLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KGZpbmFsU3RlcC50b29sQ2FsbHMpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5pbnB1dFRva2Vuc1wiOiB0b3RhbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2Uub3V0cHV0VG9rZW5zXCI6IHRvdGFsVXNhZ2Uub3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG90YWxUb2tlbnNcIjogdG90YWxVc2FnZS50b3RhbFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnJlYXNvbmluZ1Rva2Vuc1wiOiB0b3RhbFVzYWdlLnJlYXNvbmluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNhY2hlZElucHV0VG9rZW5zXCI6IHRvdGFsVXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICB0aGlzLmFkZFN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtO1xuICAgIHRoaXMuY2xvc2VTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLmNsb3NlO1xuICAgIGxldCBzdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbTtcbiAgICBzdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwic3RhcnRcIiB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtIG9mIHRyYW5zZm9ybXMpIHtcbiAgICAgIHN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgdHJhbnNmb3JtKHtcbiAgICAgICAgICB0b29scyxcbiAgICAgICAgICBzdG9wU3RyZWFtKCkge1xuICAgICAgICAgICAgc3RpdGNoYWJsZVN0cmVhbS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmJhc2VTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlT3V0cHV0VHJhbnNmb3JtU3RyZWFtKG91dHB1dCkpLnBpcGVUaHJvdWdoKGV2ZW50UHJvY2Vzc29yKTtcbiAgICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnXG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gICAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICBtb2RlbCxcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJhaS5zZXR0aW5ncy5tYXhTdGVwc1wiOiBtYXhTdGVwczJcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0cmFjZXIsXG4gICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICBmbjogYXN5bmMgKHJvb3RTcGFuQXJnKSA9PiB7XG4gICAgICAgIHJvb3RTcGFuID0gcm9vdFNwYW5Bcmc7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgdXNhZ2VcbiAgICAgICAgfSkge1xuICAgICAgICAgIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBhd2FpdCBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHN0ZXBJbnB1dE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgLi4uaW5pdGlhbFByb21wdC5tZXNzYWdlcyxcbiAgICAgICAgICAgIC4uLnJlc3BvbnNlTWVzc2FnZXNcbiAgICAgICAgICBdO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgc3lzdGVtOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgbW9kZWwuc3VwcG9ydGVkVXJsc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHRvb2xzQW5kVG9vbENob2ljZSA9IHtcbiAgICAgICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSwgYWN0aXZlVG9vbHMgfSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW06IHN0cmVhbTIsIHJlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zXG4gICAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTE3O1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2ExNyA9IHRvb2xzQW5kVG9vbENob2ljZS50b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMilcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB0b29sc0FuZFRvb2xDaG9pY2UudG9vbENob2ljZSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkodG9vbHNBbmRUb29sQ2hvaWNlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBjYWxsU2V0dGluZ3MubWF4T3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IGNhbGxTZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBjYWxsU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBjYWxsU2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNhbGxTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgLi4udG9vbHNBbmRUb29sQ2hvaWNlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogb3V0cHV0ID09IG51bGwgPyB2b2lkIDAgOiBvdXRwdXQucmVzcG9uc2VGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gcnVuVG9vbHNUcmFuc2Zvcm1hdGlvbih7XG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtMixcbiAgICAgICAgICAgIHRvb2xDYWxsU3RyZWFtaW5nLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHN0ZXBSZXF1ZXN0ID0gcmVxdWVzdCAhPSBudWxsID8gcmVxdWVzdCA6IHt9O1xuICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHMgPSBbXTtcbiAgICAgICAgICBjb25zdCBzdGVwVG9vbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBsZXQgd2FybmluZ3M7XG4gICAgICAgICAgY29uc3Qgc3RlcENvbnRlbnQgPSBbXTtcbiAgICAgICAgICBsZXQgYWN0aXZlUmVhc29uaW5nUGFydDIgPSB2b2lkIDA7XG4gICAgICAgICAgbGV0IHN0ZXBGaW5pc2hSZWFzb24gPSBcInVua25vd25cIjtcbiAgICAgICAgICBsZXQgc3RlcFVzYWdlID0ge1xuICAgICAgICAgICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgbGV0IHN0ZXBQcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIGxldCBzdGVwRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgbGV0IHN0ZXBUZXh0ID0gXCJcIjtcbiAgICAgICAgICBsZXQgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiBwdWJsaXNoVGV4dENodW5rKHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICBjaHVua1xuICAgICAgICAgIH0pIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICBzdGVwVGV4dCArPSBjaHVuay50ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTE3LCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwic3RyZWFtLXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MgPSBjaHVuay53YXJuaW5ncztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHN0ZXBGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaXJzdENodW5rID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXBNcztcbiAgICAgICAgICAgICAgICAgICAgc3RlcEZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhcnQtc3RlcFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHN0ZXBSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHRcIiAmJiBjaHVuay50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyLCBjaHVuayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmdQYXJ0MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdQYXJ0MiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBDb250ZW50LnB1c2goYWN0aXZlUmVhc29uaW5nUGFydDIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdQYXJ0Mi50ZXh0ICs9IGNodW5rLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVSZWFzb25pbmdQYXJ0Mi5wcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1wYXJ0LWZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUmVhc29uaW5nUGFydDIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcENvbnRlbnQucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBUb29sUmVzdWx0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwQ29udGVudC5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExNyA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExNyA6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IgOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9jID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jIDogc3RlcFJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBVc2FnZSA9IGNodW5rLnVzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBGaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcFByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaW5pc2ggPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maW5pc2hcIik7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmluaXNoXCI6IG1zVG9GaW5pc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmF2Z091dHB1dFRva2Vuc1BlclNlY29uZFwiOiAxZTMgKiAoKF9kID0gc3RlcFVzYWdlLm91dHB1dFRva2VucykgIT0gbnVsbCA/IF9kIDogMCkgLyBtc1RvRmluaXNoXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBDb250ZW50LnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNvdXJjZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcENvbnRlbnQucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxsc0pzb24gPSBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHN0ZXBUb29sQ2FsbHNKc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHN0ZXBSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuaW5wdXRUb2tlbnNcIjogc3RlcFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLm91dHB1dFRva2Vuc1wiOiBzdGVwVXNhZ2Uub3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IHN0ZXBVc2FnZS50b3RhbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5yZWFzb25pbmdUb2tlbnNcIjogc3RlcFVzYWdlLnJlYXNvbmluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jYWNoZWRJbnB1dFRva2Vuc1wiOiBzdGVwVXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3N0ZXBGaW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHN0ZXBSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogc3RlcFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoLXN0ZXBcIixcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZTogc3RlcFVzYWdlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBzdGVwUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjb21iaW5lZFVzYWdlID0gYWRkTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlLCBzdGVwVXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGVwICsgMSA8IG1heFN0ZXBzMiAmJiAvLyB0aGVyZSBhcmUgdG9vbCBjYWxsczpcbiAgICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMubGVuZ3RoID4gMCAmJiAvLyBhbGwgY3VycmVudCB0b29sIGNhbGxzIGhhdmUgcmVzdWx0czpcbiAgICAgICAgICAgICAgICAgIHN0ZXBUb29sUmVzdWx0cy5sZW5ndGggPT09IHN0ZXBUb29sQ2FsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAuLi50b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3RlcENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sczogdG9vbHMgIT0gbnVsbCA/IHRvb2xzIDoge31cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdHJlYW1TdGVwKHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RlcDogY3VycmVudFN0ZXAgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNvbWJpbmVkVXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVXNhZ2U6IGNvbWJpbmVkVXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzdHJlYW1TdGVwKHtcbiAgICAgICAgICBjdXJyZW50U3RlcDogMCxcbiAgICAgICAgICByZXNwb25zZU1lc3NhZ2VzOiBbXSxcbiAgICAgICAgICB1c2FnZToge1xuICAgICAgICAgICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHN0ZXBzKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzUHJvbWlzZS52YWx1ZTtcbiAgfVxuICBnZXQgZmluYWxTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLnRoZW4oKHN0ZXBzKSA9PiBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuY29udGVudCk7XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLndhcm5pbmdzKTtcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5wcm92aWRlck1ldGFkYXRhKTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC50ZXh0KTtcbiAgfVxuICBnZXQgcmVhc29uaW5nVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZWFzb25pbmdUZXh0KTtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlYXNvbmluZyk7XG4gIH1cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuc291cmNlcyk7XG4gIH1cbiAgZ2V0IGZpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLmZpbGVzKTtcbiAgfVxuICBnZXQgdG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAudXNhZ2UpO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlcXVlc3QpO1xuICB9XG4gIGdldCByZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZXNwb25zZSk7XG4gIH1cbiAgZ2V0IHRvdGFsVXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxVc2FnZVByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IGZpbmlzaFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hSZWFzb25Qcm9taXNlLnZhbHVlO1xuICB9XG4gIC8qKlxuICBTcGxpdCBvdXQgYSBuZXcgc3RyZWFtIGZyb20gdGhlIG9yaWdpbmFsIHN0cmVhbS5cbiAgVGhlIG9yaWdpbmFsIHN0cmVhbSBpcyByZXBsYWNlZCB0byBhbGxvdyBmb3IgZnVydGhlciBzcGxpdHRpbmcsXG4gIHNpbmNlIHdlIGRvIG5vdCBrbm93IGhvdyBtYW55IHRpbWVzIHRoZSBzdHJlYW0gd2lsbCBiZSBzcGxpdC5cbiAgXG4gIE5vdGU6IHRoaXMgbGVhZHMgdG8gYnVmZmVyaW5nIHRoZSBzdHJlYW0gY29udGVudCBvbiB0aGUgc2VydmVyLlxuICBIb3dldmVyLCB0aGUgTExNIHJlc3VsdHMgYXJlIGV4cGVjdGVkIHRvIGJlIHNtYWxsIGVub3VnaCB0byBub3QgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICB0ZWVTdHJlYW0oKSB7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gdGhpcy5iYXNlU3RyZWFtLnRlZSgpO1xuICAgIHRoaXMuYmFzZVN0cmVhbSA9IHN0cmVhbTI7XG4gICAgcmV0dXJuIHN0cmVhbTE7XG4gIH1cbiAgZ2V0IHRleHRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0LnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKHsgcGFydCB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgY29uc3VtZVN0cmVhbShvcHRpb25zKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNvbnN1bWVTdHJlYW0oe1xuICAgICAgICBzdHJlYW06IHRoaXMuZnVsbFN0cmVhbSxcbiAgICAgICAgb25FcnJvcjogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vbkVycm9yXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgKF9hMTcgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNhbGwob3B0aW9ucywgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBnZXQgZXhwZXJpbWVudGFsX3BhcnRpYWxPdXRwdXRTdHJlYW0oKSB7XG4gICAgaWYgKHRoaXMub3V0cHV0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb091dHB1dFNwZWNpZmllZEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKHsgcGFydGlhbE91dHB1dCB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAocGFydGlhbE91dHB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0aWFsT3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICB0b1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgbmV3TWVzc2FnZUlkLFxuICAgIG9yaWdpbmFsTWVzc2FnZXMgPSBbXSxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyA9IGZhbHNlLFxuICAgIHNlbmRTb3VyY2VzID0gZmFsc2UsXG4gICAgZXhwZXJpbWVudGFsX3NlbmRTdGFydCA9IHRydWUsXG4gICAgZXhwZXJpbWVudGFsX3NlbmRGaW5pc2ggPSB0cnVlLFxuICAgIG9uRXJyb3IgPSAoKSA9PiBcIkFuIGVycm9yIG9jY3VycmVkLlwiXG4gICAgLy8gbWFzayBlcnJvciBtZXNzYWdlcyBmb3Igc2FmZXR5IGJ5IGRlZmF1bHRcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2VzW29yaWdpbmFsTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaXNDb250aW51YXRpb24gPSAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpID09PSBcImFzc2lzdGFudFwiO1xuICAgIGNvbnN0IG1lc3NhZ2VJZCA9IGlzQ29udGludWF0aW9uID8gbGFzdE1lc3NhZ2UuaWQgOiBuZXdNZXNzYWdlSWQ7XG4gICAgY29uc3QgYmFzZVN0cmVhbSA9IHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm06IGFzeW5jIChwYXJ0LCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydFR5cGUgPSBwYXJ0LnR5cGU7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1wYXJ0LWZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJyZWFzb25pbmctcGFydC1maW5pc2hcIiB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQuZmlsZS5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgdXJsOiBgZGF0YToke3BhcnQuZmlsZS5tZWRpYVR5cGV9O2Jhc2U2NCwke3BhcnQuZmlsZS5iYXNlNjR9YFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic291cmNlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICAgICAgICBzb3VyY2VUeXBlOiBwYXJ0LnNvdXJjZVR5cGUsXG4gICAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAgIHVybDogcGFydC51cmwsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogcGFydC50aXRsZSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiBwYXJ0LmFyZ3NUZXh0RGVsdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnczogcGFydC5hcmdzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHBhcnQucmVzdWx0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yVGV4dDogb25FcnJvcihwYXJ0LmVycm9yKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RhcnQtc3RlcFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbWVzc2FnZU1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlTWV0YWRhdGEoeyBwYXJ0IH0pO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhcnQtc3RlcFwiLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2gtc3RlcFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbWVzc2FnZU1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlTWV0YWRhdGEoeyBwYXJ0IH0pO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoLXN0ZXBcIixcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RhcnRcIjoge1xuICAgICAgICAgICAgICBpZiAoZXhwZXJpbWVudGFsX3NlbmRTdGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbWVzc2FnZU1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlTWV0YWRhdGEoeyBwYXJ0IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChleHBlcmltZW50YWxfc2VuZEZpbmlzaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbWVzc2FnZU1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlTWV0YWRhdGEoeyBwYXJ0IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gcGFydFR5cGU7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAob25GaW5pc2ggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGJhc2VTdHJlYW07XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgICAgbGFzdE1lc3NhZ2UsXG4gICAgICBuZXdNZXNzYWdlSWQ6IG1lc3NhZ2VJZCAhPSBudWxsID8gbWVzc2FnZUlkIDogdGhpcy5nZW5lcmF0ZUlkKClcbiAgICB9KTtcbiAgICBjb25zdCBydW5VcGRhdGVNZXNzYWdlSm9iID0gYXN5bmMgKGpvYikgPT4ge1xuICAgICAgYXdhaXQgam9iKHsgc3RhdGUsIHdyaXRlOiAoKSA9PiB7XG4gICAgICB9IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgc3RyZWFtOiBiYXNlU3RyZWFtLFxuICAgICAgcnVuVXBkYXRlTWVzc2FnZUpvYlxuICAgIH0pLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIH0sXG4gICAgICAgIGZsdXNoKCkge1xuICAgICAgICAgIGNvbnN0IGlzQ29udGludWF0aW9uMiA9IHN0YXRlLm1lc3NhZ2UuaWQgPT09IChsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2UuaWQpO1xuICAgICAgICAgIG9uRmluaXNoKHtcbiAgICAgICAgICAgIGlzQ29udGludWF0aW9uOiBpc0NvbnRpbnVhdGlvbjIsXG4gICAgICAgICAgICByZXNwb25zZU1lc3NhZ2U6IHN0YXRlLm1lc3NhZ2UsXG4gICAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgICAuLi5pc0NvbnRpbnVhdGlvbjIgPyBvcmlnaW5hbE1lc3NhZ2VzLnNsaWNlKDAsIC0xKSA6IG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2VcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgbmV3TWVzc2FnZUlkLFxuICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgb25GaW5pc2gsXG4gICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgIHNlbmRSZWFzb25pbmcsXG4gICAgc2VuZFNvdXJjZXMsXG4gICAgZXhwZXJpbWVudGFsX3NlbmRGaW5pc2gsXG4gICAgZXhwZXJpbWVudGFsX3NlbmRTdGFydCxcbiAgICBvbkVycm9yLFxuICAgIC4uLmluaXRcbiAgfSA9IHt9KSB7XG4gICAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdHJlYW06IHRoaXMudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICBuZXdNZXNzYWdlSWQsXG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgICAgIHNlbmRSZWFzb25pbmcsXG4gICAgICAgIHNlbmRTb3VyY2VzLFxuICAgICAgICBleHBlcmltZW50YWxfc2VuZEZpbmlzaCxcbiAgICAgICAgZXhwZXJpbWVudGFsX3NlbmRTdGFydCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSksXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG4gIHRvVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2Uoe1xuICAgIG5ld01lc3NhZ2VJZCxcbiAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgIG9uRmluaXNoLFxuICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICBzZW5kUmVhc29uaW5nLFxuICAgIHNlbmRTb3VyY2VzLFxuICAgIGV4cGVyaW1lbnRhbF9zZW5kRmluaXNoLFxuICAgIGV4cGVyaW1lbnRhbF9zZW5kU3RhcnQsXG4gICAgb25FcnJvcixcbiAgICAuLi5pbml0XG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gICAgICBzdHJlYW06IHRoaXMudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICBuZXdNZXNzYWdlSWQsXG4gICAgICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgICAgIHNlbmRSZWFzb25pbmcsXG4gICAgICAgIHNlbmRTb3VyY2VzLFxuICAgICAgICBleHBlcmltZW50YWxfc2VuZEZpbmlzaCxcbiAgICAgICAgZXhwZXJpbWVudGFsX3NlbmRTdGFydCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSksXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBjb3JlL21pZGRsZXdhcmUvZGVmYXVsdC1zZXR0aW5ncy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGluZ3NNaWRkbGV3YXJlKHtcbiAgc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlVmVyc2lvbjogXCJ2MlwiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHJldHVybiBtZXJnZU9iamVjdHMoc2V0dGluZ3MsIHBhcmFtcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9nZXQtcG90ZW50aWFsLXN0YXJ0LWluZGV4LnRzXG5mdW5jdGlvbiBnZXRQb3RlbnRpYWxTdGFydEluZGV4KHRleHQyLCBzZWFyY2hlZFRleHQpIHtcbiAgaWYgKHNlYXJjaGVkVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkaXJlY3RJbmRleCA9IHRleHQyLmluZGV4T2Yoc2VhcmNoZWRUZXh0KTtcbiAgaWYgKGRpcmVjdEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBkaXJlY3RJbmRleDtcbiAgfVxuICBmb3IgKGxldCBpID0gdGV4dDIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdWZmaXggPSB0ZXh0Mi5zdWJzdHJpbmcoaSk7XG4gICAgaWYgKHNlYXJjaGVkVGV4dC5zdGFydHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gY29yZS9taWRkbGV3YXJlL2V4dHJhY3QtcmVhc29uaW5nLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZWFzb25pbmdNaWRkbGV3YXJlKHtcbiAgdGFnTmFtZSxcbiAgc2VwYXJhdG9yID0gXCJcXG5cIixcbiAgc3RhcnRXaXRoUmVhc29uaW5nID0gZmFsc2Vcbn0pIHtcbiAgY29uc3Qgb3BlbmluZ1RhZyA9IGA8JHt0YWdOYW1lfT5gO1xuICBjb25zdCBjbG9zaW5nVGFnID0gYDwvJHt0YWdOYW1lfT5gO1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYyXCIsXG4gICAgd3JhcEdlbmVyYXRlOiBhc3luYyAoeyBkb0dlbmVyYXRlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY29udGVudCwgLi4ucmVzdCB9ID0gYXdhaXQgZG9HZW5lcmF0ZSgpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRDb250ZW50ID0gW107XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgICAgICBpZiAocGFydC50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHQyID0gc3RhcnRXaXRoUmVhc29uaW5nID8gb3BlbmluZ1RhZyArIHBhcnQudGV4dCA6IHBhcnQudGV4dDtcbiAgICAgICAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChgJHtvcGVuaW5nVGFnfSguKj8pJHtjbG9zaW5nVGFnfWAsIFwiZ3NcIik7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBBcnJheS5mcm9tKHRleHQyLm1hdGNoQWxsKHJlZ2V4cCkpO1xuICAgICAgICBpZiAoIW1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhc29uaW5nVGV4dCA9IG1hdGNoZXMubWFwKChtYXRjaCkgPT4gbWF0Y2hbMV0pLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgbGV0IHRleHRXaXRob3V0UmVhc29uaW5nID0gdGV4dDI7XG4gICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzW2ldO1xuICAgICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gdGV4dFdpdGhvdXRSZWFzb25pbmcuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IGFmdGVyTWF0Y2ggPSB0ZXh0V2l0aG91dFJlYXNvbmluZy5zbGljZShcbiAgICAgICAgICAgIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0ZXh0V2l0aG91dFJlYXNvbmluZyA9IGJlZm9yZU1hdGNoICsgKGJlZm9yZU1hdGNoLmxlbmd0aCA+IDAgJiYgYWZ0ZXJNYXRjaC5sZW5ndGggPiAwID8gc2VwYXJhdG9yIDogXCJcIikgKyBhZnRlck1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgIHRleHQ6IHJlYXNvbmluZ1RleHRcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiB0ZXh0V2l0aG91dFJlYXNvbmluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGNvbnRlbnQ6IHRyYW5zZm9ybWVkQ29udGVudCwgLi4ucmVzdCB9O1xuICAgIH0sXG4gICAgd3JhcFN0cmVhbTogYXN5bmMgKHsgZG9TdHJlYW0gfSkgPT4ge1xuICAgICAgY29uc3QgeyBzdHJlYW0sIC4uLnJlc3QgfSA9IGF3YWl0IGRvU3RyZWFtKCk7XG4gICAgICBsZXQgaXNGaXJzdFJlYXNvbmluZyA9IHRydWU7XG4gICAgICBsZXQgaXNGaXJzdFRleHQgPSB0cnVlO1xuICAgICAgbGV0IGFmdGVyU3dpdGNoID0gZmFsc2U7XG4gICAgICBsZXQgaXNSZWFzb25pbmcgPSBzdGFydFdpdGhSZWFzb25pbmc7XG4gICAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnVmZmVyICs9IGNodW5rLnRleHQ7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2godGV4dDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dDIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYWZ0ZXJTd2l0Y2ggJiYgKGlzUmVhc29uaW5nID8gIWlzRmlyc3RSZWFzb25pbmcgOiAhaXNGaXJzdFRleHQpID8gc2VwYXJhdG9yIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgaXNSZWFzb25pbmcgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwcmVmaXggKyB0ZXh0MlxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHByZWZpeCArIHRleHQyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBhZnRlclN3aXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3RSZWFzb25pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3RUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFnID0gaXNSZWFzb25pbmcgPyBjbG9zaW5nVGFnIDogb3BlbmluZ1RhZztcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gZ2V0UG90ZW50aWFsU3RhcnRJbmRleChidWZmZXIsIG5leHRUYWcpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHB1Ymxpc2goYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVibGlzaChidWZmZXIuc2xpY2UoMCwgc3RhcnRJbmRleCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kRnVsbE1hdGNoID0gc3RhcnRJbmRleCArIG5leHRUYWcubGVuZ3RoIDw9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kRnVsbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2Uoc3RhcnRJbmRleCArIG5leHRUYWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1JlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInJlYXNvbmluZy1wYXJ0LWZpbmlzaFwiIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNSZWFzb25pbmcgPSAhaXNSZWFzb25pbmc7XG4gICAgICAgICAgICAgICAgICBhZnRlclN3aXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvbWlkZGxld2FyZS9zaW11bGF0ZS1zdHJlYW1pbmctbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlKCkge1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmVWZXJzaW9uOiBcInYyXCIsXG4gICAgd3JhcFN0cmVhbTogYXN5bmMgKHsgZG9HZW5lcmF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBjb25zdCBzaW11bGF0ZWRTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RyZWFtLXN0YXJ0XCIsXG4gICAgICAgICAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJyZXNwb25zZS1tZXRhZGF0YVwiLCAuLi5yZXN1bHQucmVzcG9uc2UgfSk7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHJlc3VsdC5jb250ZW50KSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IHJlc3VsdC51c2FnZSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc2ltdWxhdGVkU3RyZWFtLFxuICAgICAgICByZXF1ZXN0OiByZXN1bHQucmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3VsdC5yZXNwb25zZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvbWlkZGxld2FyZS93cmFwLWxhbmd1YWdlLW1vZGVsLnRzXG52YXIgd3JhcExhbmd1YWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gYXNBcnJheShtaWRkbGV3YXJlQXJnKS5yZXZlcnNlKCkucmVkdWNlKCh3cmFwcGVkTW9kZWwsIG1pZGRsZXdhcmUpID0+IHtcbiAgICByZXR1cm4gZG9XcmFwKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogeyB0cmFuc2Zvcm1QYXJhbXMsIHdyYXBHZW5lcmF0ZSwgd3JhcFN0cmVhbSB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHtcbiAgICBwYXJhbXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgdHlwZSB9KSA6IHBhcmFtcztcbiAgfVxuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYyXCIsXG4gICAgcHJvdmlkZXI6IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogbW9kZWwubW9kZWxJZCxcbiAgICAvLyBUT0RPIG1pZGRsZXdhcmUgc2hvdWxkIGJlIGFibGUgdG8gbW9kaWZ5IHRoZSBzdXBwb3J0ZWQgdXJsc1xuICAgIGdldCBzdXBwb3J0ZWRVcmxzKCkge1xuICAgICAgcmV0dXJuIG1vZGVsLnN1cHBvcnRlZFVybHM7XG4gICAgfSxcbiAgICBhc3luYyBkb0dlbmVyYXRlKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJnZW5lcmF0ZVwiIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgY29uc3QgZG9TdHJlYW0gPSBhc3luYyAoKSA9PiBtb2RlbC5kb1N0cmVhbSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICByZXR1cm4gd3JhcEdlbmVyYXRlID8gd3JhcEdlbmVyYXRlKHtcbiAgICAgICAgZG9HZW5lcmF0ZSxcbiAgICAgICAgZG9TdHJlYW0sXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9LFxuICAgIGFzeW5jIGRvU3RyZWFtKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJzdHJlYW1cIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBTdHJlYW0gPyB3cmFwU3RyZWFtKHsgZG9HZW5lcmF0ZSwgZG9TdHJlYW0sIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9TdHJlYW0oKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L2N1c3RvbS1wcm92aWRlci50c1xuaW1wb3J0IHsgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBjdXN0b21Qcm92aWRlcih7XG4gIGxhbmd1YWdlTW9kZWxzLFxuICB0ZXh0RW1iZWRkaW5nTW9kZWxzLFxuICBpbWFnZU1vZGVscyxcbiAgZmFsbGJhY2tQcm92aWRlclxufSkge1xuICByZXR1cm4ge1xuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGxhbmd1YWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBsYW5ndWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGluZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gdGV4dEVtYmVkZGluZ01vZGVscykge1xuICAgICAgICByZXR1cm4gdGV4dEVtYmVkZGluZ01vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIGltYWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGltYWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBpbWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gaW1hZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5pbWFnZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmltYWdlTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwiaW1hZ2VNb2RlbFwiIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIgPSBjdXN0b21Qcm92aWRlcjtcblxuLy8gY29yZS9yZWdpc3RyeS9uby1zdWNoLXByb3ZpZGVyLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxOSwgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE2ID0gXCJBSV9Ob1N1Y2hQcm92aWRlckVycm9yXCI7XG52YXIgbWFya2VyMTYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE2fWA7XG52YXIgc3ltYm9sMTYgPSBTeW1ib2wuZm9yKG1hcmtlcjE2KTtcbnZhciBfYTE2O1xudmFyIE5vU3VjaFByb3ZpZGVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIE5vU3VjaE1vZGVsRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1vZGVsSWQsXG4gICAgbW9kZWxUeXBlLFxuICAgIHByb3ZpZGVySWQsXG4gICAgYXZhaWxhYmxlUHJvdmlkZXJzLFxuICAgIG1lc3NhZ2UgPSBgTm8gc3VjaCBwcm92aWRlcjogJHtwcm92aWRlcklkfSAoYXZhaWxhYmxlIHByb3ZpZGVyczogJHthdmFpbGFibGVQcm92aWRlcnMuam9pbigpfSlgXG4gIH0pIHtcbiAgICBzdXBlcih7IGVycm9yTmFtZTogbmFtZTE2LCBtb2RlbElkLCBtb2RlbFR5cGUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE2XSA9IHRydWU7XG4gICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICB0aGlzLmF2YWlsYWJsZVByb3ZpZGVycyA9IGF2YWlsYWJsZVByb3ZpZGVycztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNik7XG4gIH1cbn07XG5fYTE2ID0gc3ltYm9sMTY7XG5cbi8vIGNvcmUvcmVnaXN0cnkvcHJvdmlkZXItcmVnaXN0cnkudHNcbmltcG9ydCB7IE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXJSZWdpc3RyeShwcm92aWRlcnMsIHtcbiAgc2VwYXJhdG9yID0gXCI6XCJcbn0gPSB7fSkge1xuICBjb25zdCByZWdpc3RyeSA9IG5ldyBEZWZhdWx0UHJvdmlkZXJSZWdpc3RyeSh7XG4gICAgc2VwYXJhdG9yXG4gIH0pO1xuICBmb3IgKGNvbnN0IFtpZCwgcHJvdmlkZXJdIG9mIE9iamVjdC5lbnRyaWVzKHByb3ZpZGVycykpIHtcbiAgICByZWdpc3RyeS5yZWdpc3RlclByb3ZpZGVyKHsgaWQsIHByb3ZpZGVyIH0pO1xuICB9XG4gIHJldHVybiByZWdpc3RyeTtcbn1cbnZhciBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSA9IGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnk7XG52YXIgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgc2VwYXJhdG9yIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICB9XG4gIHJlZ2lzdGVyUHJvdmlkZXIoe1xuICAgIGlkLFxuICAgIHByb3ZpZGVyXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVyc1tpZF0gPSBwcm92aWRlcjtcbiAgfVxuICBnZXRQcm92aWRlcihpZCkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5wcm92aWRlcnNbaWRdO1xuICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoUHJvdmlkZXJFcnJvcih7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiLFxuICAgICAgICBwcm92aWRlcklkOiBpZCxcbiAgICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBPYmplY3Qua2V5cyh0aGlzLnByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgc3BsaXRJZChpZCwgbW9kZWxUeXBlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpZC5pbmRleE9mKHRoaXMuc2VwYXJhdG9yKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCAke21vZGVsVHlwZX0gaWQgZm9yIHJlZ2lzdHJ5OiAke2lkfSAobXVzdCBiZSBpbiB0aGUgZm9ybWF0IFwicHJvdmlkZXJJZCR7dGhpcy5zZXBhcmF0b3J9bW9kZWxJZFwiKWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lkLnNsaWNlKDAsIGluZGV4KSwgaWQuc2xpY2UoaW5kZXggKyB0aGlzLnNlcGFyYXRvci5sZW5ndGgpXTtcbiAgfVxuICBsYW5ndWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTcsIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJsYW5ndWFnZU1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9iID0gKF9hMTcgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpKS5sYW5ndWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTE3LCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICB0ZXh0RW1iZWRkaW5nTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExNztcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQsIFwidGV4dEVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKTtcbiAgICBjb25zdCBtb2RlbCA9IChfYTE3ID0gcHJvdmlkZXIudGV4dEVtYmVkZGluZ01vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBpbWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImltYWdlTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMTcgPSBwcm92aWRlci5pbWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExNy5jYWxsKHByb3ZpZGVyLCBtb2RlbElkKTtcbiAgICBpZiAobW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3I0KHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJpbWFnZU1vZGVsXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxufTtcblxuLy8gY29yZS90b29sL21jcC9tY3AtY2xpZW50LnRzXG5pbXBvcnQgeyBqc29uU2NoZW1hIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS90b29sL3Rvb2wudHNcbmZ1bmN0aW9uIHRvb2wodG9vbDIpIHtcbiAgcmV0dXJuIHRvb2wyO1xufVxuXG4vLyBjb3JlL3Rvb2wvbWNwL21jcC1zc2UtdHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvdG9vbC9tY3AvanNvbi1ycGMtbWVzc2FnZS50c1xuaW1wb3J0IHsgeiBhcyB6MTAgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvdG9vbC9tY3AvdHlwZXMudHNcbmltcG9ydCB7IHogYXMgejkgfSBmcm9tIFwiem9kXCI7XG52YXIgTEFURVNUX1BST1RPQ09MX1ZFUlNJT04gPSBcIjIwMjQtMTEtMDVcIjtcbnZhciBTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMgPSBbXG4gIExBVEVTVF9QUk9UT0NPTF9WRVJTSU9OLFxuICBcIjIwMjQtMTAtMDdcIlxuXTtcbnZhciBDbGllbnRPclNlcnZlckltcGxlbWVudGF0aW9uU2NoZW1hID0gejkub2JqZWN0KHtcbiAgbmFtZTogejkuc3RyaW5nKCksXG4gIHZlcnNpb246IHo5LnN0cmluZygpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIEJhc2VQYXJhbXNTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICBfbWV0YTogejkub3B0aW9uYWwoejkub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBSZXN1bHRTY2hlbWEgPSBCYXNlUGFyYW1zU2NoZW1hO1xudmFyIFJlcXVlc3RTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICBtZXRob2Q6IHo5LnN0cmluZygpLFxuICBwYXJhbXM6IHo5Lm9wdGlvbmFsKEJhc2VQYXJhbXNTY2hlbWEpXG59KTtcbnZhciBTZXJ2ZXJDYXBhYmlsaXRpZXNTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICBleHBlcmltZW50YWw6IHo5Lm9wdGlvbmFsKHo5Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gIGxvZ2dpbmc6IHo5Lm9wdGlvbmFsKHo5Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gIHByb21wdHM6IHo5Lm9wdGlvbmFsKFxuICAgIHo5Lm9iamVjdCh7XG4gICAgICBsaXN0Q2hhbmdlZDogejkub3B0aW9uYWwoejkuYm9vbGVhbigpKVxuICAgIH0pLnBhc3N0aHJvdWdoKClcbiAgKSxcbiAgcmVzb3VyY2VzOiB6OS5vcHRpb25hbChcbiAgICB6OS5vYmplY3Qoe1xuICAgICAgc3Vic2NyaWJlOiB6OS5vcHRpb25hbCh6OS5ib29sZWFuKCkpLFxuICAgICAgbGlzdENoYW5nZWQ6IHo5Lm9wdGlvbmFsKHo5LmJvb2xlYW4oKSlcbiAgICB9KS5wYXNzdGhyb3VnaCgpXG4gICksXG4gIHRvb2xzOiB6OS5vcHRpb25hbChcbiAgICB6OS5vYmplY3Qoe1xuICAgICAgbGlzdENoYW5nZWQ6IHo5Lm9wdGlvbmFsKHo5LmJvb2xlYW4oKSlcbiAgICB9KS5wYXNzdGhyb3VnaCgpXG4gIClcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgSW5pdGlhbGl6ZVJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBwcm90b2NvbFZlcnNpb246IHo5LnN0cmluZygpLFxuICBjYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllc1NjaGVtYSxcbiAgc2VydmVySW5mbzogQ2xpZW50T3JTZXJ2ZXJJbXBsZW1lbnRhdGlvblNjaGVtYSxcbiAgaW5zdHJ1Y3Rpb25zOiB6OS5vcHRpb25hbCh6OS5zdHJpbmcoKSlcbn0pO1xudmFyIFBhZ2luYXRlZFJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBuZXh0Q3Vyc29yOiB6OS5vcHRpb25hbCh6OS5zdHJpbmcoKSlcbn0pO1xudmFyIFRvb2xTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICBuYW1lOiB6OS5zdHJpbmcoKSxcbiAgZGVzY3JpcHRpb246IHo5Lm9wdGlvbmFsKHo5LnN0cmluZygpKSxcbiAgaW5wdXRTY2hlbWE6IHo5Lm9iamVjdCh7XG4gICAgdHlwZTogejkubGl0ZXJhbChcIm9iamVjdFwiKSxcbiAgICBwcm9wZXJ0aWVzOiB6OS5vcHRpb25hbCh6OS5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG4gIH0pLnBhc3N0aHJvdWdoKClcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgTGlzdFRvb2xzUmVzdWx0U2NoZW1hID0gUGFnaW5hdGVkUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIHRvb2xzOiB6OS5hcnJheShUb29sU2NoZW1hKVxufSk7XG52YXIgVGV4dENvbnRlbnRTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICB0eXBlOiB6OS5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejkuc3RyaW5nKClcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgSW1hZ2VDb250ZW50U2NoZW1hID0gejkub2JqZWN0KHtcbiAgdHlwZTogejkubGl0ZXJhbChcImltYWdlXCIpLFxuICBkYXRhOiB6OS5zdHJpbmcoKS5iYXNlNjQoKSxcbiAgbWltZVR5cGU6IHo5LnN0cmluZygpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFJlc291cmNlQ29udGVudHNTY2hlbWEgPSB6OS5vYmplY3Qoe1xuICAvKipcbiAgICogVGhlIFVSSSBvZiB0aGlzIHJlc291cmNlLlxuICAgKi9cbiAgdXJpOiB6OS5zdHJpbmcoKSxcbiAgLyoqXG4gICAqIFRoZSBNSU1FIHR5cGUgb2YgdGhpcyByZXNvdXJjZSwgaWYga25vd24uXG4gICAqL1xuICBtaW1lVHlwZTogejkub3B0aW9uYWwoejkuc3RyaW5nKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFRleHRSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gUmVzb3VyY2VDb250ZW50c1NjaGVtYS5leHRlbmQoe1xuICB0ZXh0OiB6OS5zdHJpbmcoKVxufSk7XG52YXIgQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWEgPSBSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLmV4dGVuZCh7XG4gIGJsb2I6IHo5LnN0cmluZygpLmJhc2U2NCgpXG59KTtcbnZhciBFbWJlZGRlZFJlc291cmNlU2NoZW1hID0gejkub2JqZWN0KHtcbiAgdHlwZTogejkubGl0ZXJhbChcInJlc291cmNlXCIpLFxuICByZXNvdXJjZTogejkudW5pb24oW1RleHRSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLCBCbG9iUmVzb3VyY2VDb250ZW50c1NjaGVtYV0pXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIENhbGxUb29sUmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIGNvbnRlbnQ6IHo5LmFycmF5KFxuICAgIHo5LnVuaW9uKFtUZXh0Q29udGVudFNjaGVtYSwgSW1hZ2VDb250ZW50U2NoZW1hLCBFbWJlZGRlZFJlc291cmNlU2NoZW1hXSlcbiAgKSxcbiAgaXNFcnJvcjogejkuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLm9wdGlvbmFsKClcbn0pLm9yKFxuICBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgICB0b29sUmVzdWx0OiB6OS51bmtub3duKClcbiAgfSlcbik7XG5cbi8vIGNvcmUvdG9vbC9tY3AvanNvbi1ycGMtbWVzc2FnZS50c1xudmFyIEpTT05SUENfVkVSU0lPTiA9IFwiMi4wXCI7XG52YXIgSlNPTlJQQ1JlcXVlc3RTY2hlbWEgPSB6MTAub2JqZWN0KHtcbiAganNvbnJwYzogejEwLmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHoxMC51bmlvbihbejEwLnN0cmluZygpLCB6MTAubnVtYmVyKCkuaW50KCldKVxufSkubWVyZ2UoUmVxdWVzdFNjaGVtYSkuc3RyaWN0KCk7XG52YXIgSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hID0gejEwLm9iamVjdCh7XG4gIGpzb25ycGM6IHoxMC5saXRlcmFsKEpTT05SUENfVkVSU0lPTiksXG4gIGlkOiB6MTAudW5pb24oW3oxMC5zdHJpbmcoKSwgejEwLm51bWJlcigpLmludCgpXSksXG4gIHJlc3VsdDogUmVzdWx0U2NoZW1hXG59KS5zdHJpY3QoKTtcbnZhciBKU09OUlBDRXJyb3JTY2hlbWEgPSB6MTAub2JqZWN0KHtcbiAganNvbnJwYzogejEwLmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKSxcbiAgaWQ6IHoxMC51bmlvbihbejEwLnN0cmluZygpLCB6MTAubnVtYmVyKCkuaW50KCldKSxcbiAgZXJyb3I6IHoxMC5vYmplY3Qoe1xuICAgIGNvZGU6IHoxMC5udW1iZXIoKS5pbnQoKSxcbiAgICBtZXNzYWdlOiB6MTAuc3RyaW5nKCksXG4gICAgZGF0YTogejEwLm9wdGlvbmFsKHoxMC51bmtub3duKCkpXG4gIH0pXG59KS5zdHJpY3QoKTtcbnZhciBKU09OUlBDTm90aWZpY2F0aW9uU2NoZW1hID0gejEwLm9iamVjdCh7XG4gIGpzb25ycGM6IHoxMC5saXRlcmFsKEpTT05SUENfVkVSU0lPTilcbn0pLm1lcmdlKFxuICB6MTAub2JqZWN0KHtcbiAgICBtZXRob2Q6IHoxMC5zdHJpbmcoKSxcbiAgICBwYXJhbXM6IHoxMC5vcHRpb25hbChCYXNlUGFyYW1zU2NoZW1hKVxuICB9KVxuKS5zdHJpY3QoKTtcbnZhciBKU09OUlBDTWVzc2FnZVNjaGVtYSA9IHoxMC51bmlvbihbXG4gIEpTT05SUENSZXF1ZXN0U2NoZW1hLFxuICBKU09OUlBDTm90aWZpY2F0aW9uU2NoZW1hLFxuICBKU09OUlBDUmVzcG9uc2VTY2hlbWEsXG4gIEpTT05SUENFcnJvclNjaGVtYVxuXSk7XG5cbi8vIGNvcmUvdG9vbC9tY3AvbWNwLXNzZS10cmFuc3BvcnQudHNcbnZhciBTc2VNQ1BUcmFuc3BvcnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgaGVhZGVyc1xuICB9KSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVybCA9IG5ldyBVUkwodXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgZXN0YWJsaXNoQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdmFyIF9hMTcsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICAgICAgICBoZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcInRleHQvZXZlbnQtc3RyZWFtXCIpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy51cmwuaHJlZiwge1xuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogKF9hMTcgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuc2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vayB8fCAhcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgTUNQIFNTRSBUcmFuc3BvcnQgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc0V2ZW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTE4LCBfYjIsIF9jMjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogQ29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5XCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQsIGRhdGEgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCA9PT0gXCJlbmRwb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50ID0gbmV3IFVSTChkYXRhLCB0aGlzLnVybCk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRwb2ludC5vcmlnaW4gIT09IHRoaXMudXJsLm9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBNQ1AgU1NFIFRyYW5zcG9ydCBFcnJvcjogRW5kcG9pbnQgb3JpZ2luIGRvZXMgbm90IG1hdGNoIGNvbm5lY3Rpb24gb3JpZ2luOiAke3RoaXMuZW5kcG9pbnQub3JpZ2lufWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PT0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OUlBDTWVzc2FnZVNjaGVtYS5wYXJzZShcbiAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIChfYTE4ID0gdGhpcy5vbm1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE4LmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk1DUCBTU0UgVHJhbnNwb3J0IEVycm9yOiBGYWlsZWQgdG8gcGFyc2UgbWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgKF9iMiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKF9jMiA9IHRoaXMub25lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuc3NlQ29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiByZWFkZXIuY2FuY2VsKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHByb2Nlc3NFdmVudHMoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoX2MgPSB0aGlzLm9uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXN0YWJsaXNoQ29ubmVjdGlvbigpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTE3LCBfYiwgX2M7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAoX2ExNyA9IHRoaXMuc3NlQ29ubmVjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTcuY2xvc2UoKTtcbiAgICAoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmFib3J0KCk7XG4gICAgKF9jID0gdGhpcy5vbmNsb3NlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzKTtcbiAgfVxuICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICB2YXIgX2ExNywgX2IsIF9jO1xuICAgIGlmICghdGhpcy5lbmRwb2ludCB8fCAhdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiTUNQIFNTRSBUcmFuc3BvcnQgRXJyb3I6IE5vdCBjb25uZWN0ZWRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgIGNvbnN0IGluaXQgPSB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLFxuICAgICAgICBzaWduYWw6IChfYTE3ID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LnNpZ25hbFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5lbmRwb2ludCwgaW5pdCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHRleHQyID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYE1DUCBTU0UgVHJhbnNwb3J0IEVycm9yOiBQT1NUaW5nIHRvIGVuZHBvaW50IChIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSk6ICR7dGV4dDJ9YFxuICAgICAgICB9KTtcbiAgICAgICAgKF9iID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgKF9jID0gdGhpcy5vbmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG4vLyBjb3JlL3Rvb2wvbWNwL21jcC10cmFuc3BvcnQudHNcbmZ1bmN0aW9uIGNyZWF0ZU1jcFRyYW5zcG9ydChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy50eXBlICE9PSBcInNzZVwiKSB7XG4gICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0cmFuc3BvcnQgY29uZmlndXJhdGlvbi4gSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSB0cmFuc3BvcnQsIG1ha2Ugc3VyZSBpdCBpbXBsZW1lbnRzIHRoZSBNQ1BUcmFuc3BvcnQgaW50ZXJmYWNlLlwiXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTc2VNQ1BUcmFuc3BvcnQoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tTWNwVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICByZXR1cm4gXCJzdGFydFwiIGluIHRyYW5zcG9ydCAmJiB0eXBlb2YgdHJhbnNwb3J0LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCIgJiYgXCJzZW5kXCIgaW4gdHJhbnNwb3J0ICYmIHR5cGVvZiB0cmFuc3BvcnQuc2VuZCA9PT0gXCJmdW5jdGlvblwiICYmIFwiY2xvc2VcIiBpbiB0cmFuc3BvcnQgJiYgdHlwZW9mIHRyYW5zcG9ydC5jbG9zZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBjb3JlL3Rvb2wvbWNwL21jcC1jbGllbnQudHNcbnZhciBDTElFTlRfVkVSU0lPTiA9IFwiMS4wLjBcIjtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU1DUENsaWVudChjb25maWcpIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IE1DUENsaWVudChjb25maWcpO1xuICBhd2FpdCBjbGllbnQuaW5pdCgpO1xuICByZXR1cm4gY2xpZW50O1xufVxudmFyIE1DUENsaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0Q29uZmlnLFxuICAgIG5hbWU6IG5hbWUxNyA9IFwiYWktc2RrLW1jcC1jbGllbnRcIixcbiAgICBvblVuY2F1Z2h0RXJyb3JcbiAgfSkge1xuICAgIHRoaXMucmVxdWVzdE1lc3NhZ2VJZCA9IDA7XG4gICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnNlcnZlckNhcGFiaWxpdGllcyA9IHt9O1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMub25VbmNhdWdodEVycm9yID0gb25VbmNhdWdodEVycm9yO1xuICAgIGlmIChpc0N1c3RvbU1jcFRyYW5zcG9ydCh0cmFuc3BvcnRDb25maWcpKSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydENvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc3BvcnQgPSBjcmVhdGVNY3BUcmFuc3BvcnQodHJhbnNwb3J0Q29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy50cmFuc3BvcnQub25jbG9zZSA9ICgpID0+IHRoaXMub25DbG9zZSgpO1xuICAgIHRoaXMudHJhbnNwb3J0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgdGhpcy50cmFuc3BvcnQub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgIGlmIChcIm1ldGhvZFwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5vbkVycm9yKFxuICAgICAgICAgIG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlVuc3VwcG9ydGVkIG1lc3NhZ2UgdHlwZVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5vblJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnRJbmZvID0ge1xuICAgICAgbmFtZTogbmFtZTE3LFxuICAgICAgdmVyc2lvbjogQ0xJRU5UX1ZFUlNJT05cbiAgICB9O1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMudHJhbnNwb3J0LnN0YXJ0KCk7XG4gICAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgbWV0aG9kOiBcImluaXRpYWxpemVcIixcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbjogTEFURVNUX1BST1RPQ09MX1ZFUlNJT04sXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHt9LFxuICAgICAgICAgICAgY2xpZW50SW5mbzogdGhpcy5jbGllbnRJbmZvXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXN1bHRTY2hlbWE6IEluaXRpYWxpemVSZXN1bHRTY2hlbWFcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJTZXJ2ZXIgc2VudCBpbnZhbGlkIGluaXRpYWxpemUgcmVzdWx0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIVNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OUy5pbmNsdWRlcyhyZXN1bHQucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBTZXJ2ZXIncyBwcm90b2NvbCB2ZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6ICR7cmVzdWx0LnByb3RvY29sVmVyc2lvbn1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMgPSByZXN1bHQuY2FwYWJpbGl0aWVzO1xuICAgICAgYXdhaXQgdGhpcy5ub3RpZmljYXRpb24oe1xuICAgICAgICBtZXRob2Q6IFwibm90aWZpY2F0aW9ucy9pbml0aWFsaXplZFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCB0aGlzLmNsb3NlKCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpXG4gICAgICByZXR1cm47XG4gICAgYXdhaXQgKChfYTE3ID0gdGhpcy50cmFuc3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTE3LmNsb3NlKCkpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG4gIGFzc2VydENhcGFiaWxpdHkobWV0aG9kKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvb2xzL2xpc3RcIjpcbiAgICAgIGNhc2UgXCJ0b29scy9jYWxsXCI6XG4gICAgICAgIGlmICghdGhpcy5zZXJ2ZXJDYXBhYmlsaXRpZXMudG9vbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHRvb2xzYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgbWV0aG9kOiAke21ldGhvZH1gXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyByZXF1ZXN0KHtcbiAgICByZXF1ZXN0LFxuICAgIHJlc3VsdFNjaGVtYSxcbiAgICBvcHRpb25zXG4gIH0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJBdHRlbXB0ZWQgdG8gc2VuZCBhIHJlcXVlc3QgZnJvbSBhIGNsb3NlZCBjbGllbnRcIlxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2VydENhcGFiaWxpdHkocmVxdWVzdC5tZXRob2QpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zaWduYWw7XG4gICAgICBzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgY29uc3QgbWVzc2FnZUlkID0gdGhpcy5yZXF1ZXN0TWVzc2FnZUlkKys7XG4gICAgICBjb25zdCBqc29ucnBjUmVxdWVzdCA9IHtcbiAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgaWQ6IG1lc3NhZ2VJZFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUlkKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnJlc3BvbnNlSGFuZGxlcnMuc2V0KG1lc3NhZ2VJZCwgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUmVxdWVzdCB3YXMgYWJvcnRlZFwiLFxuICAgICAgICAgICAgICBjYXVzZTogc2lnbmFsLnJlYXNvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRTY2hlbWEucGFyc2UocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VFcnJvciA9IG5ldyBNQ1BDbGllbnRFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwYXJzZSBzZXJ2ZXIgcmVzcG9uc2VcIixcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlamVjdChwYXJzZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKGpzb25ycGNSZXF1ZXN0KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgbGlzdFRvb2xzKHtcbiAgICBwYXJhbXMsXG4gICAgb3B0aW9uc1xuICB9ID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBcInRvb2xzL2xpc3RcIiwgcGFyYW1zIH0sXG4gICAgICAgIHJlc3VsdFNjaGVtYTogTGlzdFRvb2xzUmVzdWx0U2NoZW1hLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNhbGxUb29sKHtcbiAgICBuYW1lOiBuYW1lMTcsXG4gICAgYXJncyxcbiAgICBvcHRpb25zXG4gIH0pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBcInRvb2xzL2NhbGxcIiwgcGFyYW1zOiB7IG5hbWU6IG5hbWUxNywgYXJndW1lbnRzOiBhcmdzIH0gfSxcbiAgICAgICAgcmVzdWx0U2NoZW1hOiBDYWxsVG9vbFJlc3VsdFNjaGVtYSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNpZ25hbDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIG5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCBqc29ucnBjTm90aWZpY2F0aW9uID0ge1xuICAgICAgLi4ubm90aWZpY2F0aW9uLFxuICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgIH07XG4gICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2VuZChqc29ucnBjTm90aWZpY2F0aW9uKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiBBSSBTREsgdG9vbHMgZnJvbSB0aGUgTUNQIHNlcnZlclxuICAgKiBAcmV0dXJucyBBIHJlY29yZCBvZiB0b29sIG5hbWVzIHRvIHRoZWlyIGltcGxlbWVudGF0aW9uc1xuICAgKi9cbiAgYXN5bmMgdG9vbHMoe1xuICAgIHNjaGVtYXMgPSBcImF1dG9tYXRpY1wiXG4gIH0gPSB7fSkge1xuICAgIHZhciBfYTE3O1xuICAgIGNvbnN0IHRvb2xzID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxpc3RUb29sc1Jlc3VsdCA9IGF3YWl0IHRoaXMubGlzdFRvb2xzKCk7XG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZTogbmFtZTE3LCBkZXNjcmlwdGlvbiwgaW5wdXRTY2hlbWEgfSBvZiBsaXN0VG9vbHNSZXN1bHQudG9vbHMpIHtcbiAgICAgICAgaWYgKHNjaGVtYXMgIT09IFwiYXV0b21hdGljXCIgJiYgIShuYW1lMTcgaW4gc2NoZW1hcykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc2NoZW1hcyA9PT0gXCJhdXRvbWF0aWNcIiA/IGpzb25TY2hlbWEoe1xuICAgICAgICAgIC4uLmlucHV0U2NoZW1hLFxuICAgICAgICAgIHByb3BlcnRpZXM6IChfYTE3ID0gaW5wdXRTY2hlbWEucHJvcGVydGllcykgIT0gbnVsbCA/IF9hMTcgOiB7fSxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICAgICAgfSkgOiBzY2hlbWFzW25hbWUxN10ucGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRvb2xXaXRoRXhlY3V0ZSA9IHRvb2woe1xuICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgZXhlY3V0ZTogYXN5bmMgKGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTE4O1xuICAgICAgICAgICAgKF9hMTggPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2ExOC50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsbFRvb2woe1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lMTcsXG4gICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRvb2xzW25hbWUxN10gPSB0b29sV2l0aEV4ZWN1dGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9vbHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBvbkNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiQ29ubmVjdGlvbiBjbG9zZWRcIlxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLnJlc3BvbnNlSGFuZGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIGhhbmRsZXIoZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnJlc3BvbnNlSGFuZGxlcnMuY2xlYXIoKTtcbiAgfVxuICBvbkVycm9yKGVycm9yKSB7XG4gICAgaWYgKHRoaXMub25VbmNhdWdodEVycm9yKSB7XG4gICAgICB0aGlzLm9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIG9uUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBjb25zdCBtZXNzYWdlSWQgPSBOdW1iZXIocmVzcG9uc2UuaWQpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnJlc3BvbnNlSGFuZGxlcnMuZ2V0KG1lc3NhZ2VJZCk7XG4gICAgaWYgKGhhbmRsZXIgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IE1DUENsaWVudEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYFByb3RvY29sIGVycm9yOiBSZWNlaXZlZCBhIHJlc3BvbnNlIGZvciBhbiB1bmtub3duIG1lc3NhZ2UgSUQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgKX1gXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zZUhhbmRsZXJzLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgIGhhbmRsZXIoXG4gICAgICBcInJlc3VsdFwiIGluIHJlc3BvbnNlID8gcmVzcG9uc2UgOiBuZXcgTUNQQ2xpZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5lcnJvci5tZXNzYWdlLFxuICAgICAgICBjYXVzZTogcmVzcG9uc2UuZXJyb3JcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9yL25vLXRyYW5zY3JpcHQtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyMCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBcIkFJX05vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBcIk5vIHRyYW5zY3JpcHQgZ2VuZXJhdGVkLlwiXG4gICAgfSk7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gY29yZS90cmFuc2NyaWJlL3RyYW5zY3JpYmUudHNcbmFzeW5jIGZ1bmN0aW9uIHRyYW5zY3JpYmUoe1xuICBtb2RlbCxcbiAgYXVkaW8sXG4gIHByb3ZpZGVyT3B0aW9ucyA9IHt9LFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVyc1xufSkge1xuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7IG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcgfSk7XG4gIGNvbnN0IGF1ZGlvRGF0YSA9IGF1ZGlvIGluc3RhbmNlb2YgVVJMID8gKGF3YWl0IGRvd25sb2FkKHsgdXJsOiBhdWRpbyB9KSkuZGF0YSA6IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShhdWRpbyk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IHtcbiAgICAgIHZhciBfYTE3O1xuICAgICAgcmV0dXJuIG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICBhdWRpbzogYXVkaW9EYXRhLFxuICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICBtZWRpYVR5cGU6IChfYTE3ID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICBkYXRhOiBhdWRpb0RhdGEsXG4gICAgICAgICAgc2lnbmF0dXJlczogYXVkaW9NZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICAgIH0pKSAhPSBudWxsID8gX2ExNyA6IFwiYXVkaW8vd2F2XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbiAgaWYgKCFyZXN1bHQudGV4dCkge1xuICAgIHRocm93IG5ldyBOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlczogW3Jlc3VsdC5yZXNwb25zZV0gfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWZhdWx0VHJhbnNjcmlwdGlvblJlc3VsdCh7XG4gICAgdGV4dDogcmVzdWx0LnRleHQsXG4gICAgc2VnbWVudHM6IHJlc3VsdC5zZWdtZW50cyxcbiAgICBsYW5ndWFnZTogcmVzdWx0Lmxhbmd1YWdlLFxuICAgIGR1cmF0aW9uSW5TZWNvbmRzOiByZXN1bHQuZHVyYXRpb25JblNlY29uZHMsXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gIH0pO1xufVxudmFyIERlZmF1bHRUcmFuc2NyaXB0aW9uUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMTc7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMuc2VnbWVudHMgPSBvcHRpb25zLnNlZ21lbnRzO1xuICAgIHRoaXMubGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlO1xuICAgIHRoaXMuZHVyYXRpb25JblNlY29uZHMgPSBvcHRpb25zLmR1cmF0aW9uSW5TZWNvbmRzO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmVzcG9uc2VzID0gb3B0aW9ucy5yZXNwb25zZXM7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gKF9hMTcgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYTE3IDoge307XG4gIH1cbn07XG5leHBvcnQge1xuICBBSVNES0Vycm9yMTYgYXMgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBDaGF0U3RvcmUsXG4gIERlZmF1bHRDaGF0VHJhbnNwb3J0LFxuICBEb3dubG9hZEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IsXG4gIEludmFsaWRNZXNzYWdlUm9sZUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSW52YWxpZFN0cmVhbVBhcnRFcnJvcixcbiAgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSxcbiAgTG9hZEFQSUtleUVycm9yLFxuICBNQ1BDbGllbnRFcnJvcixcbiAgTWVzc2FnZUNvbnZlcnNpb25FcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vSW1hZ2VHZW5lcmF0ZWRFcnJvcixcbiAgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcixcbiAgTm9PdXRwdXRTcGVjaWZpZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgTm9TdWNoUHJvdmlkZXJFcnJvcixcbiAgTm9TdWNoVG9vbEVycm9yLFxuICBvdXRwdXRfZXhwb3J0cyBhcyBPdXRwdXQsXG4gIFJldHJ5RXJyb3IsXG4gIFRvb2xDYWxsUmVwYWlyRXJyb3IsXG4gIFRvb2xFeGVjdXRpb25FcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIGFwcGVuZENsaWVudE1lc3NhZ2UsXG4gIGFzU2NoZW1hNSBhcyBhc1NjaGVtYSxcbiAgYXNzaXN0YW50TW9kZWxNZXNzYWdlU2NoZW1hLFxuICBjYWxsQ2hhdEFwaSxcbiAgY2FsbENvbXBsZXRpb25BcGksXG4gIGNvbnZlcnRGaWxlTGlzdFRvRmlsZVVJUGFydHMsXG4gIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyxcbiAgY29udmVydFRvTW9kZWxNZXNzYWdlcyxcbiAgY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVNZXNzYWdlU2NoZW1hLFxuICBjb3JlU3lzdGVtTWVzc2FnZVNjaGVtYSxcbiAgY29yZVRvb2xNZXNzYWdlU2NoZW1hLFxuICBjb3JlVXNlck1lc3NhZ2VTY2hlbWEsXG4gIGNvc2luZVNpbWlsYXJpdHksXG4gIGNyZWF0ZUlkR2VuZXJhdG9yNSBhcyBjcmVhdGVJZEdlbmVyYXRvcixcbiAgY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgY3JlYXRlVGV4dFN0cmVhbVJlc3BvbnNlLFxuICBjcmVhdGVVSU1lc3NhZ2VTdHJlYW0sXG4gIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbVJlc3BvbnNlLFxuICBjdXN0b21Qcm92aWRlcixcbiAgZGVmYXVsdENoYXRTdG9yZSxcbiAgZGVmYXVsdFNldHRpbmdzTWlkZGxld2FyZSxcbiAgZW1iZWQsXG4gIGVtYmVkTWFueSxcbiAgY3JlYXRlTUNQQ2xpZW50IGFzIGV4cGVyaW1lbnRhbF9jcmVhdGVNQ1BDbGllbnQsXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIsXG4gIGdlbmVyYXRlSW1hZ2UgYXMgZXhwZXJpbWVudGFsX2dlbmVyYXRlSW1hZ2UsXG4gIGdlbmVyYXRlU3BlZWNoIGFzIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVNwZWVjaCxcbiAgdHJhbnNjcmliZSBhcyBleHBlcmltZW50YWxfdHJhbnNjcmliZSxcbiAgZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcCxcbiAgZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUsXG4gIGdlbmVyYXRlSWQyIGFzIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgZ2V0VG9vbEludm9jYXRpb25zLFxuICBoYXNUb29sQ2FsbCxcbiAgaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBqc29uU2NoZW1hMiBhcyBqc29uU2NoZW1hLFxuICBtYXhTdGVwcyxcbiAgbW9kZWxNZXNzYWdlU2NoZW1hLFxuICBwYXJzZVBhcnRpYWxKc29uLFxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UsXG4gIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlLFxuICBzaG91bGRSZXN1Ym1pdE1lc3NhZ2VzLFxuICBzaW11bGF0ZVJlYWRhYmxlU3RyZWFtLFxuICBzaW11bGF0ZVN0cmVhbWluZ01pZGRsZXdhcmUsXG4gIHNtb290aFN0cmVhbSxcbiAgc3RyZWFtT2JqZWN0LFxuICBzdHJlYW1UZXh0LFxuICBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHRvb2wsXG4gIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHVwZGF0ZVRvb2xDYWxsUmVzdWx0LFxuICB1c2VyTW9kZWxNZXNzYWdlU2NoZW1hLFxuICB3cmFwTGFuZ3VhZ2VNb2RlbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/rsc/node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/rsc/node_modules/ai/dist/internal/index.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@ai-sdk/rsc/node_modules/ai/dist/internal/index.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertAsyncIteratorToReadableStream: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertAsyncIteratorToReadableStream),\n/* harmony export */   convertToLanguageModelPrompt: () => (/* binding */ convertToLanguageModelPrompt),\n/* harmony export */   prepareCallSettings: () => (/* binding */ prepareCallSettings),\n/* harmony export */   prepareRetries: () => (/* binding */ prepareRetries),\n/* harmony export */   prepareToolsAndToolChoice: () => (/* binding */ prepareToolsAndToolChoice),\n/* harmony export */   standardizePrompt: () => (/* binding */ standardizePrompt)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/rsc/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n// internal/index.ts\n\n\n// core/prompt/convert-to-language-model-prompt.ts\n\n\n// src/util/detect-media-type.ts\n\nvar imageMediaTypeSignatures = [\n  {\n    mediaType: \"image/gif\",\n    bytesPrefix: [71, 73, 70],\n    base64Prefix: \"R0lG\"\n  },\n  {\n    mediaType: \"image/png\",\n    bytesPrefix: [137, 80, 78, 71],\n    base64Prefix: \"iVBORw\"\n  },\n  {\n    mediaType: \"image/jpeg\",\n    bytesPrefix: [255, 216],\n    base64Prefix: \"/9j/\"\n  },\n  {\n    mediaType: \"image/webp\",\n    bytesPrefix: [82, 73, 70, 70],\n    base64Prefix: \"UklGRg\"\n  },\n  {\n    mediaType: \"image/bmp\",\n    bytesPrefix: [66, 77],\n    base64Prefix: \"Qk\"\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [73, 73, 42, 0],\n    base64Prefix: \"SUkqAA\"\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [77, 77, 0, 42],\n    base64Prefix: \"TU0AKg\"\n  },\n  {\n    mediaType: \"image/avif\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      97,\n      118,\n      105,\n      102\n    ],\n    base64Prefix: \"AAAAIGZ0eXBhdmlm\"\n  },\n  {\n    mediaType: \"image/heic\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      104,\n      101,\n      105,\n      99\n    ],\n    base64Prefix: \"AAAAIGZ0eXBoZWlj\"\n  }\n];\nvar stripID3 = (data) => {\n  const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertBase64ToUint8Array)(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n  data[1] === 68 && // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  for (const signature of signatures) {\n    if (typeof processedData === \"string\" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(\n      (byte, index) => processedData[index] === byte\n    )) {\n      return signature.mediaType;\n    }\n  }\n  return void 0;\n}\n\n// src/util/download-error.ts\n\nvar name = \"AI_DownloadError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name, message, cause });\n    this[_a] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker);\n  }\n};\n_a = symbol;\n\n// src/util/download.ts\nasync function download({ url }) {\n  var _a5;\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: (_a5 = response.headers.get(\"content-type\")) != null ? _a5 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n\n// core/prompt/data-content.ts\n\n\n\n\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mediaType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mediaType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// core/prompt/data-content.ts\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_2__.union([\n  zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  zod__WEBPACK_IMPORTED_MODULE_2__[\"instanceof\"](Uint8Array),\n  zod__WEBPACK_IMPORTED_MODULE_2__[\"instanceof\"](ArrayBuffer),\n  zod__WEBPACK_IMPORTED_MODULE_2__.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a5, _b;\n      return (_b = (_a5 = globalThis.Buffer) == null ? void 0 : _a5.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertToLanguageModelV2DataContent(content) {\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: void 0 };\n  }\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: void 0 };\n  }\n  if (typeof content === \"string\") {\n    try {\n      content = new URL(content);\n    } catch (error) {\n    }\n  }\n  if (content instanceof URL && content.protocol === \"data:\") {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString()\n    );\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError({\n        name: \"InvalidDataContentError\",\n        message: `Invalid data URL format in content ${content.toString()}`\n      });\n    }\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n  return { data: content, mediaType: void 0 };\n}\n\n// core/prompt/invalid-message-role-error.ts\n\nvar name2 = \"AI_InvalidMessageRoleError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name2, message });\n    this[_a2] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  downloadImplementation = download\n}) {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    downloadImplementation,\n    supportedUrls\n  );\n  return [\n    ...prompt.system != null ? [{ role: \"system\", content: prompt.system }] : [],\n    ...prompt.messages.map(\n      (message) => convertToLanguageModelMessage(message, downloadedAssets)\n    )\n  ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        ).map((part) => {\n          const providerOptions = part.providerOptions;\n          switch (part.type) {\n            case \"file\": {\n              const { data, mediaType } = convertToLanguageModelV2DataContent(\n                part.data\n              );\n              return {\n                type: \"file\",\n                data,\n                filename: part.filename,\n                mediaType: mediaType != null ? mediaType : part.mediaType,\n                providerOptions\n              };\n            }\n            case \"reasoning\": {\n              return {\n                type: \"reasoning\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"tool-call\": {\n              return {\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                args: part.args,\n                providerOptions\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => ({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          content: part.experimental_content,\n          isError: part.isError,\n          providerOptions: part.providerOptions\n        })),\n        providerOptions: message.providerOptions\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, downloadImplementation, supportedUrls) {\n  const urls = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).map((part) => {\n    var _a5;\n    const mediaType = (_a5 = part.mediaType) != null ? _a5 : part.type === \"image\" ? \"image/*\" : void 0;\n    let data = part.type === \"image\" ? part.image : part.data;\n    if (typeof data === \"string\") {\n      try {\n        data = new URL(data);\n      } catch (ignored) {\n      }\n    }\n    return { mediaType, data };\n  }).filter(\n    (part) => part.data instanceof URL && part.mediaType != null && !(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isUrlSupported)({\n      url: part.data.toString(),\n      mediaType: part.mediaType,\n      supportedUrls\n    })\n  ).map((part) => part.data);\n  const downloadedImages = await Promise.all(\n    urls.map(async (url) => ({\n      url,\n      data: await downloadImplementation({ url })\n    }))\n  );\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data])\n  );\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a5, _b;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerOptions: part.providerOptions\n    };\n  }\n  let originalData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      originalData = part.image;\n      break;\n    case \"file\":\n      originalData = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);\n  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n  let data = convertedData;\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType = (_a5 = downloadedFile.mediaType) != null ? _a5 : mediaType;\n    }\n  }\n  switch (type) {\n    case \"image\": {\n      if (data instanceof Uint8Array || typeof data === \"string\") {\n        mediaType = (_b = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _b : mediaType;\n      }\n      return {\n        type: \"file\",\n        mediaType: mediaType != null ? mediaType : \"image/*\",\n        // any image\n        filename: void 0,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n    case \"file\": {\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n      return {\n        type: \"file\",\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n  }\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n  return object != null && Object.keys(object).length > 0;\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(\n    ([name5]) => activeTools.includes(name5)\n  ) : Object.entries(tools);\n  return {\n    tools: filteredTools.map(([name5, tool]) => {\n      const toolType = tool.type;\n      switch (toolType) {\n        case void 0:\n        case \"function\":\n          return {\n            type: \"function\",\n            name: name5,\n            description: tool.description,\n            parameters: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.asSchema)(tool.parameters).jsonSchema\n          };\n        case \"provider-defined\":\n          return {\n            type: \"provider-defined\",\n            name: name5,\n            id: tool.id,\n            args: tool.args\n          };\n        default: {\n          const exhaustiveCheck = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// core/prompt/standardize-prompt.ts\n\n\n\n\n// core/prompt/message.ts\n\n\n// core/types/provider-metadata.ts\n\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_2__.lazy(\n  () => zod__WEBPACK_IMPORTED_MODULE_2__.union([\n    zod__WEBPACK_IMPORTED_MODULE_2__[\"null\"](),\n    zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n    zod__WEBPACK_IMPORTED_MODULE_2__.number(),\n    zod__WEBPACK_IMPORTED_MODULE_2__.boolean(),\n    zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), jsonValueSchema),\n    zod__WEBPACK_IMPORTED_MODULE_2__.array(jsonValueSchema)\n  ])\n);\n\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_2__.record(\n  zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  zod__WEBPACK_IMPORTED_MODULE_2__.record(zod__WEBPACK_IMPORTED_MODULE_2__.string(), jsonValueSchema)\n);\n\n// core/prompt/content-part.ts\n\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_2__.array(\n  zod__WEBPACK_IMPORTED_MODULE_2__.union([\n    zod__WEBPACK_IMPORTED_MODULE_2__.object({ type: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"text\"), text: zod__WEBPACK_IMPORTED_MODULE_2__.string() }),\n    zod__WEBPACK_IMPORTED_MODULE_2__.object({\n      type: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"image\"),\n      data: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n      mediaType: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional()\n    })\n  ])\n);\n\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"text\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"image\"),\n  image: zod__WEBPACK_IMPORTED_MODULE_2__.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_2__[\"instanceof\"](URL)]),\n  mediaType: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"file\"),\n  data: zod__WEBPACK_IMPORTED_MODULE_2__.union([dataContentSchema, zod__WEBPACK_IMPORTED_MODULE_2__[\"instanceof\"](URL)]),\n  filename: zod__WEBPACK_IMPORTED_MODULE_2__.string().optional(),\n  mediaType: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"reasoning\"),\n  text: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"tool-call\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  args: zod__WEBPACK_IMPORTED_MODULE_2__.unknown(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"tool-result\"),\n  toolCallId: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  toolName: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n  result: zod__WEBPACK_IMPORTED_MODULE_2__.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: zod__WEBPACK_IMPORTED_MODULE_2__.boolean().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\n\n// core/prompt/message.ts\nvar systemModelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object(\n  {\n    role: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n    providerOptions: providerMetadataSchema.optional()\n  }\n);\nvar userModelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"user\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_2__.union([\n    zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n    zod__WEBPACK_IMPORTED_MODULE_2__.array(zod__WEBPACK_IMPORTED_MODULE_2__.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar assistantModelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"assistant\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_2__.union([\n    zod__WEBPACK_IMPORTED_MODULE_2__.string(),\n    zod__WEBPACK_IMPORTED_MODULE_2__.array(\n      zod__WEBPACK_IMPORTED_MODULE_2__.union([\n        textPartSchema,\n        filePartSchema,\n        reasoningPartSchema,\n        toolCallPartSchema\n      ])\n    )\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolModelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_2__.object({\n  role: zod__WEBPACK_IMPORTED_MODULE_2__.literal(\"tool\"),\n  content: zod__WEBPACK_IMPORTED_MODULE_2__.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar modelMessageSchema = zod__WEBPACK_IMPORTED_MODULE_2__.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\n\n// core/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  let messages;\n  if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n    messages = [{ role: \"user\", content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (messages.length === 0) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"messages must not be empty\"\n    });\n  }\n  const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeValidateTypes)({\n    value: messages,\n    schema: zod__WEBPACK_IMPORTED_MODULE_2__.array(modelMessageSchema)\n  });\n  if (!validationResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.\",\n      cause: validationResult.error\n    });\n  }\n  return {\n    messages,\n    system: prompt.system\n  };\n}\n\n// src/error/invalid-argument-error.ts\n\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name3,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a3] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences\n}) {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be an integer\"\n      });\n    }\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed\n  };\n}\n\n// src/util/retry-with-exponential-backoff.ts\n\n\n\n// src/util/retry-error.ts\n\nvar name4 = \"AI_RetryError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name: name4, message });\n    this[_a4] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.delay)(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// src/util/prepare-retries.ts\nfunction prepareRetries({\n  maxRetries\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult })\n  };\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yc2Mvbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW50ZXJuYWwvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQzhFOztBQUU5RTtBQUN3RDs7QUFFeEQ7QUFDbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUZBQXlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQSxrQ0FBa0Msd0RBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJLElBQUksWUFBWSxFQUFFLFdBQVcsMEJBQTBCLElBQUksSUFBSSxNQUFNO0FBQzdILEdBQUc7QUFDSCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7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SUFBSTtBQUNKLFFBQVEsb0VBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXLHdCQUF3QixhQUFhO0FBQ2pGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQ0FBa0MsMERBQVk7QUFDOUMsWUFBWSw2REFBSztBQUNqQjtBQUNBO0FBQ0EsVUFBVSxpRUFBaUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxzQ0FBc0MsYUFBYTtBQUM3RjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw4QkFBOEI7QUFDdkU7QUFDQTtBQVFFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXEFwZXhcXG5vZGVfbW9kdWxlc1xcQGFpLXNka1xccnNjXFxub2RlX21vZHVsZXNcXGFpXFxkaXN0XFxpbnRlcm5hbFxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGludGVybmFsL2luZGV4LnRzXG5pbXBvcnQgeyBjb252ZXJ0QXN5bmNJdGVyYXRvclRvUmVhZGFibGVTdHJlYW0gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuaW1wb3J0IHsgaXNVcmxTdXBwb3J0ZWQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9kZXRlY3QtbWVkaWEtdHlwZS50c1xuaW1wb3J0IHsgY29udmVydEJhc2U2NFRvVWludDhBcnJheSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzID0gW1xuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2dpZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzEsIDczLCA3MF0sXG4gICAgYmFzZTY0UHJlZml4OiBcIlIwbEdcIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3BuZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTM3LCA4MCwgNzgsIDcxXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiaVZCT1J3XCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9qcGVnXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsyNTUsIDIxNl0sXG4gICAgYmFzZTY0UHJlZml4OiBcIi85ai9cIlxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3dlYnBcIixcbiAgICBieXRlc1ByZWZpeDogWzgyLCA3MywgNzAsIDcwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVWtsR1JnXCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9ibXBcIixcbiAgICBieXRlc1ByZWZpeDogWzY2LCA3N10sXG4gICAgYmFzZTY0UHJlZml4OiBcIlFrXCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS90aWZmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3MywgNzMsIDQyLCAwXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiU1VrcUFBXCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS90aWZmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3NywgNzcsIDAsIDQyXSxcbiAgICBiYXNlNjRQcmVmaXg6IFwiVFUwQUtnXCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9hdmlmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDMyLFxuICAgICAgMTAyLFxuICAgICAgMTE2LFxuICAgICAgMTIxLFxuICAgICAgMTEyLFxuICAgICAgOTcsXG4gICAgICAxMTgsXG4gICAgICAxMDUsXG4gICAgICAxMDJcbiAgICBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJBQUFBSUdaMGVYQmhkbWxtXCJcbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9oZWljXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDMyLFxuICAgICAgMTAyLFxuICAgICAgMTE2LFxuICAgICAgMTIxLFxuICAgICAgMTEyLFxuICAgICAgMTA0LFxuICAgICAgMTAxLFxuICAgICAgMTA1LFxuICAgICAgOTlcbiAgICBdLFxuICAgIGJhc2U2NFByZWZpeDogXCJBQUFBSUdaMGVYQm9aV2xqXCJcbiAgfVxuXTtcbnZhciBzdHJpcElEMyA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGRhdGEpIDogZGF0YTtcbiAgY29uc3QgaWQzU2l6ZSA9IChieXRlc1s2XSAmIDEyNykgPDwgMjEgfCAoYnl0ZXNbN10gJiAxMjcpIDw8IDE0IHwgKGJ5dGVzWzhdICYgMTI3KSA8PCA3IHwgYnl0ZXNbOV0gJiAxMjc7XG4gIHJldHVybiBieXRlcy5zbGljZShpZDNTaXplICsgMTApO1xufTtcbmZ1bmN0aW9uIHN0cmlwSUQzVGFnc0lmUHJlc2VudChkYXRhKSB7XG4gIGNvbnN0IGhhc0lkMyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmIGRhdGEuc3RhcnRzV2l0aChcIlNVUXpcIikgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgJiYgZGF0YS5sZW5ndGggPiAxMCAmJiBkYXRhWzBdID09PSA3MyAmJiAvLyAnSSdcbiAgZGF0YVsxXSA9PT0gNjggJiYgLy8gJ0QnXG4gIGRhdGFbMl0gPT09IDUxO1xuICByZXR1cm4gaGFzSWQzID8gc3RyaXBJRDMoZGF0YSkgOiBkYXRhO1xufVxuZnVuY3Rpb24gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgZGF0YSxcbiAgc2lnbmF0dXJlc1xufSkge1xuICBjb25zdCBwcm9jZXNzZWREYXRhID0gc3RyaXBJRDNUYWdzSWZQcmVzZW50KGRhdGEpO1xuICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiBzaWduYXR1cmVzKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzZWREYXRhID09PSBcInN0cmluZ1wiID8gcHJvY2Vzc2VkRGF0YS5zdGFydHNXaXRoKHNpZ25hdHVyZS5iYXNlNjRQcmVmaXgpIDogcHJvY2Vzc2VkRGF0YS5sZW5ndGggPj0gc2lnbmF0dXJlLmJ5dGVzUHJlZml4Lmxlbmd0aCAmJiBzaWduYXR1cmUuYnl0ZXNQcmVmaXguZXZlcnkoXG4gICAgICAoYnl0ZSwgaW5kZXgpID0+IHByb2Nlc3NlZERhdGFbaW5kZXhdID09PSBieXRlXG4gICAgKSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZS5tZWRpYVR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lID0gXCJBSV9Eb3dubG9hZEVycm9yXCI7XG52YXIgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG52YXIgX2E7XG52YXIgRG93bmxvYWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgc3RhdHVzQ29kZSxcbiAgICBzdGF0dXNUZXh0LFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBjYXVzZSA9PSBudWxsID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWAgOiBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtjYXVzZX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcblxuLy8gc3JjL3V0aWwvZG93bmxvYWQudHNcbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHsgdXJsIH0pIHtcbiAgdmFyIF9hNTtcbiAgY29uc3QgdXJsVGV4dCA9IHVybC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsVGV4dCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3Ioe1xuICAgICAgICB1cmw6IHVybFRleHQsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgIG1lZGlhVHlwZTogKF9hNSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpKSAhPSBudWxsID8gX2E1IDogdm9pZCAwXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cblxuLy8gY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgYXMgY29udmVydEJhc2U2NFRvVWludDhBcnJheTIsXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L3NwbGl0LWRhdGEtdXJsLnRzXG5mdW5jdGlvbiBzcGxpdERhdGFVcmwoZGF0YVVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lZGlhVHlwZTogaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV0sXG4gICAgICBiYXNlNjRDb250ZW50XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVkaWFUeXBlOiB2b2lkIDAsXG4gICAgICBiYXNlNjRDb250ZW50OiB2b2lkIDBcbiAgICB9O1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xudmFyIGRhdGFDb250ZW50U2NoZW1hID0gei51bmlvbihbXG4gIHouc3RyaW5nKCksXG4gIHouaW5zdGFuY2VvZihVaW50OEFycmF5KSxcbiAgei5pbnN0YW5jZW9mKEFycmF5QnVmZmVyKSxcbiAgei5jdXN0b20oXG4gICAgLy8gQnVmZmVyIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gc29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBDbG91ZEZsYXJlOlxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hNSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hNSA9IGdsb2JhbFRoaXMuQnVmZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2E1LmlzQnVmZmVyKHZhbHVlKSkgIT0gbnVsbCA/IF9iIDogZmFsc2U7XG4gICAgfSxcbiAgICB7IG1lc3NhZ2U6IFwiTXVzdCBiZSBhIEJ1ZmZlclwiIH1cbiAgKVxuXSk7XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsVjJEYXRhQ29udGVudChjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB7IGRhdGE6IGNvbnRlbnQsIG1lZGlhVHlwZTogdm9pZCAwIH07XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IGRhdGE6IG5ldyBVaW50OEFycmF5KGNvbnRlbnQpLCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50ID0gbmV3IFVSTChjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVSTCAmJiBjb250ZW50LnByb3RvY29sID09PSBcImRhdGE6XCIpIHtcbiAgICBjb25zdCB7IG1lZGlhVHlwZTogZGF0YVVybE1lZGlhVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgY29udGVudC50b1N0cmluZygpXG4gICAgKTtcbiAgICBpZiAoZGF0YVVybE1lZGlhVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEFJU0RLRXJyb3IyKHtcbiAgICAgICAgbmFtZTogXCJJbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQgaW4gY29udGVudCAke2NvbnRlbnQudG9TdHJpbmcoKX1gXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZGF0YTogYmFzZTY0Q29udGVudCwgbWVkaWFUeXBlOiBkYXRhVXJsTWVkaWFUeXBlIH07XG4gIH1cbiAgcmV0dXJuIHsgZGF0YTogY29udGVudCwgbWVkaWFUeXBlOiB2b2lkIDAgfTtcbn1cblxuLy8gY29yZS9wcm9tcHQvaW52YWxpZC1tZXNzYWdlLXJvbGUtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUyID0gXCJBSV9JbnZhbGlkTWVzc2FnZVJvbGVFcnJvclwiO1xudmFyIG1hcmtlcjIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTJ9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJvbGUsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIG1lc3NhZ2Ugcm9sZTogJyR7cm9sZX0nLiBNdXN0IGJlIG9uZSBvZjogXCJzeXN0ZW1cIiwgXCJ1c2VyXCIsIFwiYXNzaXN0YW50XCIsIFwidG9vbFwiLmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gIHByb21wdCxcbiAgc3VwcG9ydGVkVXJscyxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiA9IGRvd25sb2FkXG59KSB7XG4gIGNvbnN0IGRvd25sb2FkZWRBc3NldHMgPSBhd2FpdCBkb3dubG9hZEFzc2V0cyhcbiAgICBwcm9tcHQubWVzc2FnZXMsXG4gICAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbixcbiAgICBzdXBwb3J0ZWRVcmxzXG4gICk7XG4gIHJldHVybiBbXG4gICAgLi4ucHJvbXB0LnN5c3RlbSAhPSBudWxsID8gW3sgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogcHJvbXB0LnN5c3RlbSB9XSA6IFtdLFxuICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoXG4gICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cylcbiAgICApXG4gIF07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkQXNzZXRzKSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+IGNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydChwYXJ0LCBkb3dubG9hZGVkQXNzZXRzKSkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIiksXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgdGV4dCBwYXJ0czpcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCJcbiAgICAgICAgKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICBjb25zdCBwcm92aWRlck9wdGlvbnMgPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucztcbiAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIG1lZGlhVHlwZSB9ID0gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFYyRGF0YUNvbnRlbnQoXG4gICAgICAgICAgICAgICAgcGFydC5kYXRhXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogcGFydC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogcGFydC5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJ0LmFyZ3MsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgIGNvbnRlbnQ6IHBhcnQuZXhwZXJpbWVudGFsX2NvbnRlbnQsXG4gICAgICAgICAgaXNFcnJvcjogcGFydC5pc0Vycm9yLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiwgc3VwcG9ydGVkVXJscykge1xuICBjb25zdCB1cmxzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgPT09IFwidXNlclwiKS5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuY29udGVudCkuZmlsdGVyKFxuICAgIChjb250ZW50KSA9PiBBcnJheS5pc0FycmF5KGNvbnRlbnQpXG4gICkuZmxhdCgpLmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICApLm1hcCgocGFydCkgPT4ge1xuICAgIHZhciBfYTU7XG4gICAgY29uc3QgbWVkaWFUeXBlID0gKF9hNSA9IHBhcnQubWVkaWFUeXBlKSAhPSBudWxsID8gX2E1IDogcGFydC50eXBlID09PSBcImltYWdlXCIgPyBcImltYWdlLypcIiA6IHZvaWQgMDtcbiAgICBsZXQgZGF0YSA9IHBhcnQudHlwZSA9PT0gXCJpbWFnZVwiID8gcGFydC5pbWFnZSA6IHBhcnQuZGF0YTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVVJMKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtZWRpYVR5cGUsIGRhdGEgfTtcbiAgfSkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LmRhdGEgaW5zdGFuY2VvZiBVUkwgJiYgcGFydC5tZWRpYVR5cGUgIT0gbnVsbCAmJiAhaXNVcmxTdXBwb3J0ZWQoe1xuICAgICAgdXJsOiBwYXJ0LmRhdGEudG9TdHJpbmcoKSxcbiAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICBzdXBwb3J0ZWRVcmxzXG4gICAgfSlcbiAgKS5tYXAoKHBhcnQpID0+IHBhcnQuZGF0YSk7XG4gIGNvbnN0IGRvd25sb2FkZWRJbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB1cmxzLm1hcChhc3luYyAodXJsKSA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YTogYXdhaXQgZG93bmxvYWRJbXBsZW1lbnRhdGlvbih7IHVybCB9KVxuICAgIH0pKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvd25sb2FkZWRJbWFnZXMubWFwKCh7IHVybCwgZGF0YSB9KSA9PiBbdXJsLnRvU3RyaW5nKCksIGRhdGFdKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgdmFyIF9hNSwgX2I7XG4gIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgIH07XG4gIH1cbiAgbGV0IG9yaWdpbmFsRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBvcmlnaW5hbERhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIG9yaWdpbmFsRGF0YSA9IHBhcnQuZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIGNvbnN0IHsgZGF0YTogY29udmVydGVkRGF0YSwgbWVkaWFUeXBlOiBjb252ZXJ0ZWRNZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWMkRhdGFDb250ZW50KG9yaWdpbmFsRGF0YSk7XG4gIGxldCBtZWRpYVR5cGUgPSBjb252ZXJ0ZWRNZWRpYVR5cGUgIT0gbnVsbCA/IGNvbnZlcnRlZE1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlO1xuICBsZXQgZGF0YSA9IGNvbnZlcnRlZERhdGE7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgZG93bmxvYWRlZEZpbGUgPSBkb3dubG9hZGVkQXNzZXRzW2RhdGEudG9TdHJpbmcoKV07XG4gICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICBkYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgIG1lZGlhVHlwZSA9IChfYTUgPSBkb3dubG9hZGVkRmlsZS5tZWRpYVR5cGUpICE9IG51bGwgPyBfYTUgOiBtZWRpYVR5cGU7XG4gICAgfVxuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVkaWFUeXBlID0gKF9iID0gZGV0ZWN0TWVkaWFUeXBlKHsgZGF0YSwgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzIH0pKSAhPSBudWxsID8gX2IgOiBtZWRpYVR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUgIT0gbnVsbCA/IG1lZGlhVHlwZSA6IFwiaW1hZ2UvKlwiLFxuICAgICAgICAvLyBhbnkgaW1hZ2VcbiAgICAgICAgZmlsZW5hbWU6IHZvaWQgMCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgaWYgKG1lZGlhVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVkaWEgdHlwZSBpcyBtaXNzaW5nIGZvciBmaWxlIHBhcnRgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuaW1wb3J0IHsgYXNTY2hlbWEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPiAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBhY3RpdmVUb29sc1xufSkge1xuICBpZiAoIWlzTm9uRW1wdHlPYmplY3QodG9vbHMpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xzOiB2b2lkIDAsXG4gICAgICB0b29sQ2hvaWNlOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGNvbnN0IGZpbHRlcmVkVG9vbHMgPSBhY3RpdmVUb29scyAhPSBudWxsID8gT2JqZWN0LmVudHJpZXModG9vbHMpLmZpbHRlcihcbiAgICAoW25hbWU1XSkgPT4gYWN0aXZlVG9vbHMuaW5jbHVkZXMobmFtZTUpXG4gICkgOiBPYmplY3QuZW50cmllcyh0b29scyk7XG4gIHJldHVybiB7XG4gICAgdG9vbHM6IGZpbHRlcmVkVG9vbHMubWFwKChbbmFtZTUsIHRvb2xdKSA9PiB7XG4gICAgICBjb25zdCB0b29sVHlwZSA9IHRvb2wudHlwZTtcbiAgICAgIHN3aXRjaCAodG9vbFR5cGUpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lNSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogYXNTY2hlbWEodG9vbC5wYXJhbWV0ZXJzKS5qc29uU2NoZW1hXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInByb3ZpZGVyLWRlZmluZWRcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJwcm92aWRlci1kZWZpbmVkXCIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lNSxcbiAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgYXJnczogdG9vbC5hcmdzXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IHRvb2xUeXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdG9vbCB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRvb2xDaG9pY2U6IHRvb2xDaG9pY2UgPT0gbnVsbCA/IHsgdHlwZTogXCJhdXRvXCIgfSA6IHR5cGVvZiB0b29sQ2hvaWNlID09PSBcInN0cmluZ1wiID8geyB0eXBlOiB0b29sQ2hvaWNlIH0gOiB7IHR5cGU6IFwidG9vbFwiLCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSB9XG4gIH07XG59XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuaW1wb3J0IHsgSW52YWxpZFByb21wdEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejcgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L21lc3NhZ2UudHNcbmltcG9ydCB7IHogYXMgejYgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbmltcG9ydCB7IHogYXMgejMgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvdHlwZXMvanNvbi12YWx1ZS50c1xuaW1wb3J0IHsgeiBhcyB6MiB9IGZyb20gXCJ6b2RcIjtcbnZhciBqc29uVmFsdWVTY2hlbWEgPSB6Mi5sYXp5KFxuICAoKSA9PiB6Mi51bmlvbihbXG4gICAgejIubnVsbCgpLFxuICAgIHoyLnN0cmluZygpLFxuICAgIHoyLm51bWJlcigpLFxuICAgIHoyLmJvb2xlYW4oKSxcbiAgICB6Mi5yZWNvcmQoejIuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYSksXG4gICAgejIuYXJyYXkoanNvblZhbHVlU2NoZW1hKVxuICBdKVxuKTtcblxuLy8gY29yZS90eXBlcy9wcm92aWRlci1tZXRhZGF0YS50c1xudmFyIHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEgPSB6My5yZWNvcmQoXG4gIHozLnN0cmluZygpLFxuICB6My5yZWNvcmQoejMuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYSlcbik7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnRlbnQtcGFydC50c1xuaW1wb3J0IHsgeiBhcyB6NSB9IGZyb20gXCJ6b2RcIjtcblxuLy8gY29yZS9wcm9tcHQvdG9vbC1yZXN1bHQtY29udGVudC50c1xuaW1wb3J0IHsgeiBhcyB6NCB9IGZyb20gXCJ6b2RcIjtcbnZhciB0b29sUmVzdWx0Q29udGVudFNjaGVtYSA9IHo0LmFycmF5KFxuICB6NC51bmlvbihbXG4gICAgejQub2JqZWN0KHsgdHlwZTogejQubGl0ZXJhbChcInRleHRcIiksIHRleHQ6IHo0LnN0cmluZygpIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2VcIiksXG4gICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgIG1lZGlhVHlwZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgIH0pXG4gIF0pXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbnZhciB0ZXh0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6NS5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGltYWdlUGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJpbWFnZVwiKSxcbiAgaW1hZ2U6IHo1LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejUuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1lZGlhVHlwZTogejUuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGZpbGVQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImZpbGVcIiksXG4gIGRhdGE6IHo1LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejUuaW5zdGFuY2VvZihVUkwpXSksXG4gIGZpbGVuYW1lOiB6NS5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBtZWRpYVR5cGU6IHo1LnN0cmluZygpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgcmVhc29uaW5nUGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJyZWFzb25pbmdcIiksXG4gIHRleHQ6IHo1LnN0cmluZygpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbENhbGxQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgYXJnczogejUudW5rbm93bigpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbFJlc3VsdFBhcnRTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICB0eXBlOiB6NS5saXRlcmFsKFwidG9vbC1yZXN1bHRcIiksXG4gIHRvb2xDYWxsSWQ6IHo1LnN0cmluZygpLFxuICB0b29sTmFtZTogejUuc3RyaW5nKCksXG4gIHJlc3VsdDogejUudW5rbm93bigpLFxuICBjb250ZW50OiB0b29sUmVzdWx0Q29udGVudFNjaGVtYS5vcHRpb25hbCgpLFxuICBpc0Vycm9yOiB6NS5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG52YXIgc3lzdGVtTW9kZWxNZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KFxuICB7XG4gICAgcm9sZTogejYubGl0ZXJhbChcInN5c3RlbVwiKSxcbiAgICBjb250ZW50OiB6Ni5zdHJpbmcoKSxcbiAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICB9XG4pO1xudmFyIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICByb2xlOiB6Ni5saXRlcmFsKFwidXNlclwiKSxcbiAgY29udGVudDogejYudW5pb24oW1xuICAgIHo2LnN0cmluZygpLFxuICAgIHo2LmFycmF5KHo2LnVuaW9uKFt0ZXh0UGFydFNjaGVtYSwgaW1hZ2VQYXJ0U2NoZW1hLCBmaWxlUGFydFNjaGVtYV0pKVxuICBdKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGFzc2lzdGFudE1vZGVsTWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJhc3Npc3RhbnRcIiksXG4gIGNvbnRlbnQ6IHo2LnVuaW9uKFtcbiAgICB6Ni5zdHJpbmcoKSxcbiAgICB6Ni5hcnJheShcbiAgICAgIHo2LnVuaW9uKFtcbiAgICAgICAgdGV4dFBhcnRTY2hlbWEsXG4gICAgICAgIGZpbGVQYXJ0U2NoZW1hLFxuICAgICAgICByZWFzb25pbmdQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sQ2FsbFBhcnRTY2hlbWFcbiAgICAgIF0pXG4gICAgKVxuICBdKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHRvb2xNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6Ni5vYmplY3Qoe1xuICByb2xlOiB6Ni5saXRlcmFsKFwidG9vbFwiKSxcbiAgY29udGVudDogejYuYXJyYXkodG9vbFJlc3VsdFBhcnRTY2hlbWEpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgbW9kZWxNZXNzYWdlU2NoZW1hID0gejYudW5pb24oW1xuICBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIGFzc2lzdGFudE1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYVxuXSk7XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuYXN5bmMgZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQocHJvbXB0KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5zeXN0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGxldCBtZXNzYWdlcztcbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnByb21wdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1lc3NhZ2VzID0gW3sgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQ6IHByb21wdC5wcm9tcHQgfV07XG4gIH0gZWxzZSBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkocHJvbXB0LnByb21wdCkpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5wcm9tcHQ7XG4gIH0gZWxzZSBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBtZXNzYWdlcyA9IHByb21wdC5tZXNzYWdlcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJtZXNzYWdlcyBtdXN0IG5vdCBiZSBlbXB0eVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICB2YWx1ZTogbWVzc2FnZXMsXG4gICAgc2NoZW1hOiB6Ny5hcnJheShtb2RlbE1lc3NhZ2VTY2hlbWEpXG4gIH0pO1xuICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJUaGUgbWVzc2FnZXMgbXVzdCBiZSBhIE1vZGVsTWVzc2FnZVtdLiBJZiB5b3UgaGF2ZSBwYXNzZWQgYSBVSU1lc3NhZ2VbXSwgeW91IGNhbiB1c2UgY29udmVydFRvTW9kZWxNZXNzYWdlcyB0byBjb252ZXJ0IHRoZW0uXCIsXG4gICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH07XG59XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJhbWV0ZXIsXG4gICAgdmFsdWUsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTMsXG4gICAgICBtZXNzYWdlOiBgSW52YWxpZCBhcmd1bWVudCBmb3IgcGFyYW1ldGVyICR7cGFyYW1ldGVyfTogJHttZXNzYWdlfWBcbiAgICB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG59O1xuX2EzID0gc3ltYm9sMztcblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4T3V0cHV0VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBzdG9wU2VxdWVuY2VzXG59KSB7XG4gIGlmIChtYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhPdXRwdXRUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4T3V0cHV0VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4T3V0cHV0VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heE91dHB1dFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhPdXRwdXRUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heE91dHB1dFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhPdXRwdXRUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wS1wiLFxuICAgICAgICB2YWx1ZTogdG9wSyxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BLIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4T3V0cHV0VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzLFxuICAgIHNlZWRcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZGVsYXksIGdldEVycm9yTWVzc2FnZSwgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvcmV0cnktZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjUgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU0ID0gXCJBSV9SZXRyeUVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNH1gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBSZXRyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTQsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTRdID0gdHJ1ZTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yc1tlcnJvcnMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG5cbi8vIHNyYy91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xudmFyIHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMlxufSA9IHt9KSA9PiBhc3luYyAoZikgPT4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSk7XG5hc3luYyBmdW5jdGlvbiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShlcnJvcik7XG4gICAgY29uc3QgbmV3RXJyb3JzID0gWy4uLmVycm9ycywgZXJyb3JdO1xuICAgIGNvbnN0IHRyeU51bWJlciA9IG5ld0Vycm9ycy5sZW5ndGg7XG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogXCJtYXhSZXRyaWVzRXhjZWVkZWRcIixcbiAgICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBBUElDYWxsRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgJiYgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiYgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAgeyBtYXhSZXRyaWVzLCBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsIGJhY2tvZmZGYWN0b3IgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWwvcHJlcGFyZS1yZXRyaWVzLnRzXG5mdW5jdGlvbiBwcmVwYXJlUmV0cmllcyh7XG4gIG1heFJldHJpZXNcbn0pIHtcbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heFJldHJpZXNSZXN1bHQgPSBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMjtcbiAgcmV0dXJuIHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0LFxuICAgIHJldHJ5OiByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0IH0pXG4gIH07XG59XG5leHBvcnQge1xuICBjb252ZXJ0QXN5bmNJdGVyYXRvclRvUmVhZGFibGVTdHJlYW0sXG4gIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQsXG4gIHByZXBhcmVDYWxsU2V0dGluZ3MsXG4gIHByZXBhcmVSZXRyaWVzLFxuICBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlLFxuICBzdGFuZGFyZGl6ZVByb21wdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/rsc/node_modules/ai/dist/internal/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/rsc/dist/rsc-shared.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/rsc/dist/rsc-shared.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // src/streamable-value/streamable-value.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\n// src/streamable-value/is-streamable-value.ts\nfunction isStreamableValue(value) {\n    return value != null && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE;\n}\n// src/streamable-value/read-streamable-value.tsx\nfunction readStreamableValue(streamableValue) {\n    if (!isStreamableValue(streamableValue)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let value = row.curr;\n            let isDone = false;\n            let isFirstIteration = true;\n            return {\n                async next () {\n                    if (isDone) return {\n                        value,\n                        done: true\n                    };\n                    row = await row;\n                    if (row.error !== void 0) {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            if (row.diff[0] === 0) {\n                                if (typeof value !== \"string\") {\n                                    throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                }\n                                value = value + row.diff[1];\n                            }\n                        } else {\n                            value = row.curr;\n                        }\n                        if (!row.next) {\n                            isDone = true;\n                            return {\n                                value,\n                                done: false\n                            };\n                        }\n                    }\n                    if (row.next === void 0) {\n                        return {\n                            value,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (isFirstIteration) {\n                        isFirstIteration = false;\n                        if (value === void 0) {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\n// src/streamable-value/use-streamable-value.tsx\n\nfunction checkStreamableValue(value) {\n    const hasSignature = isStreamableValue(value);\n    if (!hasSignature && value !== void 0) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"useStreamableValue.useLayoutEffect\": ()=>{\n            if (!checkStreamableValue(streamableValue)) return;\n            let cancelled = false;\n            const iterator = readStreamableValue(streamableValue);\n            if (streamableValue.next) {\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)({\n                    \"useStreamableValue.useLayoutEffect\": ()=>{\n                        if (cancelled) return;\n                        setPending(true);\n                    }\n                }[\"useStreamableValue.useLayoutEffect\"]);\n            }\n            ({\n                \"useStreamableValue.useLayoutEffect\": async ()=>{\n                    try {\n                        for await (const value of iterator){\n                            if (cancelled) return;\n                            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)({\n                                \"useStreamableValue.useLayoutEffect\": ()=>{\n                                    if (cancelled) return;\n                                    setCurr(value);\n                                }\n                            }[\"useStreamableValue.useLayoutEffect\"]);\n                        }\n                    } catch (e) {\n                        if (cancelled) return;\n                        (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)({\n                            \"useStreamableValue.useLayoutEffect\": ()=>{\n                                if (cancelled) return;\n                                setError(e);\n                            }\n                        }[\"useStreamableValue.useLayoutEffect\"]);\n                    } finally{\n                        if (cancelled) return;\n                        (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)({\n                            \"useStreamableValue.useLayoutEffect\": ()=>{\n                                if (cancelled) return;\n                                setPending(false);\n                            }\n                        }[\"useStreamableValue.useLayoutEffect\"]);\n                    }\n                }\n            })[\"useStreamableValue.useLayoutEffect\"]();\n            return ({\n                \"useStreamableValue.useLayoutEffect\": ()=>{\n                    cancelled = true;\n                }\n            })[\"useStreamableValue.useLayoutEffect\"];\n        }\n    }[\"useStreamableValue.useLayoutEffect\"], [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// src/shared-client/context.tsx\n\n\n// src/util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// src/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"InternalAIProvider.useMemo\": ()=>{\n            if (resolvedInitialAIStatePatch) {\n                return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n            }\n            return initialAIState;\n        }\n    }[\"InternalAIProvider.useMemo\"], [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"InternalAIProvider.useEffect\": ()=>{\n            aiStateRef.current = aiState[0];\n        }\n    }[\"InternalAIProvider.useEffect\"], [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"InternalAIProvider.useMemo[clientWrappedActions]\": ()=>Object.fromEntries(Object.entries(wrappedActions).map({\n                \"InternalAIProvider.useMemo[clientWrappedActions]\": ([key, action])=>[\n                        key,\n                        {\n                            \"InternalAIProvider.useMemo[clientWrappedActions]\": async (...args)=>{\n                                const aiStateSnapshot = aiStateRef.current;\n                                const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                                ({\n                                    \"InternalAIProvider.useMemo[clientWrappedActions]\": async ()=>{\n                                        const delta = await aiStateDelta;\n                                        if (delta !== void 0) {\n                                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                                        }\n                                    }\n                                })[\"InternalAIProvider.useMemo[clientWrappedActions]\"]();\n                                return result;\n                            }\n                        }[\"InternalAIProvider.useMemo[clientWrappedActions]\"]\n                    ]\n            }[\"InternalAIProvider.useMemo[clientWrappedActions]\"]))\n    }[\"InternalAIProvider.useMemo[clientWrappedActions]\"], [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\": ()=>{\n            if (!wrappedSyncUIState) {\n                return ({\n                    \"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\": ()=>{}\n                })[\"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\"];\n            }\n            return ({\n                \"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\": async ()=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n                    if (uiState2 !== void 0) {\n                        setUIState(uiState2);\n                    }\n                    const delta = await aiStateDelta;\n                    if (delta !== void 0) {\n                        const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                        setAIState(patchedAiState);\n                    }\n                }\n            })[\"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\"];\n        }\n    }[\"InternalAIProvider.useMemo[clientWrappedSyncUIStateAction]\"], [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : ({\n        \"useAIState.useCallback[setter]\": (newState)=>{\n            if (isFunction(newState)) {\n                return state[1]({\n                    \"useAIState.useCallback[setter]\": (s)=>{\n                        return {\n                            ...s,\n                            [key]: newState(s[key])\n                        };\n                    }\n                }[\"useAIState.useCallback[setter]\"]);\n            } else {\n                return state[1]({\n                    ...state[0],\n                    [key]: newState\n                });\n            }\n        }\n    })[\"useAIState.useCallback[setter]\"], [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yc2MvZGlzdC9yc2Mtc2hhcmVkLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBTyxJQUFNLHdCQUF3QixPQUFPLElBQUkscUJBQXFCOztBQ0U5RCxTQUFTLGtCQUFrQixPQUEwQztJQUMxRSxPQUNFLFNBQVMsUUFDVCxPQUFPLFVBQVUsWUFDakIsVUFBVSxTQUNWLE1BQU0sU0FBUztBQUVuQjs7QUN3Qk8sU0FBUyxvQkFDZCxpQkFDOEI7SUFDOUIsSUFBSSxDQUFDLGtCQUFrQixlQUFlLEdBQUc7UUFDdkMsTUFBTSxJQUFJLE1BQ1I7SUFFSjtJQUVBLE9BQU87UUFDTCxDQUFDLE9BQU8sYUFBYSxJQUFJO1lBQ3ZCLElBQUksTUFDRjtZQUNGLElBQUksUUFBUSxJQUFJO1lBQ2hCLElBQUksU0FBUztZQUNiLElBQUksbUJBQW1CO1lBRXZCLE9BQU87Z0JBQ0wsTUFBTSxPQUFPO29CQUVYLElBQUksUUFBUSxPQUFPO3dCQUFFO3dCQUFPLE1BQU07b0JBQUs7b0JBR3ZDLE1BQU0sTUFBTTtvQkFHWixJQUFJLElBQUksVUFBVSxRQUFXO3dCQUMzQixNQUFNLElBQUk7b0JBQ1o7b0JBR0EsSUFBSSxVQUFVLE9BQU8sSUFBSSxNQUFNO3dCQUM3QixJQUFJLElBQUksTUFBTTs0QkFFWixJQUFJLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRztnQ0FDckIsSUFBSSxPQUFPLFVBQVUsVUFBVTtvQ0FDN0IsTUFBTSxJQUFJLE1BQ1I7Z0NBRUo7Z0NBR0MsUUFBbUIsUUFBUSxJQUFJLEtBQUssQ0FBQzs0QkFDeEM7d0JBQ0YsT0FBTzs0QkFFTCxRQUFRLElBQUk7d0JBQ2Q7d0JBSUEsSUFBSSxDQUFDLElBQUksTUFBTTs0QkFDYixTQUFTOzRCQUNULE9BQU87Z0NBQUU7Z0NBQU8sTUFBTTs0QkFBTTt3QkFDOUI7b0JBQ0Y7b0JBR0EsSUFBSSxJQUFJLFNBQVMsUUFBVzt3QkFDMUIsT0FBTzs0QkFBRTs0QkFBTyxN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UyxDQUFDO1lBQ2xEO1FBQ0Y7MENBQ0o7UUFBQyxHQUFHO0tBQUE7SUFHTixJQUFJLEtBQUssV0FBVyxHQUFHO1FBQ3JCLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBTztZQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQUcsTUFBTTtTQUFBO0lBQ25DO0FBQ0Y7QUFFTyxTQUFTLGFBQTBDO0lBR3hELE1BQU0sVUFBZ0IsOENBQWMsc0JBQXNCO0lBQzFELE9BQU87QUFDVDtBQUVPLFNBQVMsaUJBQWlCO0lBQy9CLE1BQU0sY0FBb0IsOENBQ3hCO0lBR0YsSUFBSSxnQkFBZ0IsTUFBTTtRQUN4QixNQUFNLElBQUksTUFBTSx3REFBd0Q7SUFDMUU7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXHNyY1xcc3RyZWFtYWJsZS12YWx1ZVxcc3RyZWFtYWJsZS12YWx1ZS50cyIsIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXHNyY1xcc3RyZWFtYWJsZS12YWx1ZVxcaXMtc3RyZWFtYWJsZS12YWx1ZS50cyIsIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXHNyY1xcc3RyZWFtYWJsZS12YWx1ZVxccmVhZC1zdHJlYW1hYmxlLXZhbHVlLnRzeCIsIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXHNyY1xcc3RyZWFtYWJsZS12YWx1ZVxcdXNlLXN0cmVhbWFibGUtdmFsdWUudHN4IiwiQzpcXFVzZXJzXFxsaWtob1xcT25lRHJpdmVcXEdpdEh1Ylxcc3JjXFxzaGFyZWQtY2xpZW50XFxjb250ZXh0LnRzeCIsIkM6XFxVc2Vyc1xcbGlraG9cXE9uZURyaXZlXFxHaXRIdWJcXHNyY1xcdXRpbFxcaXMtZnVuY3Rpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoJ3VpLnN0cmVhbWFibGUudmFsdWUnKTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtYWJsZVBhdGNoID0gdW5kZWZpbmVkIHwgWzAsIHN0cmluZ107IC8vIEFwcGVuZCBzdHJpbmcuXG5cbmRlY2xhcmUgY29uc3QgX19pbnRlcm5hbF9jdXJyOiB1bmlxdWUgc3ltYm9sO1xuZGVjbGFyZSBjb25zdCBfX2ludGVybmFsX2Vycm9yOiB1bmlxdWUgc3ltYm9sO1xuXG4vKipcbiAqIFN0cmVhbWFibGVWYWx1ZSBpcyBhIHZhbHVlIHRoYXQgY2FuIGJlIHN0cmVhbWVkIG92ZXIgdGhlIG5ldHdvcmsgdmlhIEFJIEFjdGlvbnMuXG4gKiBUbyByZWFkIHRoZSBzdHJlYW1lZCB2YWx1ZXMsIHVzZSB0aGUgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgIEFQSXMuXG4gKi9cbmV4cG9ydCB0eXBlIFN0cmVhbWFibGVWYWx1ZTxUID0gYW55LCBFID0gYW55PiA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIHR5cGU/OiB0eXBlb2YgU1RSRUFNQUJMRV9WQUxVRV9UWVBFO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgY3Vycj86IFQ7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBlcnJvcj86IEU7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBkaWZmPzogU3RyZWFtYWJsZVBhdGNoO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgbmV4dD86IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAvLyBicmFuZGVkIHR5cGVzIHRvIG1haW50YWluIHR5cGUgc2lnbmF0dXJlIGFmdGVyIGludGVybmFsIHByb3BlcnRpZXMgYXJlIHN0cmlwcGVkLlxuICBbX19pbnRlcm5hbF9jdXJyXT86IFQ7XG4gIFtfX2ludGVybmFsX2Vycm9yXT86IEU7XG59O1xuIiwiaW1wb3J0IHsgU1RSRUFNQUJMRV9WQUxVRV9UWVBFLCBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL3N0cmVhbWFibGUtdmFsdWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJlYW1hYmxlVmFsdWUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgJ3R5cGUnIGluIHZhbHVlICYmXG4gICAgdmFsdWUudHlwZSA9PT0gU1RSRUFNQUJMRV9WQUxVRV9UWVBFXG4gICk7XG59XG4iLCJpbXBvcnQgeyBpc1N0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vaXMtc3RyZWFtYWJsZS12YWx1ZSc7XG5pbXBvcnQgeyBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL3N0cmVhbWFibGUtdmFsdWUnO1xuXG4vKipcbiAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0YWtlcyBhIHN0cmVhbWFibGUgdmFsdWUgY3JlYXRlZCB2aWEgdGhlIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKS52YWx1ZWAgQVBJLFxuICogYW5kIHJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IuXG4gKlxuICogYGBganNcbiAqIC8vIEluc2lkZSB5b3VyIEFJIGFjdGlvbjpcbiAqXG4gKiBhc3luYyBmdW5jdGlvbiBhY3Rpb24oKSB7XG4gKiAgICd1c2Ugc2VydmVyJ1xuICogICBjb25zdCBzdHJlYW1hYmxlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCk7XG4gKlxuICogICBzdHJlYW1hYmxlLnVwZGF0ZSgxKTtcbiAqICAgc3RyZWFtYWJsZS51cGRhdGUoMik7XG4gKiAgIHN0cmVhbWFibGUuZG9uZSgzKTtcbiAqICAgLy8gLi4uXG4gKiAgIHJldHVybiBzdHJlYW1hYmxlLnZhbHVlO1xuICogfVxuICogYGBgXG4gKlxuICogQW5kIHRvIHJlYWQgdGhlIHZhbHVlOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBhd2FpdCBhY3Rpb24oKVxuICogZm9yIGF3YWl0IChjb25zdCB2IG9mIHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSkge1xuICogICBjb25zb2xlLmxvZyh2KVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBsb2dzIG91dCAxLCAyLCAzIG9uIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyZWFtYWJsZVZhbHVlPFQgPSB1bmtub3duPihcbiAgc3RyZWFtYWJsZVZhbHVlOiBTdHJlYW1hYmxlVmFsdWU8VD4sXG4pOiBBc3luY0l0ZXJhYmxlPFQgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKCFpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgdmFsdWU6IHRoaXMgaG9vayBvbmx5IGFjY2VwdHMgdmFsdWVzIGNyZWF0ZWQgdmlhIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWVgLicsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIGxldCByb3c6IFN0cmVhbWFibGVWYWx1ZTxUPiB8IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQ+PiA9XG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZTtcbiAgICAgIGxldCB2YWx1ZSA9IHJvdy5jdXJyOyAvLyB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgbGV0IGlzRG9uZSA9IGZhbHNlO1xuICAgICAgbGV0IGlzRmlyc3RJdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgIC8vIHRoZSBpdGVyYXRpb24gaXMgZG9uZSBhbHJlYWR5LCByZXR1cm4gdGhlIGxhc3QgdmFsdWU6XG4gICAgICAgICAgaWYgKGlzRG9uZSkgcmV0dXJuIHsgdmFsdWUsIGRvbmU6IHRydWUgfTtcblxuICAgICAgICAgIC8vIHJlc29sdmUgdGhlIHByb21pc2UgYXQgdGhlIGJlZ2lubmluZyBvZiBlYWNoIGl0ZXJhdGlvbjpcbiAgICAgICAgICByb3cgPSBhd2FpdCByb3c7XG5cbiAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpZiBhbnk6XG4gICAgICAgICAgaWYgKHJvdy5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyByb3cuZXJyb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB2YWx1ZSBvciBhIHBhdGNoLCB1c2UgaXQ6XG4gICAgICAgICAgaWYgKCdjdXJyJyBpbiByb3cgfHwgcm93LmRpZmYpIHtcbiAgICAgICAgICAgIGlmIChyb3cuZGlmZikge1xuICAgICAgICAgICAgICAvLyBzdHJlYW1hYmxlIHBhdGNoICh0ZXh0IG9ubHkpOlxuICAgICAgICAgICAgICBpZiAocm93LmRpZmZbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBwYXRjaDogY2FuIG9ubHkgYXBwZW5kIHRvIHN0cmluZyB0eXBlcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgQUkgU0RLLicsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhc3RpbmcgcmVxdWlyZWQgdG8gcmVtb3ZlIFQgJiBzdHJpbmcgbGltaXRhdGlvblxuICAgICAgICAgICAgICAgICh2YWx1ZSBhcyBzdHJpbmcpID0gdmFsdWUgKyByb3cuZGlmZlsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgdmFsdWUgKGZ1bGwgbmV3IHZhbHVlKVxuICAgICAgICAgICAgICB2YWx1ZSA9IHJvdy5jdXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBlbWl0dGVkIHsgZG9uZTogdHJ1ZSB9IHdvbid0IGJlIHVzZWQgYXMgdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBieSB0aGUgZm9yIGF3YWl0Li4ub2Ygc3ludGF4LlxuICAgICAgICAgICAgaWYgKCFyb3cubmV4dCkge1xuICAgICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gZnVydGhlciByb3dzIHRvIGl0ZXJhdGUgb3ZlcjpcbiAgICAgICAgICBpZiAocm93Lm5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgPSByb3cubmV4dDtcblxuICAgICAgICAgIGlmIChpc0ZpcnN0SXRlcmF0aW9uKSB7XG4gICAgICAgICAgICBpc0ZpcnN0SXRlcmF0aW9uID0gZmFsc2U7IC8vIFRPRE8gc2hvdWxkIHRoaXMgYmUgc2V0IGZvciBldmVyeSByZXR1cm4/XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGluaXRpYWwgY2h1bmsgYW5kIHRoZXJlIGlzbid0IGFuIGluaXRpYWwgdmFsdWUgeWV0LlxuICAgICAgICAgICAgICAvLyBMZXQncyBza2lwIHRoaXMgb25lLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59XG4iLCJpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24sIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZWFkU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9yZWFkLXN0cmVhbWFibGUtdmFsdWUnO1xuaW1wb3J0IHsgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9zdHJlYW1hYmxlLXZhbHVlJztcbmltcG9ydCB7IGlzU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9pcy1zdHJlYW1hYmxlLXZhbHVlJztcblxuZnVuY3Rpb24gY2hlY2tTdHJlYW1hYmxlVmFsdWUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICBjb25zdCBoYXNTaWduYXR1cmUgPSBpc1N0cmVhbWFibGVWYWx1ZSh2YWx1ZSk7XG5cbiAgaWYgKCFoYXNTaWduYXR1cmUgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHZhbHVlOiB0aGlzIGhvb2sgb25seSBhY2NlcHRzIHZhbHVlcyBjcmVhdGVkIHZpYSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlYC4nLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaGFzU2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIGB1c2VTdHJlYW1hYmxlVmFsdWVgIGlzIGEgUmVhY3QgaG9vayB0aGF0IHRha2VzIGEgc3RyZWFtYWJsZSB2YWx1ZSBjcmVhdGVkIHZpYSB0aGUgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpLnZhbHVlYCBBUEksXG4gKiBhbmQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSwgZXJyb3IsIGFuZCBwZW5kaW5nIHN0YXRlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb25zdW1pbmcgc3RyZWFtYWJsZSB2YWx1ZXMgcmVjZWl2ZWQgZnJvbSBhIGNvbXBvbmVudCdzIHByb3BzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gTXlDb21wb25lbnQoeyBzdHJlYW1hYmxlVmFsdWUgfSkge1xuICogICBjb25zdCBbZGF0YSwgZXJyb3IsIHBlbmRpbmddID0gdXNlU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG4gKlxuICogICBpZiAocGVuZGluZykgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcbiAqICAgaWYgKGVycm9yKSByZXR1cm4gPGRpdj5FcnJvcjoge2Vycm9yLm1lc3NhZ2V9PC9kaXY+O1xuICpcbiAqICAgcmV0dXJuIDxkaXY+RGF0YToge2RhdGF9PC9kaXY+O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdHJlYW1hYmxlVmFsdWU8VCA9IHVua25vd24sIEVycm9yID0gdW5rbm93bj4oXG4gIHN0cmVhbWFibGVWYWx1ZT86IFN0cmVhbWFibGVWYWx1ZTxUPixcbik6IFtkYXRhOiBUIHwgdW5kZWZpbmVkLCBlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQsIHBlbmRpbmc6IGJvb2xlYW5dIHtcbiAgY29uc3QgW2N1cnIsIHNldEN1cnJdID0gdXNlU3RhdGU8VCB8IHVuZGVmaW5lZD4oXG4gICAgY2hlY2tTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5jdXJyIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPEVycm9yIHwgdW5kZWZpbmVkPihcbiAgICBjaGVja1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmVycm9yIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBbcGVuZGluZywgc2V0UGVuZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihcbiAgICBjaGVja1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gISFzdHJlYW1hYmxlVmFsdWUubmV4dCA6IGZhbHNlLFxuICApO1xuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGVja1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKSByZXR1cm47XG5cbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAgICBpZiAoc3RyZWFtYWJsZVZhbHVlLm5leHQpIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRDdXJyKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHNldEVycm9yKGUgYXMgRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc2V0UGVuZGluZyhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbc3RyZWFtYWJsZVZhbHVlXSk7XG5cbiAgcmV0dXJuIFtjdXJyLCBlcnJvciwgcGVuZGluZ107XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbid1c2UgY2xpZW50JztcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBqc29uZGlmZnBhdGNoIGZyb20gJ2pzb25kaWZmcGF0Y2gnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvaXMtZnVuY3Rpb24nO1xuaW1wb3J0IHR5cGUge1xuICBBSVByb3ZpZGVyLFxuICBJbmZlckFjdGlvbnMsXG4gIEluZmVyQUlTdGF0ZSxcbiAgSW5mZXJVSVN0YXRlLFxuICBJbnRlcm5hbEFJUHJvdmlkZXJQcm9wcyxcbiAgVmFsdWVPclVwZGF0ZXIsXG59IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuY29uc3QgSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHVuZGVmaW5lZCB8IGFueT4odW5kZWZpbmVkKTtcbmNvbnN0IEludGVybmFsQWN0aW9uUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuY29uc3QgSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEludGVybmFsQUlQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBpbml0aWFsVUlTdGF0ZSxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxBSVN0YXRlUGF0Y2gsXG4gIHdyYXBwZWRBY3Rpb25zLFxuICB3cmFwcGVkU3luY1VJU3RhdGUsXG59OiBJbnRlcm5hbEFJUHJvdmlkZXJQcm9wcykge1xuICBpZiAoISgndXNlJyBpbiBSZWFjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJlYWN0IHZlcnNpb24uJyk7XG4gIH1cblxuICBjb25zdCB1aVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbFVJU3RhdGUpO1xuICBjb25zdCBzZXRVSVN0YXRlID0gdWlTdGF0ZVsxXTtcblxuICBjb25zdCByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2ggPSBpbml0aWFsQUlTdGF0ZVBhdGNoXG4gICAgPyAoUmVhY3QgYXMgYW55KS51c2UoaW5pdGlhbEFJU3RhdGVQYXRjaClcbiAgICA6IHVuZGVmaW5lZDtcbiAgaW5pdGlhbEFJU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoKSB7XG4gICAgICByZXR1cm4ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShpbml0aWFsQUlTdGF0ZSksXG4gICAgICAgIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpbml0aWFsQUlTdGF0ZTtcbiAgfSwgW2luaXRpYWxBSVN0YXRlLCByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2hdKTtcblxuICBjb25zdCBhaVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbEFJU3RhdGUpO1xuICBjb25zdCBzZXRBSVN0YXRlID0gYWlTdGF0ZVsxXTtcbiAgY29uc3QgYWlTdGF0ZVJlZiA9IFJlYWN0LnVzZVJlZihhaVN0YXRlWzBdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFpU3RhdGVSZWYuY3VycmVudCA9IGFpU3RhdGVbMF07XG4gIH0sIFthaVN0YXRlWzBdXSk7XG5cbiAgY29uc3QgY2xpZW50V3JhcHBlZEFjdGlvbnMgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHdyYXBwZWRBY3Rpb25zKS5tYXAoKFtrZXksIGFjdGlvbl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXN5bmMgKC4uLmFyZ3M6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgW2FpU3RhdGVEZWx0YSwgcmVzdWx0XSA9IGF3YWl0IGFjdGlvbihcbiAgICAgICAgICAgICAgYWlTdGF0ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgICAgICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFpU3RhdGVbMV0oXG4gICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LFxuICAgICAgICBdKSxcbiAgICAgICksXG4gICAgW3dyYXBwZWRBY3Rpb25zXSxcbiAgKTtcblxuICBjb25zdCBjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXdyYXBwZWRTeW5jVUlTdGF0ZSkge1xuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhaVN0YXRlU25hcHNob3QgPSBhaVN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCB1aVN0YXRlXSA9XG4gICAgICAgIGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZSEoYWlTdGF0ZVNuYXBzaG90KTtcblxuICAgICAgaWYgKHVpU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRVSVN0YXRlKHVpU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWx0YSA9IGF3YWl0IGFpU3RhdGVEZWx0YTtcbiAgICAgIGlmIChkZWx0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRBaVN0YXRlID0ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICk7XG4gICAgICAgIHNldEFJU3RhdGUocGF0Y2hlZEFpU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt3cmFwcGVkU3luY1VJU3RhdGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbnRlcm5hbEFJU3RhdGVQcm92aWRlci5Qcm92aWRlciB2YWx1ZT17YWlTdGF0ZX0+XG4gICAgICA8SW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e3VpU3RhdGV9PlxuICAgICAgICA8SW50ZXJuYWxBY3Rpb25Qcm92aWRlci5Qcm92aWRlciB2YWx1ZT17Y2xpZW50V3JhcHBlZEFjdGlvbnN9PlxuICAgICAgICAgIDxJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXJcbiAgICAgICAgICAgIHZhbHVlPXtjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb259XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICAgICAgICA8L0ludGVybmFsQWN0aW9uUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgICA8L0ludGVybmFsVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICAgIDwvSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKSB7XG4gIHR5cGUgVCA9IEluZmVyVUlTdGF0ZTxBSSwgYW55PjtcblxuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8XG4gICAgW1QsICh2OiBUIHwgKCh2XzogVCkgPT4gVCkpID0+IHZvaWRdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICA+KEludGVybmFsVUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlVUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaW5pdGlhbFVJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmAnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vLyBUT0RPOiBIb3cgZG8gd2UgYXZvaWQgY2F1c2luZyBhIHJlLXJlbmRlciB3aGVuIHRoZSBBSSBzdGF0ZSBjaGFuZ2VzIGJ1dCB5b3Vcbi8vIGFyZSBvbmx5IGxpc3RlbmluZyB0byBhIHNwZWNpZmljIGtleT8gV2UgbmVlZCB1c2VTRVMgcGVyaGFwcz9cbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBbXG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PixcbiAgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxJbmZlckFJU3RhdGU8QUksIGFueT4+KSA9PiB2b2lkLFxuXTtcbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBbXG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XSxcbiAgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+KSA9PiB2b2lkLFxuXTtcbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIHR5cGUgVCA9IEluZmVyQUlTdGF0ZTxBSSwgYW55PjtcblxuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8XG4gICAgW1QsIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8VD4pID0+IHZvaWRdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICA+KEludGVybmFsQUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlQUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaW5pdGlhbEFJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmAnLFxuICAgICk7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID49IDEgJiYgdHlwZW9mIHN0YXRlWzBdICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdXaGVuIHVzaW5nIGB1c2VBSVN0YXRlYCB3aXRoIGEga2V5LCB0aGUgQUkgc3RhdGUgbXVzdCBiZSBhbiBvYmplY3QuJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgY29uc3Qgc2V0dGVyID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gc3RhdGVbMV1cbiAgICAgIDogKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxUPikgPT4ge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlWzFdKHMgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5zLCBba2V5XTogbmV3U3RhdGUoc1trZXldKSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVsxXSh7IC4uLnN0YXRlWzBdLCBba2V5XTogbmV3U3RhdGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFtrZXldLFxuICApO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3N0YXRlWzBdW2FyZ3NbMF1dLCBzZXR0ZXJdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3Rpb25zPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKSB7XG4gIHR5cGUgVCA9IEluZmVyQWN0aW9uczxBSSwgYW55PjtcblxuICBjb25zdCBhY3Rpb25zID0gUmVhY3QudXNlQ29udGV4dDxUPihJbnRlcm5hbEFjdGlvblByb3ZpZGVyKTtcbiAgcmV0dXJuIGFjdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTeW5jVUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3luY1VJU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PCgpID0+IFByb21pc2U8dm9pZD4+KFxuICAgIEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlcixcbiAgKTtcblxuICBpZiAoc3luY1VJU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VTeW5jVUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG5cbiAgcmV0dXJuIHN5bmNVSVN0YXRlO1xufVxuXG5leHBvcnQgeyB1c2VBSVN0YXRlIH07XG4iLCIvKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBGdW5jdGlvbiA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4iXSwibmFtZXMiOlsidWlTdGF0ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/rsc/dist/rsc-shared.mjs\n");

/***/ })

};
;